<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Duck Song - Got Any Grapes?</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            height: 100dvh; /* dynamic viewport height for mobile */
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: 'Comic Sans MS', cursive, sans-serif;
            overflow: hidden;
            width: 100%;
        }
        #gameContainer {
            position: relative; /* allow absolute children to center over the canvas */
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            width: 100%;
            height: 100%;
            max-width: 900px;
            overflow: hidden;
        }
        /* Make canvas fit within viewport */
        #gameCanvas {
            border: 4px solid #8B4513;
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.3);
            display: block;
            touch-action: none; /* prevent browser gestures interfering with game touches */
        }
        /* Full screen mode for mobile - detect touch devices */
        @media (pointer: coarse), (max-width: 600px) {
            html, body {
                height: 100%;
                height: -webkit-fill-available;
            }
            #gameContainer {
                padding: 0;
                max-width: none;
                height: 100%;
                height: -webkit-fill-available;
            }
            #gameCanvas {
                border: none;
                border-radius: 0;
                max-width: none;
                max-height: none;
            }
            #title, #instructions, #fullscreenBtn {
                display: none;
            }
            #ui {
                position: absolute;
                top: env(safe-area-inset-top, 10px);
                left: 50%;
                transform: translateX(-50%);
                z-index: 100;
                margin: 0;
                padding: 8px 16px;
                font-size: 14px;
                background: rgba(0,0,0,0.6);
            }
        }
        #ui {
            display: flex;
            gap: 30px;
            margin-bottom: 10px;
            color: white;
            font-size: 18px;
            background: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border-radius: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        #instructions {
            color: #aaa;
            margin-top: 10px;
            text-align: center;
            font-size: 14px;
        }
        #title {
            color: #FFD700;
            font-size: 28px;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            text-align: center;
        }
        #musicBtn, #fullscreenBtn {
            background: #FFD700;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-family: inherit;
            font-size: 14px;
            transition: transform 0.1s;
        }
        #musicBtn:hover, #fullscreenBtn:hover {
            transform: scale(1.05);
        }
        #fullscreenBtn {
            background: #4CAF50;
            color: white;
        }
        /* Fullscreen styles */
        #gameContainer:fullscreen, #gameContainer:-webkit-full-screen {
            max-width: none;
            padding: 0;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        }
        #gameContainer:fullscreen #gameCanvas, #gameContainer:-webkit-full-screen #gameCanvas {
            max-width: 100vw;
            max-height: calc(100vh - 60px);
            border: none;
            border-radius: 0;
        }
        #gameContainer:fullscreen #title, #gameContainer:-webkit-full-screen #title,
        #gameContainer:fullscreen #instructions, #gameContainer:-webkit-full-screen #instructions {
            display: none;
        }
        #gameContainer:fullscreen #ui, #gameContainer:-webkit-full-screen #ui {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            margin: 0;
        }
        #startScreen, #winScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.85);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            width: min(90%, 600px);
            box-shadow: 0 8px 30px rgba(0,0,0,0.5);
        }
        .screen-btn {
            background: #FFD700;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-family: inherit;
            font-size: 20px;
            margin-top: 20px;
            transition: transform 0.1s, background 0.2s;
        }
        .screen-btn:hover {
            transform: scale(1.1);
            background: #FFA500;
        }
        .hidden { display: none !important; }

        /* Responsive tweaks */
        @media (max-width: 600px) {
            #title { font-size: 20px; }
            #ui { font-size: 14px; gap: 10px; padding: 8px 12px; }
            #instructions { font-size: 12px; }
            .screen-btn { font-size: 18px; padding: 12px 22px; }
            #startScreen, #winScreen { padding: 20px; }
            #musicBtn { font-size: 12px; padding: 6px 12px; }
            #startScreen h1, #winScreen h1 { font-size: 28px !important; }
            #startScreen p, #winScreen p { font-size: 14px !important; }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="title">The Duck Song Game - Got Any Grapes?</div>
        <div id="ui">
            <span>Grapes: <span id="grapeCount">0</span></span>
            <span>Level: <span id="levelNum">1</span></span>
            <button id="musicBtn" onclick="toggleMusic()">Music: OFF</button>
            <button id="fullscreenBtn" onclick="toggleFullscreen()">Fullscreen</button>
        </div>
        <canvas id="gameCanvas" width="800" height="500"></canvas>
        <div id="instructions">
            WASD/Arrows: move | SPACE: jump | X/F: shoot (Lv5+) | E: helicopter (Lv6+)
        </div>

        <div id="startScreen">
            <h1 style="color: #FFD700; font-size: 36px;">The Duck Song Game</h1>
            <p style="margin: 20px 0; font-size: 18px;">Help the duck collect grapes!<br>Collect all grapes & reach the end of each level.</p>
            <p style="color: #aaa;">Desktop: Arrow Keys / WASD + Space<br>Mobile: Tilt to move, Tap to jump!<br><span style="font-size: 12px;">(Or tap left/right sides to move)</span></p>
            <div style="margin: 15px 0; width: 100%;">
                <label style="color: #aaa; font-size: 14px;">Tilt Sensitivity: <span id="sensitivityValue">50</span>%</label>
                <input type="range" id="tiltSensitivity" min="10" max="100" value="50"
                    style="width: 80%; margin-top: 8px; cursor: pointer;">
            </div>
            <button class="screen-btn" onclick="startGame()">Start Game!</button>
        </div>

        <div id="winScreen" class="hidden">
            <h1 style="color: #FFD700; font-size: 36px;">You Win!</h1>
            <p style="margin: 20px 0; font-size: 18px;">The duck finally got all the grapes!</p>
            <p style="color: #8B008B;">Total grapes collected: <span id="totalGrapes">0</span></p>
            <button class="screen-btn" onclick="startGame()">Play Again</button>
        </div>
    </div>

    <audio id="bgMusic" loop>
        <source src="duck_song.mp3" type="audio/mpeg">
    </audio>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const grapeCountEl = document.getElementById('grapeCount');
        const levelNumEl = document.getElementById('levelNum');
        const musicBtn = document.getElementById('musicBtn');
        const bgMusic = document.getElementById('bgMusic');
        const startScreen = document.getElementById('startScreen');
        const winScreen = document.getElementById('winScreen');

        // Reference dimensions (original design)
        const REF_WIDTH = 800;
        const REF_HEIGHT = 500;

        // Scale factors - updated on resize
        let scaleX = 1;
        let scaleY = 1;
        let scale = 1; // uniform scale for sprites

        // Resize canvas to fill screen
        function resizeCanvas() {
            // Use visualViewport for accurate sizing on iOS Safari
            const vv = window.visualViewport;
            const isMobile = window.matchMedia('(pointer: coarse), (max-width: 600px)').matches;

            let width, height;
            if (isMobile) {
                // On mobile, use full viewport
                width = Math.floor(vv ? vv.width : window.innerWidth);
                height = Math.floor(vv ? vv.height : window.innerHeight);
            } else {
                // On desktop, fit within container with some room for UI
                const container = document.getElementById('gameContainer');
                width = Math.min(container.clientWidth - 20, 880);
                height = Math.floor(window.innerHeight - 150);
            }

            // Set canvas internal resolution
            canvas.width = width;
            canvas.height = height;

            // Set CSS display size to match exactly (prevents distortion)
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';

            scaleX = canvas.width / REF_WIDTH;
            scaleY = canvas.height / REF_HEIGHT;
            scale = Math.min(scaleX, scaleY); // uniform scale for sprites

            // Update duck size based on scale
            duck.width = 50 * scale;
            duck.height = 60 * scale;
            duck.speed = 5 * scaleX;
            duck.jumpForce = -14 * scaleY;
        }

        // Helper to convert reference coords to screen coords
        function sx(x) { return x * scaleX; }
        function sy(y) { return y * scaleY; }

        // Game state
        let gameRunning = false;
        let demoMode = true;
        let keys = {};
        let grapes = [];
        let platforms = [];
        let level = 1;
        let grapesCollected = 0;
        let totalGrapesCollected = 0;
        let totalGrapes = 0;
        let gameMessage = '';
        let messageTimer = 0;
        let musicPlaying = false;
        let levelCompleting = false;  // Prevent multiple level completions

        // Particle system for visual effects
        let particles = [];

        // Demo AI state
        let targetGrape = null;
        let demoJumpCooldown = 0;

        const MAX_LEVEL = 15;

        // Combat system - lemon seed gun (available from level 5)
        let seeds = [];  // Projectiles
        let enemies = [];  // Enemy objects
        let lastShotTime = 0;
        const SHOT_COOLDOWN = 250;  // ms between shots

        // Helicopter system (available from level 6)
        let helicopter = {
            active: false,
            available: false,
            x: 0,
            y: 0,
            fuel: 100,
            maxFuel: 100
        };

        // ========================================
        // WORLD & CAMERA SYSTEM
        // ========================================
        let worldWidth = 2000;  // World extends beyond viewport
        const camera = { x: 0, y: 0 };
        let sceneryElements = [];  // Background objects

        // Scene definitions for each level theme
        const SCENES = {
            countryside: {
                skyColors: ['#87CEEB', '#B0E0E6'],
                hillColor: '#3CB371',
                groundColor: '#32CD32',
                groundAccent: '#228B22'
            },
            suburbs: {
                skyColors: ['#87CEEB', '#A8C8E8'],
                hillColor: '#5D8C5D',
                groundColor: '#7CBA7C',
                groundAccent: '#5A9A5A'
            },
            downtown: {
                skyColors: ['#6B8CAE', '#8899AA'],
                hillColor: '#4A4A4A',
                groundColor: '#606060',
                groundAccent: '#505050'
            }
        };

        // Get scene for current level
        function getSceneForLevel(levelNum) {
            const levelThemes = {
                1: 'countryside',
                2: 'countryside',
                3: 'suburbs',
                4: 'suburbs',
                5: 'downtown',
                6: 'downtown',
                7: 'countryside',
                8: 'suburbs',
                9: 'downtown',
                10: 'countryside',
                11: 'suburbs',
                12: 'downtown',
                13: 'countryside',
                14: 'suburbs',
                15: 'downtown'
            };
            const theme = levelThemes[levelNum] || 'countryside';
            return { ...SCENES[theme], name: theme };
        }

        // Convert world coords to screen coords
        function worldToScreen(wx, wy) {
            return { x: wx - camera.x, y: wy };
        }

        // Update camera to follow duck
        function updateCamera() {
            // Keep duck at 30% from left edge
            const targetX = duck.x - canvas.width * 0.3;
            camera.x = Math.max(0, Math.min(targetX, worldWidth - canvas.width));
        }

        // Duck player (positions will be in screen coords)
        const duck = {
            x: 100,
            y: 300,
            width: 50,
            height: 60,
            vx: 0,
            vy: 0,
            speed: 5,
            jumpForce: -14,
            onGround: false,
            facing: 1,
            walkFrame: 0,
            walkTimer: 0,
            tiltAmount: 0
        };

        // Physics (scaled on resize)
        let gravity = 0.6;
        const friction = 0.85;

        // Remove unused lemonadeStand object - position is now calculated dynamically

        function toggleMusic() {
            if (musicPlaying) {
                bgMusic.pause();
                musicBtn.textContent = 'Music: OFF';
                musicPlaying = false;
            } else {
                bgMusic.play().catch(e => console.log('Audio play failed:', e));
                musicBtn.textContent = 'Music: ON';
                musicPlaying = true;
            }
        }

        function toggleFullscreen() {
            const container = document.getElementById('gameContainer');
            const btn = document.getElementById('fullscreenBtn');

            if (!document.fullscreenElement && !document.webkitFullscreenElement) {
                // Enter fullscreen
                if (container.requestFullscreen) {
                    container.requestFullscreen();
                } else if (container.webkitRequestFullscreen) {
                    container.webkitRequestFullscreen();
                }
                btn.textContent = 'Exit Fullscreen';
            } else {
                // Exit fullscreen
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                }
                btn.textContent = 'Fullscreen';
            }
        }

        // Update button text and resize canvas when fullscreen changes
        function onFullscreenChange() {
            const btn = document.getElementById('fullscreenBtn');
            if (document.fullscreenElement || document.webkitFullscreenElement) {
                btn.textContent = 'Exit Fullscreen';
            } else {
                btn.textContent = 'Fullscreen';
            }
            // Resize canvas after a short delay to let the browser adjust
            setTimeout(() => {
                resizeCanvas();
                generateLevel(level);
            }, 100);
        }
        document.addEventListener('fullscreenchange', onFullscreenChange);
        document.addEventListener('webkitfullscreenchange', onFullscreenChange);

        // ========================================
        // NEW GRAPHICS FUNCTIONS
        // ========================================

        // Draw a tree (countryside)
        function drawTree(x, y, size) {
            const s = size * scale;
            
            // Trunk shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.fillRect(x - 6 * s, y + 2 * s, 14 * s, 48 * s);
            
            // Trunk with gradient
            const trunkGradient = ctx.createLinearGradient(x - 7 * s, y, x + 7 * s, y);
            trunkGradient.addColorStop(0, '#6F3710');
            trunkGradient.addColorStop(0.5, '#8B4513');
            trunkGradient.addColorStop(1, '#6F3710');
            ctx.fillStyle = trunkGradient;
            ctx.fillRect(x - 7 * s, y, 14 * s, 50 * s);
            
            // Trunk texture
            ctx.strokeStyle = 'rgba(60, 30, 10, 0.3)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.moveTo(x - 5 * s, y + 15 * s + i * 12 * s);
                ctx.lineTo(x + 5 * s, y + 15 * s + i * 12 * s);
                ctx.stroke();
            }
            
            // Foliage with gradient (back layer)
            const foliageGradient1 = ctx.createRadialGradient(x, y - 10 * s, 0, x, y - 10 * s, 35 * s);
            foliageGradient1.addColorStop(0, '#3CB371');
            foliageGradient1.addColorStop(0.7, '#228B22');
            foliageGradient1.addColorStop(1, '#1B5E20');
            ctx.fillStyle = foliageGradient1;
            ctx.beginPath();
            ctx.arc(x, y - 10 * s, 35 * s, 0, Math.PI * 2);
            ctx.fill();
            
            // Side foliage with gradients
            const foliageGradient2 = ctx.createRadialGradient(x - 20 * s, y + 5 * s, 0, x - 20 * s, y + 5 * s, 25 * s);
            foliageGradient2.addColorStop(0, '#3CB371');
            foliageGradient2.addColorStop(0.7, '#228B22');
            foliageGradient2.addColorStop(1, '#1B5E20');
            ctx.fillStyle = foliageGradient2;
            ctx.beginPath();
            ctx.arc(x - 20 * s, y + 5 * s, 25 * s, 0, Math.PI * 2);
            ctx.fill();
            
            const foliageGradient3 = ctx.createRadialGradient(x + 20 * s, y + 5 * s, 0, x + 20 * s, y + 5 * s, 25 * s);
            foliageGradient3.addColorStop(0, '#3CB371');
            foliageGradient3.addColorStop(0.7, '#228B22');
            foliageGradient3.addColorStop(1, '#1B5E20');
            ctx.fillStyle = foliageGradient3;
            ctx.beginPath();
            ctx.arc(x + 20 * s, y + 5 * s, 25 * s, 0, Math.PI * 2);
            ctx.fill();
            
            // Foliage highlights
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.beginPath();
            ctx.arc(x - 8 * s, y - 15 * s, 12 * s, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw a shrub (small bush)
        function drawShrub(x, y, size) {
            const s = (size || 1) * scale;
            
            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.beginPath();
            ctx.arc(x, y, 16 * s, 0, Math.PI * 2);
            ctx.fill();
            
            // Main bush with gradient
            const bushGradient = ctx.createRadialGradient(x - 3 * s, y - 10 * s, 0, x, y - 8 * s, 15 * s);
            bushGradient.addColorStop(0, '#3CB371');
            bushGradient.addColorStop(0.6, '#2E8B57');
            bushGradient.addColorStop(1, '#1B5E20');
            ctx.fillStyle = bushGradient;
            ctx.beginPath();
            ctx.arc(x, y - 8 * s, 15 * s, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(x - 10 * s, y - 3 * s, 10 * s, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(x + 10 * s, y - 3 * s, 10 * s, 0, Math.PI * 2);
            ctx.fill();
            
            // Highlight
            ctx.fillStyle = 'rgba(255, 255, 255, 0.25)';
            ctx.beginPath();
            ctx.arc(x - 3 * s, y - 10 * s, 6 * s, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw a flower
        function drawFlower(x, y, color) {
            const s = scale;
            
            // Stem with gradient
            const stemGradient = ctx.createLinearGradient(x, y, x, y - 15 * s);
            stemGradient.addColorStop(0, '#1B5E20');
            stemGradient.addColorStop(1, '#4CAF50');
            ctx.strokeStyle = stemGradient;
            ctx.lineWidth = 2.5 * s;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x, y - 15 * s);
            ctx.stroke();
            
            // Leaf
            ctx.fillStyle = '#4CAF50';
            ctx.beginPath();
            ctx.ellipse(x - 4 * s, y - 8 * s, 3 * s, 5 * s, -0.5, 0, Math.PI * 2);
            ctx.fill();
            
            // Petals with gradient
            const petalColor = color || '#FF69B4';
            for (let i = 0; i < 5; i++) {
                const angle = (i / 5) * Math.PI * 2;
                const px = x + Math.cos(angle) * 5 * s;
                const py = y - 15 * s + Math.sin(angle) * 5 * s;
                
                const petalGradient = ctx.createRadialGradient(px - s, py - s, 0, px, py, 4 * s);
                petalGradient.addColorStop(0, petalColor);
                petalGradient.addColorStop(1, petalColor + 'CC');
                ctx.fillStyle = petalGradient;
                ctx.beginPath();
                ctx.arc(px, py, 4 * s, 0, Math.PI * 2);
                ctx.fill();
                
                // Petal highlight
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.beginPath();
                ctx.arc(px - s * 0.8, py - s * 0.8, 1.5 * s, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Center with gradient
            const centerGradient = ctx.createRadialGradient(x - s, y - 15 * s - s, 0, x, y - 15 * s, 3 * s);
            centerGradient.addColorStop(0, '#FFD700');
            centerGradient.addColorStop(1, '#FFA500');
            ctx.fillStyle = centerGradient;
            ctx.beginPath();
            ctx.arc(x, y - 15 * s, 3 * s, 0, Math.PI * 2);
            ctx.fill();
            
            // Center details (stamens)
            ctx.fillStyle = '#FF8C00';
            for (let i = 0; i < 3; i++) {
                const angle = (i / 3) * Math.PI * 2;
                ctx.beginPath();
                ctx.arc(x + Math.cos(angle) * s, y - 15 * s + Math.sin(angle) * s, 0.5 * s, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Draw a picket fence section
        function drawFence(x, y, width) {
            const s = scale;
            const postSpacing = 20 * s;
            ctx.fillStyle = '#F5F5DC';
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 1;
            // Horizontal rails
            ctx.fillRect(x, y - 25 * s, width, 5 * s);
            ctx.fillRect(x, y - 10 * s, width, 5 * s);
            // Pickets
            for (let px = x; px < x + width; px += postSpacing) {
                ctx.fillStyle = '#F5F5DC';
                ctx.beginPath();
                ctx.moveTo(px, y);
                ctx.lineTo(px, y - 35 * s);
                ctx.lineTo(px + 5 * s, y - 40 * s);
                ctx.lineTo(px + 10 * s, y - 35 * s);
                ctx.lineTo(px + 10 * s, y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
        }

        // Draw a suburban house
        function drawHouse(x, y, style) {
            const s = scale;
            const width = (80 + style * 20) * s;
            const height = (60 + style * 10) * s;
            const colors = ['#D2691E', '#8B0000', '#4169E1', '#2F4F4F'];
            const roofColors = ['#8B4513', '#A52A2A', '#696969', '#2F2F2F'];

            // House body
            ctx.fillStyle = colors[style % colors.length];
            ctx.fillRect(x - width/2, y - height, width, height);
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.strokeRect(x - width/2, y - height, width, height);

            // Roof
            ctx.fillStyle = roofColors[style % roofColors.length];
            ctx.beginPath();
            ctx.moveTo(x - width/2 - 10 * s, y - height);
            ctx.lineTo(x, y - height - 40 * s);
            ctx.lineTo(x + width/2 + 10 * s, y - height);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Door
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(x - 10 * s, y - 40 * s, 20 * s, 40 * s);
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(x + 5 * s, y - 20 * s, 2 * s, 0, Math.PI * 2);
            ctx.fill();

            // Windows
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(x - width/2 + 10 * s, y - height + 15 * s, 15 * s, 15 * s);
            ctx.fillRect(x + width/2 - 25 * s, y - height + 15 * s, 15 * s, 15 * s);
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 1;
            ctx.strokeRect(x - width/2 + 10 * s, y - height + 15 * s, 15 * s, 15 * s);
            ctx.strokeRect(x + width/2 - 25 * s, y - height + 15 * s, 15 * s, 15 * s);
        }

        // Draw a mailbox
        function drawMailbox(x, y) {
            const s = scale;
            // Post
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(x - 3 * s, y - 35 * s, 6 * s, 35 * s);
            // Box
            ctx.fillStyle = '#4169E1';
            ctx.fillRect(x - 12 * s, y - 50 * s, 24 * s, 18 * s);
            // Flag
            ctx.fillStyle = '#FF0000';
            ctx.fillRect(x + 12 * s, y - 50 * s, 3 * s, 12 * s);
        }

        // Draw a city building
        function drawBuilding(x, y, width, height, style) {
            const s = scale;
            const w = width * s;
            const h = height * s;
            const colors = ['#708090', '#5F5F5F', '#4A4A4A', '#363636', '#2F4F4F'];

            // Building body
            ctx.fillStyle = colors[style % colors.length];
            ctx.fillRect(x - w/2, y - h, w, h);
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.strokeRect(x - w/2, y - h, w, h);

            // Windows grid
            const windowSize = 12 * s;
            const windowSpacing = 20 * s;
            const margin = 15 * s;

            for (let wy = y - h + margin; wy < y - margin; wy += windowSpacing) {
                for (let wx = x - w/2 + margin; wx < x + w/2 - margin; wx += windowSpacing) {
                    // Randomly lit windows
                    const lit = Math.sin(wx * 0.1 + wy * 0.1 + style) > 0;
                    ctx.fillStyle = lit ? '#FFFF99' : '#333';
                    ctx.fillRect(wx, wy, windowSize, windowSize);
                }
            }

            // Rooftop details
            if (style % 2 === 0) {
                // Water tower
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(x - 8 * s, y - h - 20 * s, 16 * s, 20 * s);
            } else {
                // Antenna
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x, y - h);
                ctx.lineTo(x, y - h - 30 * s);
                ctx.stroke();
            }
        }

        // Draw a lamp post
        function drawLampPost(x, y) {
            const s = scale;
            // Pole
            ctx.fillStyle = '#2F2F2F';
            ctx.fillRect(x - 3 * s, y - 80 * s, 6 * s, 80 * s);
            // Lamp head
            ctx.fillStyle = '#333';
            ctx.fillRect(x - 12 * s, y - 85 * s, 24 * s, 8 * s);
            // Light glow
            const gradient = ctx.createRadialGradient(x, y - 80 * s, 0, x, y - 80 * s, 40 * s);
            gradient.addColorStop(0, 'rgba(255, 255, 200, 0.3)');
            gradient.addColorStop(1, 'rgba(255, 255, 200, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y - 70 * s, 40 * s, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw a fire hydrant
        function drawFireHydrant(x, y) {
            const s = scale;
            ctx.fillStyle = '#FF0000';
            // Body
            ctx.fillRect(x - 6 * s, y - 25 * s, 12 * s, 25 * s);
            // Top
            ctx.beginPath();
            ctx.arc(x, y - 25 * s, 8 * s, Math.PI, 0);
            ctx.fill();
            // Side nozzles
            ctx.fillRect(x - 12 * s, y - 18 * s, 6 * s, 6 * s);
            ctx.fillRect(x + 6 * s, y - 18 * s, 6 * s, 6 * s);
        }

        // Draw a bench
        function drawBench(x, y) {
            const s = scale;
            ctx.fillStyle = '#8B4513';
            // Seat
            ctx.fillRect(x - 25 * s, y - 18 * s, 50 * s, 6 * s);
            // Back
            ctx.fillRect(x - 25 * s, y - 35 * s, 50 * s, 5 * s);
            // Legs
            ctx.fillRect(x - 22 * s, y - 18 * s, 4 * s, 18 * s);
            ctx.fillRect(x + 18 * s, y - 18 * s, 4 * s, 18 * s);
            // Back supports
            ctx.fillRect(x - 22 * s, y - 35 * s, 4 * s, 17 * s);
            ctx.fillRect(x + 18 * s, y - 35 * s, 4 * s, 17 * s);
        }

        // Draw a street sign
        function drawStreetSign(x, y, text) {
            const s = scale;
            // Pole
            ctx.fillStyle = '#4A4A4A';
            ctx.fillRect(x - 2 * s, y - 60 * s, 4 * s, 60 * s);
            // Sign
            ctx.fillStyle = '#228B22';
            ctx.fillRect(x - 30 * s, y - 70 * s, 60 * s, 15 * s);
            ctx.fillStyle = '#FFF';
            ctx.font = `bold ${8 * s}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText(text || 'MAIN ST', x, y - 60 * s);
        }

        // Draw finish banner/flag at end of level
        function drawFinishBanner(x, y) {
            const s = scale;
            // Pole
            ctx.fillStyle = '#4A4A4A';
            ctx.fillRect(x - 3 * s, y - 120 * s, 6 * s, 120 * s);
            // Banner
            ctx.fillStyle = '#FF0000';
            ctx.beginPath();
            ctx.moveTo(x + 3 * s, y - 120 * s);
            ctx.lineTo(x + 60 * s, y - 100 * s);
            ctx.lineTo(x + 3 * s, y - 80 * s);
            ctx.closePath();
            ctx.fill();
            // Checkered pattern
            ctx.fillStyle = '#FFF';
            ctx.fillRect(x + 10 * s, y - 115 * s, 15 * s, 10 * s);
            ctx.fillRect(x + 25 * s, y - 105 * s, 15 * s, 10 * s);
            ctx.fillRect(x + 10 * s, y - 95 * s, 15 * s, 10 * s);
            // Text
            ctx.fillStyle = '#FFD700';
            ctx.font = `bold ${10 * s}px Comic Sans MS`;
            ctx.textAlign = 'center';
            ctx.fillText('FINISH', x + 25 * s, y - 70 * s);
        }

        // Draw scenery element based on type
        function drawSceneryElement(elem, screenX) {
            const groundY = canvas.height * 0.86;
            switch (elem.type) {
                case 'tree':
                    drawTree(screenX, groundY, elem.size || 1);
                    break;
                case 'shrub':
                    drawShrub(screenX, groundY, elem.size || 1);
                    break;
                case 'flower':
                    drawFlower(screenX, groundY, elem.color);
                    break;
                case 'fence':
                    drawFence(screenX, groundY, elem.width * scale);
                    break;
                case 'house':
                    drawHouse(screenX, groundY, elem.style);
                    break;
                case 'mailbox':
                    drawMailbox(screenX, groundY);
                    break;
                case 'building':
                    drawBuilding(screenX, groundY, elem.width, elem.height, elem.style);
                    break;
                case 'lamppost':
                    drawLampPost(screenX, groundY);
                    break;
                case 'hydrant':
                    drawFireHydrant(screenX, groundY);
                    break;
                case 'bench':
                    drawBench(screenX, groundY);
                    break;
                case 'sign':
                    drawStreetSign(screenX, groundY, elem.text);
                    break;
                case 'finishBanner':
                    drawFinishBanner(screenX, groundY);
                    break;
            }
        }

        // ========================================
        // PROGRAMMATIC BACKGROUND DRAWING
        // ========================================

        // Draw cloud
        function drawCloud(x, y, size) {
            const s = size * scale;
            
            // Cloud shadow (subtle)
            ctx.fillStyle = 'rgba(200, 200, 220, 0.3)';
            ctx.beginPath();
            ctx.arc(x + 2 * s, y + 2 * s, 20 * s, 0, Math.PI * 2);
            ctx.arc(x + 27 * s, y - 3 * s, 25 * s, 0, Math.PI * 2);
            ctx.arc(x + 52 * s, y + 2 * s, 20 * s, 0, Math.PI * 2);
            ctx.arc(x + 17 * s, y + 12 * s, 15 * s, 0, Math.PI * 2);
            ctx.arc(x + 37 * s, y + 10 * s, 18 * s, 0, Math.PI * 2);
            ctx.fill();
            
            // Main cloud with soft gradient
            const cloudGradient = ctx.createRadialGradient(x + 25 * s, y, 0, x + 25 * s, y, 50 * s);
            cloudGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            cloudGradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.95)');
            cloudGradient.addColorStop(1, 'rgba(240, 240, 250, 0.85)');
            ctx.fillStyle = cloudGradient;
            ctx.beginPath();
            ctx.arc(x, y, 20 * s, 0, Math.PI * 2);
            ctx.arc(x + 25 * s, y - 5 * s, 25 * s, 0, Math.PI * 2);
            ctx.arc(x + 50 * s, y, 20 * s, 0, Math.PI * 2);
            ctx.arc(x + 15 * s, y + 10 * s, 15 * s, 0, Math.PI * 2);
            ctx.arc(x + 35 * s, y + 8 * s, 18 * s, 0, Math.PI * 2);
            ctx.fill();
            
            // Cloud highlights
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.beginPath();
            ctx.arc(x + 20 * s, y - 8 * s, 10 * s, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 45 * s, y - 3 * s, 8 * s, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw backgrounds (consistent per level)
        function drawBackgrounds() {
            const groundY = canvas.height * 0.86;
            const scene = getSceneForLevel(level);
            const horizonY = canvas.height * 0.6;

            // Sky gradient
            const skyGradient = ctx.createLinearGradient(0, 0, 0, horizonY);
            skyGradient.addColorStop(0, scene.skyColors[0]);
            skyGradient.addColorStop(1, scene.skyColors[1]);
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, horizonY);

            // Sun (with parallax and glow)
            const parallaxOffset = camera.x * 0.1;
            const sunX = canvas.width * 0.85 - parallaxOffset * 0.3;
            const sunY = canvas.height * 0.12;
            const sunR = 35 * scale;
            
            // Sun glow (outer)
            const sunGlowOuter = ctx.createRadialGradient(sunX, sunY, sunR * 0.5, sunX, sunY, sunR * 2.5);
            sunGlowOuter.addColorStop(0, 'rgba(255, 223, 0, 0.3)');
            sunGlowOuter.addColorStop(0.5, 'rgba(255, 215, 0, 0.15)');
            sunGlowOuter.addColorStop(1, 'rgba(255, 215, 0, 0)');
            ctx.fillStyle = sunGlowOuter;
            ctx.beginPath();
            ctx.arc(sunX, sunY, sunR * 2.5, 0, Math.PI * 2);
            ctx.fill();
            
            // Sun body with gradient
            const sunGradient = ctx.createRadialGradient(sunX - sunR * 0.3, sunY - sunR * 0.3, 0, sunX, sunY, sunR);
            sunGradient.addColorStop(0, '#FFEB3B');
            sunGradient.addColorStop(0.6, '#FFD700');
            sunGradient.addColorStop(1, '#FFA500');
            ctx.fillStyle = sunGradient;
            ctx.beginPath();
            ctx.arc(sunX, sunY, sunR, 0, Math.PI * 2);
            ctx.fill();

            // Sun rays
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const rayGradient = ctx.createLinearGradient(
                    sunX + Math.cos(angle) * sunR * 1.15,
                    sunY + Math.sin(angle) * sunR * 1.15,
                    sunX + Math.cos(angle) * sunR * 1.6,
                    sunY + Math.sin(angle) * sunR * 1.6
                );
                rayGradient.addColorStop(0, '#FFD700');
                rayGradient.addColorStop(1, 'rgba(255, 215, 0, 0.3)');
                ctx.strokeStyle = rayGradient;
                ctx.lineWidth = 4 * scale;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(sunX + Math.cos(angle) * sunR * 1.15, sunY + Math.sin(angle) * sunR * 1.15);
                ctx.lineTo(sunX + Math.cos(angle) * sunR * 1.6, sunY + Math.sin(angle) * sunR * 1.6);
                ctx.stroke();
            }

            // Clouds (slow parallax)
            const cloudOffset = parallaxOffset * 0.5;
            drawCloud(((100 - cloudOffset) % (canvas.width + 200) + canvas.width + 200) % (canvas.width + 200) - 100, 60 * scaleY, 0.8);
            drawCloud(((400 - cloudOffset) % (canvas.width + 200) + canvas.width + 200) % (canvas.width + 200) - 100, 40 * scaleY, 1);
            drawCloud(((700 - cloudOffset) % (canvas.width + 200) + canvas.width + 200) % (canvas.width + 200) - 100, 70 * scaleY, 0.6);

            // Rolling hills (with parallax)
            ctx.fillStyle = scene.hillColor;
            ctx.beginPath();
            ctx.moveTo(0, horizonY);
            const hillCount = 4;
            for (let i = 0; i <= hillCount; i++) {
                const hx = (i / hillCount) * canvas.width;
                const offset = ((parallaxOffset * 0.3) + i * 200) % 400;
                const hillHeight = 50 + Math.sin(offset * 0.02) * 30;
                ctx.quadraticCurveTo(
                    hx + canvas.width / (hillCount * 2),
                    horizonY - hillHeight * scaleY,
                    hx + canvas.width / hillCount,
                    horizonY
                );
            }
            ctx.lineTo(canvas.width, groundY);
            ctx.lineTo(0, groundY);
            ctx.closePath();
            ctx.fill();

            // Ground
            ctx.fillStyle = scene.groundColor;
            ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);

            // Ground texture
            ctx.strokeStyle = scene.groundAccent;
            ctx.lineWidth = 1;
            if (scene.name === 'countryside' || scene.name === 'suburbs') {
                // Grass blades
                for (let i = 0; i < canvas.width; i += 15 * scale) {
                    ctx.beginPath();
                    ctx.moveTo(i, groundY);
                    ctx.lineTo(i + 3 * scale, groundY - 5 * scaleY);
                    ctx.moveTo(i + 7 * scale, groundY);
                    ctx.lineTo(i + 10 * scale, groundY - 7 * scaleY);
                    ctx.stroke();
                }
            } else {
                // Street markings for downtown
                ctx.strokeStyle = '#FFFF00';
                ctx.lineWidth = 3 * scale;
                ctx.setLineDash([30 * scale, 20 * scale]);
                ctx.beginPath();
                ctx.moveTo(0, groundY + 30 * scaleY);
                ctx.lineTo(canvas.width, groundY + 30 * scaleY);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }

        // Draw the duck (cartoon style) - scaled version
        function drawDuck(x, y, facing, walkFrame, hasGun) {
            ctx.save();
            ctx.translate(x + duck.width/2, y + duck.height/2);
            ctx.scale(facing * scale, scale);
            ctx.translate(-25, -30); // center on reference duck size

            // Shadow beneath duck
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.ellipse(25, 78, 28, 8, 0, 0, Math.PI * 2);
            ctx.fill();

            // Tail feathers with gradient
            const tailGradient = ctx.createRadialGradient(-5, 35, 0, -5, 35, 15);
            tailGradient.addColorStop(0, '#F5C842');
            tailGradient.addColorStop(1, '#D4A820');
            ctx.fillStyle = tailGradient;
            ctx.beginPath();
            ctx.moveTo(-5, 35);
            ctx.quadraticCurveTo(-15, 25, -12, 38);
            ctx.quadraticCurveTo(-18, 30, -14, 42);
            ctx.quadraticCurveTo(-12, 45, -5, 42);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Body (yellow oval) with gradient
            const bodyGradient = ctx.createRadialGradient(20, 30, 0, 25, 38, 30);
            bodyGradient.addColorStop(0, '#FFF176');
            bodyGradient.addColorStop(0.6, '#FFD83D');
            bodyGradient.addColorStop(1, '#F5C842');
            ctx.fillStyle = bodyGradient;
            ctx.beginPath();
            ctx.ellipse(25, 38, 24, 26, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Body highlight
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.ellipse(20, 32, 12, 14, -0.3, 0, Math.PI * 2);
            ctx.fill();

            // Wing with gradient
            const wingGradient = ctx.createRadialGradient(15, 35, 0, 20, 40, 18);
            wingGradient.addColorStop(0, '#F5D86D');
            wingGradient.addColorStop(1, '#D4A820');
            ctx.fillStyle = wingGradient;
            ctx.beginPath();
            ctx.ellipse(20, 40, 14, 18, -0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#B8942E';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Wing feather details
            ctx.strokeStyle = 'rgba(180, 148, 46, 0.4)';
            ctx.lineWidth = 0.5;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.arc(20, 35 + i * 5, 10, 0.3, 1.5);
                ctx.stroke();
            }

            // Neck with shading
            const neckGradient = ctx.createLinearGradient(30, 20, 40, 35);
            neckGradient.addColorStop(0, '#FFF176');
            neckGradient.addColorStop(1, '#FFD83D');
            ctx.fillStyle = neckGradient;
            ctx.beginPath();
            ctx.moveTo(35, 20);
            ctx.quadraticCurveTo(42, 25, 40, 35);
            ctx.quadraticCurveTo(35, 30, 30, 22);
            ctx.closePath();
            ctx.fill();

            // Head with gradient
            const headGradient = ctx.createRadialGradient(28, 6, 0, 32, 10, 14);
            headGradient.addColorStop(0, '#FFF9C4');
            headGradient.addColorStop(0.5, '#FFD83D');
            headGradient.addColorStop(1, '#F5C842');
            ctx.fillStyle = headGradient;
            ctx.beginPath();
            ctx.arc(32, 10, 14, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Beak (flat duck bill) with gradient
            const beakGradient = ctx.createLinearGradient(44, 8, 60, 12);
            beakGradient.addColorStop(0, '#FFA726');
            beakGradient.addColorStop(0.5, '#FF8C00');
            beakGradient.addColorStop(1, '#E67E00');
            ctx.fillStyle = beakGradient;
            ctx.beginPath();
            ctx.moveTo(44, 8);
            ctx.quadraticCurveTo(58, 6, 60, 12);
            ctx.quadraticCurveTo(58, 18, 44, 16);
            ctx.quadraticCurveTo(46, 12, 44, 8);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            
            // Beak highlight
            ctx.fillStyle = 'rgba(255, 200, 100, 0.4)';
            ctx.beginPath();
            ctx.moveTo(46, 9);
            ctx.quadraticCurveTo(52, 8, 54, 10);
            ctx.quadraticCurveTo(52, 11, 46, 11);
            ctx.closePath();
            ctx.fill();
            
            // Nostril
            ctx.fillStyle = '#CC6600';
            ctx.beginPath();
            ctx.ellipse(50, 11, 2, 1.5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Eye white with subtle gradient
            const eyeWhiteGradient = ctx.createRadialGradient(37, 6, 0, 38, 7, 6);
            eyeWhiteGradient.addColorStop(0, '#FFFFFF');
            eyeWhiteGradient.addColorStop(1, '#F0F0F0');
            ctx.fillStyle = eyeWhiteGradient;
            ctx.beginPath();
            ctx.ellipse(38, 7, 5, 6, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Pupil with depth
            const pupilGradient = ctx.createRadialGradient(38.5, 6.5, 0, 39, 7, 2.5);
            pupilGradient.addColorStop(0, '#333');
            pupilGradient.addColorStop(1, '#000');
            ctx.fillStyle = pupilGradient;
            ctx.beginPath();
            ctx.arc(39, 7, 2.5, 0, Math.PI * 2);
            ctx.fill();
            
            // Eye highlights (two for more life)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.beginPath();
            ctx.arc(40, 5.5, 1.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.beginPath();
            ctx.arc(38, 8, 0.6, 0, Math.PI * 2);
            ctx.fill();

            // Legs with gradient
            const legGradient = ctx.createLinearGradient(0, 60, 0, 72);
            legGradient.addColorStop(0, '#FFA726');
            legGradient.addColorStop(1, '#FF8C00');
            ctx.strokeStyle = legGradient;
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            const legOffset = Math.sin(walkFrame * 0.3) * 5;

            ctx.beginPath();
            ctx.moveTo(18, 60);
            ctx.lineTo(15 - legOffset, 72);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(32, 60);
            ctx.lineTo(35 + legOffset, 72);
            ctx.stroke();

            // Webbed feet with gradient
            const footGradient = ctx.createLinearGradient(0, 72, 0, 74);
            footGradient.addColorStop(0, '#FF8C00');
            footGradient.addColorStop(1, '#E67E00');
            ctx.fillStyle = footGradient;
            ctx.lineWidth = 1.5;
            
            // Left foot
            ctx.beginPath();
            ctx.moveTo(15 - legOffset, 72);
            ctx.lineTo(5 - legOffset, 74);
            ctx.lineTo(10 - legOffset, 72);
            ctx.lineTo(15 - legOffset, 74);
            ctx.lineTo(20 - legOffset, 72);
            ctx.lineTo(25 - legOffset, 74);
            ctx.lineTo(20 - legOffset, 72);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#B8660A';
            ctx.stroke();
            
            // Right foot
            ctx.beginPath();
            ctx.moveTo(35 + legOffset, 72);
            ctx.lineTo(25 + legOffset, 74);
            ctx.lineTo(30 + legOffset, 72);
            ctx.lineTo(35 + legOffset, 74);
            ctx.lineTo(40 + legOffset, 72);
            ctx.lineTo(45 + legOffset, 74);
            ctx.lineTo(40 + legOffset, 72);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Lemon seed gun (if has gun)
            if (hasGun) {
                // Gun body (held under wing)
                ctx.fillStyle = '#8B4513';
                ctx.beginPath();
                ctx.roundRect(35, 32, 30, 10, 3);
                ctx.fill();
                ctx.strokeStyle = '#5D2E0C';
                ctx.lineWidth = 1.5;
                ctx.stroke();

                // Gun barrel
                ctx.fillStyle = '#666';
                ctx.beginPath();
                ctx.roundRect(60, 34, 18, 6, 2);
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.stroke();

                // Gun handle
                ctx.fillStyle = '#8B4513';
                ctx.beginPath();
                ctx.roundRect(40, 40, 8, 12, 2);
                ctx.fill();
                ctx.strokeStyle = '#5D2E0C';
                ctx.stroke();

                // Lemon decoration on gun
                ctx.fillStyle = '#FFE135';
                ctx.beginPath();
                ctx.ellipse(45, 37, 5, 3, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#DAA520';
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            ctx.restore();
        }

        // Draw a grape bunch (scaled)
        function drawGrape(x, y, size) {
            const s = size * scale;

            // Stem with gradient
            const stemGradient = ctx.createLinearGradient(x, y - s - 10 * scale, x, y - s);
            stemGradient.addColorStop(0, '#2E7D32');
            stemGradient.addColorStop(1, '#228B22');
            ctx.strokeStyle = stemGradient;
            ctx.lineWidth = 2.5 * scale;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(x, y - s);
            ctx.lineTo(x, y - s - 10 * scale);
            ctx.stroke();

            // Leaf with gradient
            const leafGradient = ctx.createRadialGradient(x + 5 * scale, y - s - 8 * scale, 0, x + 5 * scale, y - s - 8 * scale, 8 * scale);
            leafGradient.addColorStop(0, '#4CAF50');
            leafGradient.addColorStop(1, '#2E7D32');
            ctx.fillStyle = leafGradient;
            ctx.beginPath();
            ctx.ellipse(x + 5 * scale, y - s - 8 * scale, 8 * scale, 4 * scale, 0.3, 0, Math.PI * 2);
            ctx.fill();
            // Leaf vein
            ctx.strokeStyle = '#1B5E20';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x + 2 * scale, y - s - 8 * scale);
            ctx.lineTo(x + 8 * scale, y - s - 8 * scale);
            ctx.stroke();

            const positions = [
                {dx: 0, dy: 0},
                {dx: -s*0.7, dy: -s*0.4},
                {dx: s*0.7, dy: -s*0.4},
                {dx: -s*0.35, dy: s*0.5},
                {dx: s*0.35, dy: s*0.5},
                {dx: 0, dy: s*0.9}
            ];

            positions.forEach(pos => {
                const gx = x + pos.dx;
                const gy = y + pos.dy;
                
                // Grape shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
                ctx.beginPath();
                ctx.arc(gx + s * 0.1, gy + s * 0.15, s * 0.48, 0, Math.PI * 2);
                ctx.fill();

                // Grape body with radial gradient
                const grapeGradient = ctx.createRadialGradient(
                    gx - s * 0.15, gy - s * 0.15, 0,
                    gx, gy, s * 0.5
                );
                grapeGradient.addColorStop(0, '#BA68C8');
                grapeGradient.addColorStop(0.5, '#8B008B');
                grapeGradient.addColorStop(1, '#6A0080');
                ctx.fillStyle = grapeGradient;
                ctx.beginPath();
                ctx.arc(gx, gy, s * 0.5, 0, Math.PI * 2);
                ctx.fill();
                
                // Grape outline
                ctx.strokeStyle = '#4B0082';
                ctx.lineWidth = 1.5 * scale;
                ctx.stroke();

                // Main highlight (glossy effect)
                const highlightGradient = ctx.createRadialGradient(
                    gx - s * 0.2, gy - s * 0.2, 0,
                    gx - s * 0.2, gy - s * 0.2, s * 0.25
                );
                highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.7)');
                highlightGradient.addColorStop(0.5, 'rgba(204, 153, 255, 0.4)');
                highlightGradient.addColorStop(1, 'rgba(204, 153, 255, 0)');
                ctx.fillStyle = highlightGradient;
                ctx.beginPath();
                ctx.arc(gx - s * 0.2, gy - s * 0.2, s * 0.25, 0, Math.PI * 2);
                ctx.fill();

                // Secondary highlight
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.beginPath();
                ctx.arc(gx - s * 0.25, gy - s * 0.25, s * 0.12, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // Draw a lemon seed projectile
        function drawSeed(x, y) {
            ctx.fillStyle = '#F5DEB3';
            ctx.beginPath();
            ctx.ellipse(x, y, 6 * scale, 3 * scale, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#D2B48C';
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        // ========================================
        // PARTICLE SYSTEM
        // ========================================
        
        function createParticles(x, y, count, type) {
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 * i) / count + Math.random() * 0.5;
                const speed = 2 + Math.random() * 3;
                
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 1,
                    life: 1.0,
                    decay: 0.02 + Math.random() * 0.01,
                    size: 3 + Math.random() * 3,
                    type: type,
                    color: type === 'grape' ? '#8B008B' : '#FFD700'
                });
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.15; // gravity
                p.life -= p.decay;
                
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        function drawParticles() {
            for (const p of particles) {
                const screenX = p.x - camera.x;
                if (screenX < -20 || screenX > canvas.width + 20) continue;
                
                ctx.save();
                ctx.globalAlpha = p.life;
                
                if (p.type === 'grape') {
                    // Sparkle particles for grapes
                    const gradient = ctx.createRadialGradient(screenX, p.y, 0, screenX, p.y, p.size * scale);
                    gradient.addColorStop(0, '#DA70D6');
                    gradient.addColorStop(0.5, '#8B008B');
                    gradient.addColorStop(1, 'rgba(139, 0, 139, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(screenX, p.y, p.size * scale, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Star shape
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * 2 * Math.PI) / 5 - Math.PI / 2;
                        const x = screenX + Math.cos(angle) * p.size * scale * 0.5;
                        const y = p.y + Math.sin(angle) * p.size * scale * 0.5;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                } else {
                    // Simple colored particles
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(screenX, p.y, p.size * scale, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }

        // ========================================
        // ENEMY DRAWING
        // ========================================
        
        // Draw enemy based on type
        function drawEnemy(enemy, screenX) {
            const x = screenX;
            const y = enemy.y;
            const s = scale;

            if (enemy.type === 'walker') {
                // Angry lemon - walks back and forth
                ctx.fillStyle = '#FFE135';
                ctx.beginPath();
                ctx.ellipse(x, y, 20 * s, 16 * s, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#DAA520';
                ctx.lineWidth = 2;
                ctx.stroke();
                // Angry eyes
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(x - 6 * s, y - 4 * s, 3 * s, 0, Math.PI * 2);
                ctx.arc(x + 6 * s, y - 4 * s, 3 * s, 0, Math.PI * 2);
                ctx.fill();
                // Angry eyebrows
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x - 10 * s, y - 10 * s);
                ctx.lineTo(x - 3 * s, y - 7 * s);
                ctx.moveTo(x + 10 * s, y - 10 * s);
                ctx.lineTo(x + 3 * s, y - 7 * s);
                ctx.stroke();
                // Frown
                ctx.beginPath();
                ctx.arc(x, y + 8 * s, 6 * s, 1.2 * Math.PI, 1.8 * Math.PI);
                ctx.stroke();
                // Legs
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(x - 8 * s, y + 14 * s);
                ctx.lineTo(x - 10 * s, y + 25 * s);
                ctx.moveTo(x + 8 * s, y + 14 * s);
                ctx.lineTo(x + 10 * s, y + 25 * s);
                ctx.stroke();
            } else if (enemy.type === 'flyer') {
                // Flying lime with wings
                ctx.fillStyle = '#32CD32';
                ctx.beginPath();
                ctx.arc(x, y, 15 * s, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#228B22';
                ctx.lineWidth = 2;
                ctx.stroke();
                // Wings
                ctx.fillStyle = 'rgba(200, 200, 255, 0.7)';
                const wingFlap = Math.sin(Date.now() * 0.02) * 5;
                ctx.beginPath();
                ctx.ellipse(x - 20 * s, y - wingFlap * s, 12 * s, 6 * s, -0.3, 0, Math.PI * 2);
                ctx.ellipse(x + 20 * s, y - wingFlap * s, 12 * s, 6 * s, 0.3, 0, Math.PI * 2);
                ctx.fill();
                // Eyes
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(x - 5 * s, y - 3 * s, 2 * s, 0, Math.PI * 2);
                ctx.arc(x + 5 * s, y - 3 * s, 2 * s, 0, Math.PI * 2);
                ctx.fill();
            } else if (enemy.type === 'jumper') {
                // Jumping orange
                ctx.fillStyle = '#FFA500';
                ctx.beginPath();
                ctx.arc(x, y, 18 * s, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#FF8C00';
                ctx.lineWidth = 2;
                ctx.stroke();
                // Leaf on top
                ctx.fillStyle = '#228B22';
                ctx.beginPath();
                ctx.ellipse(x, y - 20 * s, 5 * s, 8 * s, 0, 0, Math.PI * 2);
                ctx.fill();
                // Eyes
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(x - 6 * s, y - 4 * s, 3 * s, 0, Math.PI * 2);
                ctx.arc(x + 6 * s, y - 4 * s, 3 * s, 0, Math.PI * 2);
                ctx.fill();
                // Determined mouth
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x - 6 * s, y + 6 * s);
                ctx.lineTo(x + 6 * s, y + 6 * s);
                ctx.stroke();
            }

            // Health indicator
            if (enemy.health > 1) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(x - 15 * s, y - 30 * s, 30 * s, 5 * s);
                ctx.fillStyle = '#FF0000';
                ctx.fillRect(x - 15 * s, y - 30 * s, (enemy.health / 2) * 30 * s, 5 * s);
            }
        }

        // Draw helicopter
        function drawHelicopter(x, y, isPickup) {
            const s = scale;

            if (isPickup) {
                // Glowing pickup effect
                ctx.fillStyle = 'rgba(100, 200, 255, 0.3)';
                ctx.beginPath();
                ctx.arc(x, y, 40 * s + Math.sin(Date.now() * 0.005) * 5 * s, 0, Math.PI * 2);
                ctx.fill();
            }

            // Body
            ctx.fillStyle = '#4169E1';
            ctx.beginPath();
            ctx.ellipse(x, y, 30 * s, 15 * s, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Cockpit
            ctx.fillStyle = '#87CEEB';
            ctx.beginPath();
            ctx.ellipse(x + 15 * s, y, 12 * s, 10 * s, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Tail
            ctx.fillStyle = '#4169E1';
            ctx.beginPath();
            ctx.moveTo(x - 25 * s, y - 5 * s);
            ctx.lineTo(x - 50 * s, y - 8 * s);
            ctx.lineTo(x - 50 * s, y + 8 * s);
            ctx.lineTo(x - 25 * s, y + 5 * s);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Tail rotor
            ctx.fillStyle = '#333';
            ctx.fillRect(x - 52 * s, y - 15 * s, 4 * s, 30 * s);

            // Main rotor
            const rotorAngle = Date.now() * 0.03;
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 3 * s;
            ctx.beginPath();
            ctx.moveTo(x + Math.cos(rotorAngle) * 40 * s, y - 18 * s);
            ctx.lineTo(x - Math.cos(rotorAngle) * 40 * s, y - 18 * s);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x + Math.sin(rotorAngle) * 40 * s, y - 18 * s);
            ctx.lineTo(x - Math.sin(rotorAngle) * 40 * s, y - 18 * s);
            ctx.stroke();

            // Rotor hub
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.arc(x, y - 18 * s, 5 * s, 0, Math.PI * 2);
            ctx.fill();

            // Skids
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 3 * s;
            ctx.beginPath();
            ctx.moveTo(x - 20 * s, y + 15 * s);
            ctx.lineTo(x - 20 * s, y + 22 * s);
            ctx.lineTo(x + 20 * s, y + 22 * s);
            ctx.lineTo(x + 20 * s, y + 15 * s);
            ctx.stroke();
        }

        // Draw platforms (already in screen coords)
        function drawPlatform(p) {
            // Platform shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.fillRect(p.x + 3 * scale, p.y + 3 * scaleY, p.width, p.height);

            // Wood section with gradient
            const woodGradient = ctx.createLinearGradient(p.x, p.y + 10 * scaleY, p.x, p.y + p.height);
            woodGradient.addColorStop(0, '#A0643C');
            woodGradient.addColorStop(0.5, '#8B4513');
            woodGradient.addColorStop(1, '#6F3710');
            ctx.fillStyle = woodGradient;
            ctx.fillRect(p.x, p.y + 10 * scaleY, p.width, p.height - 10 * scaleY);

            // Wood grain texture
            ctx.strokeStyle = 'rgba(101, 67, 33, 0.3)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 3; i++) {
                const yPos = p.y + 15 * scaleY + i * 8 * scaleY;
                ctx.beginPath();
                ctx.moveTo(p.x, yPos);
                ctx.lineTo(p.x + p.width, yPos);
                ctx.stroke();
            }

            // Grass section with gradient
            const grassGradient = ctx.createLinearGradient(p.x, p.y, p.x, p.y + 15 * scaleY);
            grassGradient.addColorStop(0, '#4CAF50');
            grassGradient.addColorStop(0.5, '#32CD32');
            grassGradient.addColorStop(1, '#2E7D32');
            ctx.fillStyle = grassGradient;
            ctx.fillRect(p.x, p.y, p.width, 15 * scaleY);

            // Grass blades with varied colors
            const grassColors = ['#228B22', '#2E7D32', '#1B5E20'];
            for (let i = p.x; i < p.x + p.width; i += 8 * scale) {
                ctx.strokeStyle = grassColors[Math.floor(Math.random() * grassColors.length)];
                ctx.lineWidth = 1.5;
                const grassHeight = 4 + Math.random() * 3;
                ctx.beginPath();
                ctx.moveTo(i + 2 * scale, p.y);
                ctx.lineTo(i + 3 * scale + Math.random() * 2 * scale, p.y - grassHeight * scaleY);
                ctx.stroke();
            }

            // Platform edge highlights
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(p.x, p.y + 1 * scaleY);
            ctx.lineTo(p.x + p.width, p.y + 1 * scaleY);
            ctx.stroke();

            // Platform outline
            ctx.strokeStyle = '#5D2E0C';
            ctx.lineWidth = 2;
            ctx.strokeRect(p.x, p.y, p.width, p.height);

            // Darker bottom edge
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(p.x, p.y + p.height);
            ctx.lineTo(p.x + p.width, p.y + p.height);
            ctx.stroke();
        }

        // Generate scrolling level with scenery
        function generateLevel(levelNum) {
            platforms = [];
            grapes = [];
            sceneryElements = [];
            grapesCollected = 0;

            // World gets longer each level
            worldWidth = (1500 + levelNum * 500) * scaleX;

            const groundY = canvas.height * 0.86;
            const platHeight = 20 * scaleY;

            // Ground platform spans entire world
            platforms.push({x: 0, y: groundY, width: worldWidth, height: canvas.height - groundY, isGround: true});

            // Level-specific scene themes
            const levelThemes = {
                1: 'countryside',  // Trees, shrubs, flowers, fences
                2: 'countryside',  // Same pastoral theme
                3: 'suburbs',      // Houses, mailboxes, small trees
                4: 'suburbs',      // More suburban
                5: 'downtown'      // Buildings, lamp posts, city
            };

            const theme = levelThemes[levelNum] || 'mainstreet';

            // Generate scenery based on theme
            generateScenery(theme, levelNum);

            // Generate platforms distributed across the world
            const platformCount = 3 + levelNum * 2;
            const spacing = worldWidth / (platformCount + 1);

            for (let i = 0; i < platformCount; i++) {
                const px = spacing * (i + 0.5 + Math.random() * 0.5);
                const py = 0.45 + Math.random() * 0.25;  // Between 45% and 70% height
                const pw = 0.08 + Math.random() * 0.05;  // Platform width

                platforms.push({
                    x: px,
                    y: py * canvas.height,
                    width: pw * canvas.width,
                    height: platHeight
                });
            }

            // Generate grapes distributed across the world
            const grapeCount = 4 + levelNum * 2;
            const grapeSpacing = worldWidth / (grapeCount + 1);

            for (let i = 0; i < grapeCount; i++) {
                const gx = grapeSpacing * (i + 0.3 + Math.random() * 0.4);

                // Some grapes on ground, some elevated (near platforms)
                let gy;
                if (Math.random() > 0.4) {
                    // Find a nearby platform
                    const nearPlatform = platforms.find(p => !p.isGround &&
                        Math.abs(p.x + p.width/2 - gx) < 150 * scaleX);
                    if (nearPlatform) {
                        gy = nearPlatform.y - 30 * scaleY;
                    } else {
                        gy = groundY - 40 * scaleY;
                    }
                } else {
                    gy = groundY - 40 * scaleY;
                }

                grapes.push({
                    x: gx,
                    y: gy,
                    size: 12,
                    collected: false
                });
            }

            totalGrapes = grapes.length;

            // Reset duck and camera
            duck.x = 50 * scaleX;
            duck.y = groundY - duck.height - 10;
            duck.vx = 0;
            duck.vy = 0;
            camera.x = 0;

            // Update gravity based on screen height
            gravity = 0.6 * scaleY;

            // Clear projectiles
            seeds = [];

            // Generate enemies (starting from level 5)
            enemies = [];
            if (levelNum >= 5) {
                const enemyCount = 2 + (levelNum - 5) * 2;  // More enemies at higher levels
                const enemySpacing = worldWidth / (enemyCount + 2);

                for (let i = 0; i < enemyCount; i++) {
                    const ex = enemySpacing * (i + 1.5 + Math.random() * 0.5);
                    const enemyTypes = ['walker', 'flyer', 'jumper'];
                    const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];

                    enemies.push({
                        x: ex,
                        y: type === 'flyer' ? groundY - 150 * scaleY : groundY - 40 * scaleY,
                        width: 40 * scale,
                        height: 40 * scale,
                        vx: (Math.random() > 0.5 ? 1 : -1) * 2 * scaleX,
                        vy: 0,
                        type: type,
                        health: type === 'flyer' ? 1 : 2,
                        jumpTimer: 0,
                        startX: ex,
                        patrolRange: 200 * scaleX
                    });
                }
            }

            // Set up helicopter (available from level 6)
            helicopter.available = levelNum >= 6;
            helicopter.active = false;
            helicopter.fuel = helicopter.maxFuel;
            if (helicopter.available) {
                // Place helicopter pickup near start
                helicopter.pickupX = 200 * scaleX;
                helicopter.pickupY = groundY - 80 * scaleY;
                helicopter.pickedUp = false;
            }
        }

        // Generate scenery elements based on theme (consistent throughout level)
        function generateScenery(theme, levelNum) {
            sceneryElements = [];
            const colors = ['#FF69B4', '#FF6347', '#FFD700', '#9370DB', '#00CED1'];
            const streetNames = ['MAIN ST', 'OAK AVE', 'PARK RD', 'ELM ST', 'GRAPE LN'];

            // Much denser scenery - smaller spacing between elements
            for (let x = 50; x < worldWidth; x += 30 + Math.random() * 50) {
                const rand = Math.random();

                // Use same theme throughout entire level
                if (theme === 'countryside') {
                    // Countryside elements - lots of nature
                    if (rand < 0.3) {
                        sceneryElements.push({type: 'tree', x: x, size: 0.6 + Math.random() * 0.6});
                    } else if (rand < 0.5) {
                        sceneryElements.push({type: 'shrub', x: x, size: 0.5 + Math.random() * 0.6});
                    } else if (rand < 0.7) {
                        sceneryElements.push({type: 'flower', x: x, color: colors[Math.floor(Math.random() * colors.length)]});
                    } else if (rand < 0.8) {
                        sceneryElements.push({type: 'fence', x: x, width: 60 + Math.random() * 60});
                        x += 40;
                    } else {
                        // Add extra flowers in gaps
                        sceneryElements.push({type: 'flower', x: x, color: colors[Math.floor(Math.random() * colors.length)]});
                    }
                } else if (theme === 'suburbs') {
                    // Suburban elements - houses, yards, trees
                    if (rand < 0.15) {
                        sceneryElements.push({type: 'house', x: x, style: Math.floor(Math.random() * 4)});
                        x += 80;
                    } else if (rand < 0.35) {
                        sceneryElements.push({type: 'tree', x: x, size: 0.5 + Math.random() * 0.4});
                    } else if (rand < 0.5) {
                        sceneryElements.push({type: 'shrub', x: x, size: 0.4 + Math.random() * 0.4});
                    } else if (rand < 0.6) {
                        sceneryElements.push({type: 'mailbox', x: x});
                    } else if (rand < 0.75) {
                        sceneryElements.push({type: 'flower', x: x, color: colors[Math.floor(Math.random() * colors.length)]});
                    } else if (rand < 0.85) {
                        sceneryElements.push({type: 'lamppost', x: x});
                    } else {
                        sceneryElements.push({type: 'fence', x: x, width: 40 + Math.random() * 40});
                        x += 30;
                    }
                } else if (theme === 'downtown') {
                    // Downtown elements - dense urban
                    if (rand < 0.25) {
                        sceneryElements.push({
                            type: 'building',
                            x: x,
                            width: 60 + Math.random() * 80,
                            height: 120 + Math.random() * 180,
                            style: Math.floor(Math.random() * 5)
                        });
                        x += 80;
                    } else if (rand < 0.45) {
                        sceneryElements.push({type: 'lamppost', x: x});
                    } else if (rand < 0.55) {
                        sceneryElements.push({type: 'hydrant', x: x});
                    } else if (rand < 0.7) {
                        sceneryElements.push({type: 'bench', x: x});
                    } else if (rand < 0.8) {
                        sceneryElements.push({type: 'sign', x: x, text: streetNames[Math.floor(Math.random() * streetNames.length)]});
                    } else {
                        sceneryElements.push({type: 'tree', x: x, size: 0.4 + Math.random() * 0.3});
                    }
                } else {
                    // Default - mix of everything
                    if (rand < 0.2) {
                        sceneryElements.push({type: 'tree', x: x, size: 0.6 + Math.random() * 0.4});
                    } else if (rand < 0.4) {
                        sceneryElements.push({type: 'shrub', x: x, size: 0.5 + Math.random() * 0.5});
                    } else if (rand < 0.5) {
                        sceneryElements.push({type: 'lamppost', x: x});
                    } else if (rand < 0.6) {
                        sceneryElements.push({type: 'bench', x: x});
                    } else {
                        sceneryElements.push({type: 'flower', x: x, color: colors[Math.floor(Math.random() * colors.length)]});
                    }
                }
            }

            // Always add lemonade stand near the start for level 1
            if (levelNum === 1) {
                // Mark position for lemonade stand
                sceneryElements.push({type: 'lemonadeStand', x: 400 * scaleX});
            }

            // Add finish banner at the end of every level
            sceneryElements.push({type: 'finishBanner', x: worldWidth - 80 * scaleX});

            // Sort by x position for proper rendering order
            sceneryElements.sort((a, b) => a.x - b.x);
        }

        function checkPlatformCollision() {
            duck.onGround = false;

            for (const p of platforms) {
                if (duck.x + duck.width > p.x &&
                    duck.x < p.x + p.width &&
                    duck.y + duck.height > p.y &&
                    duck.y + duck.height < p.y + p.height + duck.vy + 5 &&
                    duck.vy >= 0) {

                    duck.y = p.y - duck.height;
                    duck.vy = 0;
                    duck.onGround = true;
                }
            }
        }

        function checkGrapeCollection() {
            for (const grape of grapes) {
                if (!grape.collected) {
                    const dx = (duck.x + duck.width/2) - grape.x;
                    const dy = (duck.y + duck.height/2) - grape.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);

                    if (dist < 40 * scale) {
                        grape.collected = true;
                        grapesCollected++;
                        totalGrapesCollected++;
                        showMessage("Got a grape!");
                        
                        // Create particle effect
                        createParticles(grape.x, grape.y, 15, 'grape');

                        // Check if all grapes collected - prompt to reach end
                        if (grapesCollected === totalGrapes) {
                            showMessage("All grapes! Reach the end!");
                        }
                    }
                }
            }
        }

        function showMessage(msg) {
            gameMessage = msg;
            messageTimer = 90;
        }

        // Demo AI - finds nearest uncollected grape and moves toward it
        function updateDemoAI() {
            if (!demoMode) return;

            // Find nearest uncollected grape (within reasonable range for demo)
            let nearestDist = Infinity;
            targetGrape = null;
            for (const grape of grapes) {
                if (!grape.collected) {
                    const dx = grape.x - (duck.x + duck.width/2);
                    const dy = grape.y - (duck.y + duck.height/2);
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    // Prefer grapes ahead and not too far
                    if (dist < nearestDist && dx > -200 * scaleX) {
                        nearestDist = dist;
                        targetGrape = grape;
                    }
                }
            }

            if (!targetGrape) {
                // All grapes collected or none ahead, reset level for demo
                generateLevel(level);
                camera.x = 0;
                return;
            }

            // Move toward target grape
            const dx = targetGrape.x - (duck.x + duck.width/2);
            const threshold = 20 * scaleX;

            if (dx > threshold) {
                duck.vx = duck.speed * 0.8;
                duck.facing = 1;
            } else if (dx < -threshold) {
                duck.vx = -duck.speed * 0.8;
                duck.facing = -1;
            } else {
                duck.vx *= friction;
            }

            // Jump logic
            demoJumpCooldown--;
            const needsToJumpUp = targetGrape.y < duck.y - 30 * scaleY;

            // Check if there's a platform above we need to reach
            let platformAbove = false;
            for (const p of platforms) {
                if (!p.isGround && p.y < duck.y && p.y > duck.y - 150 * scaleY &&
                    duck.x + duck.width > p.x - 50 * scaleX && duck.x < p.x + p.width + 50 * scaleX) {
                    platformAbove = true;
                    break;
                }
            }

            if (duck.onGround && demoJumpCooldown <= 0 && (needsToJumpUp || platformAbove)) {
                duck.vy = duck.jumpForce;
                duck.onGround = false;
                demoJumpCooldown = 30;
            }
        }

        function update() {
            // Run demo mode even when game not started
            if (demoMode && !gameRunning) {
                updateDemoAI();
            }

            // Player input only when game is running (not demo)
            if (gameRunning && !demoMode) {
                if (keys['ArrowLeft'] || keys['KeyA'] || keys['tiltLeft'] || keys['touchLeft']) {
                    duck.vx = -duck.speed * (keys['tiltLeft'] ? duck.tiltAmount : 1);
                    duck.facing = -1;
                } else if (keys['ArrowRight'] || keys['KeyD'] || keys['tiltRight'] || keys['touchRight']) {
                    duck.vx = duck.speed * (keys['tiltRight'] ? duck.tiltAmount : 1);
                    duck.facing = 1;
                } else {
                    duck.vx *= friction;
                }

                if ((keys['Space'] || keys['ArrowUp'] || keys['KeyW'] || keys['touchJump']) && duck.onGround && !helicopter.active) {
                    duck.vy = duck.jumpForce;
                    duck.onGround = false;
                    keys['touchJump'] = false; // Reset tap jump
                }

                // Shooting (X key or F key) - available from level 5
                if ((keys['KeyX'] || keys['KeyF']) && level >= 5) {
                    const now = Date.now();
                    if (now - lastShotTime > SHOT_COOLDOWN) {
                        seeds.push({
                            x: duck.x + (duck.facing > 0 ? duck.width : 0),
                            y: duck.y + duck.height / 2,
                            vx: duck.facing * 12 * scaleX,
                            vy: 0
                        });
                        lastShotTime = now;
                    }
                }

                // Helicopter controls (E to toggle, Space to fly up when active)
                if (keys['KeyE'] && helicopter.available && !keys['helicopterToggled']) {
                    keys['helicopterToggled'] = true;
                    if (!helicopter.pickedUp) {
                        // Check if near helicopter pickup
                        const distToPickup = Math.abs(duck.x - helicopter.pickupX) + Math.abs(duck.y - helicopter.pickupY);
                        if (distToPickup < 100 * scale) {
                            helicopter.pickedUp = true;
                            helicopter.active = true;
                            showMessage("Helicopter activated! Space to fly!");
                        }
                    } else {
                        helicopter.active = !helicopter.active;
                        if (helicopter.active && helicopter.fuel > 0) {
                            showMessage("Helicopter ON");
                        } else {
                            showMessage("Helicopter OFF");
                        }
                    }
                }
                if (!keys['KeyE']) keys['helicopterToggled'] = false;

                // Helicopter flying
                if (helicopter.active && helicopter.fuel > 0) {
                    if (keys['Space'] || keys['ArrowUp'] || keys['KeyW']) {
                        duck.vy = -6 * scaleY;  // Fly up
                        helicopter.fuel -= 0.3;
                    } else {
                        duck.vy += gravity * 0.3;  // Slow fall
                    }
                    // Helicopter uses fuel slowly even when not ascending
                    helicopter.fuel -= 0.05;
                    if (helicopter.fuel <= 0) {
                        helicopter.fuel = 0;
                        helicopter.active = false;
                        showMessage("Out of fuel!");
                    }
                }
            }

            // Apply gravity (reduced if helicopter active)
            if (!helicopter.active) {
                duck.vy += gravity;
            }
            duck.x += duck.vx;
            duck.y += duck.vy;

            // Boundaries - world coordinates
            if (duck.x < 0) duck.x = 0;
            if (duck.x + duck.width > worldWidth) duck.x = worldWidth - duck.width;

            // Fall off screen
            if (duck.y > canvas.height + 50) {
                const groundY = canvas.height * 0.86;
                duck.x = 50 * scaleX;
                duck.y = groundY - duck.height - 10;
                duck.vy = 0;
                camera.x = 0;
                if (gameRunning) showMessage("Whoops! Try again!");
            }

            // Check if reached end of level
            if (gameRunning && !levelCompleting && duck.x > worldWidth - 100 * scaleX && grapesCollected === totalGrapes) {
                levelCompleting = true;
                if (level >= MAX_LEVEL) {
                    showMessage("You Win! All 15 levels complete!");
                    setTimeout(() => {
                        gameRunning = false;
                        levelCompleting = false;
                        document.getElementById('totalGrapes').textContent = totalGrapesCollected;
                        winScreen.classList.remove('hidden');
                    }, 1500);
                } else {
                    showMessage("Level Complete! Onward!");
                    setTimeout(() => {
                        level++;
                        levelCompleting = false;
                        generateLevel(level);
                    }, 1500);
                }
            }

            // Walk animation
            if (Math.abs(duck.vx) > 0.5) {
                duck.walkTimer++;
                if (duck.walkTimer > 5) {
                    duck.walkFrame++;
                    duck.walkTimer = 0;
                }
            } else {
                duck.walkFrame = 0;
            }

            checkPlatformCollision();

            // Update seeds (projectiles)
            for (let i = seeds.length - 1; i >= 0; i--) {
                const seed = seeds[i];
                seed.x += seed.vx;
                seed.y += seed.vy;
                seed.vy += gravity * 0.3;  // Slight arc

                // Remove if off screen
                if (seed.x < camera.x - 50 || seed.x > camera.x + canvas.width + 50 ||
                    seed.y > canvas.height) {
                    seeds.splice(i, 1);
                    continue;
                }

                // Check collision with enemies
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    const dx = seed.x - enemy.x;
                    const dy = seed.y - enemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 30 * scale) {
                        enemy.health--;
                        seeds.splice(i, 1);
                        if (enemy.health <= 0) {
                            enemies.splice(j, 1);
                            showMessage("Enemy defeated!");
                        }
                        break;
                    }
                }
            }

            // Update enemies
            const groundY = canvas.height * 0.86;
            for (const enemy of enemies) {
                if (enemy.type === 'walker') {
                    // Patrol back and forth
                    enemy.x += enemy.vx;
                    if (Math.abs(enemy.x - enemy.startX) > enemy.patrolRange) {
                        enemy.vx = -enemy.vx;
                    }
                    enemy.y = groundY - 25 * scale;
                } else if (enemy.type === 'flyer') {
                    // Fly in a sine wave pattern
                    enemy.x += enemy.vx;
                    enemy.y = groundY - 150 * scaleY + Math.sin(Date.now() * 0.003 + enemy.startX) * 50 * scaleY;
                    if (Math.abs(enemy.x - enemy.startX) > enemy.patrolRange) {
                        enemy.vx = -enemy.vx;
                    }
                } else if (enemy.type === 'jumper') {
                    // Jump periodically
                    enemy.x += enemy.vx * 0.5;
                    enemy.vy += gravity;
                    enemy.y += enemy.vy;
                    if (enemy.y > groundY - 20 * scale) {
                        enemy.y = groundY - 20 * scale;
                        enemy.vy = 0;
                        enemy.jumpTimer++;
                        if (enemy.jumpTimer > 60) {
                            enemy.vy = -12 * scaleY;
                            enemy.jumpTimer = 0;
                        }
                    }
                    if (Math.abs(enemy.x - enemy.startX) > enemy.patrolRange) {
                        enemy.vx = -enemy.vx;
                    }
                }

                // Check collision with duck
                if (gameRunning) {
                    const dx = (duck.x + duck.width / 2) - enemy.x;
                    const dy = (duck.y + duck.height / 2) - enemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 40 * scale) {
                        // Duck hit by enemy - reset position
                        duck.x = 50 * scaleX;
                        duck.y = groundY - duck.height - 10;
                        duck.vx = 0;
                        duck.vy = 0;
                        camera.x = 0;
                        helicopter.active = false;
                        showMessage("Ouch! Watch out for enemies!");
                    }
                }
            }

            // Only collect grapes and update UI when game is running
            if (gameRunning) {
                checkGrapeCollection();
                grapeCountEl.textContent = grapesCollected + '/' + totalGrapes;
                levelNumEl.textContent = level;
            } else if (demoMode) {
                // Demo mode grape collection (just for show, resets)
                for (const grape of grapes) {
                    if (!grape.collected) {
                        const dx = (duck.x + duck.width/2) - grape.x;
                        const dy = (duck.y + duck.height/2) - grape.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < 40 * scale) {
                            grape.collected = true;
                        }
                    }
                }
            }

            if (messageTimer > 0) messageTimer--;
            
            // Update particles
            updateParticles();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Update camera to follow duck
            updateCamera();

            const groundY = canvas.height * 0.86;

            // Draw programmatic backgrounds
            drawBackgrounds();

            // Level indicator (fixed on screen)
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.font = `bold ${50 * scale}px Comic Sans MS`;
            ctx.textAlign = 'center';
            ctx.fillText('LEVEL ' + level, canvas.width/2, canvas.height * 0.55);

            // Draw scenery elements (with camera offset)
            for (const elem of sceneryElements) {
                const screenX = elem.x - camera.x;
                if (screenX > -200 * scale && screenX < canvas.width + 200 * scale) {
                    if (elem.type === 'lemonadeStand') {
                        drawLemonadeStandAt(screenX);
                    } else {
                        drawSceneryElement(elem, screenX);
                    }
                }
            }

            // Platforms (skip ground, apply camera offset)
            for (const p of platforms) {
                if (!p.isGround) {
                    const screenX = p.x - camera.x;
                    // Only draw if on screen
                    if (screenX + p.width > 0 && screenX < canvas.width) {
                        drawPlatform({...p, x: screenX});
                    }
                }
            }

            // Grapes (with camera offset)
            for (const grape of grapes) {
                if (!grape.collected) {
                    const screenX = grape.x - camera.x;
                    if (screenX > -30 && screenX < canvas.width + 30) {
                        drawGrape(screenX, grape.y, grape.size);
                    }
                }
            }

            // Helicopter pickup (if available and not picked up)
            if (helicopter.available && !helicopter.pickedUp) {
                const heliScreenX = helicopter.pickupX - camera.x;
                if (heliScreenX > -100 && heliScreenX < canvas.width + 100) {
                    drawHelicopter(heliScreenX, helicopter.pickupY, true);
                }
            }

            // Enemies (with camera offset)
            for (const enemy of enemies) {
                const screenX = enemy.x - camera.x;
                if (screenX > -50 && screenX < canvas.width + 50) {
                    drawEnemy(enemy, screenX);
                }
            }

            // Seeds/projectiles (with camera offset)
            for (const seed of seeds) {
                const screenX = seed.x - camera.x;
                if (screenX > -20 && screenX < canvas.width + 20) {
                    drawSeed(screenX, seed.y);
                }
            }

            // Duck (with camera offset) - hide when in helicopter
            const duckScreenX = duck.x - camera.x;
            if (helicopter.active) {
                // Draw helicopter with duck inside (duck hidden)
                drawHelicopter(duckScreenX + duck.width / 2, duck.y + duck.height / 2, false);
            } else {
                // Draw duck normally (with gun if level 5+)
                drawDuck(duckScreenX, duck.y, duck.facing, duck.walkFrame, level >= 5);
            }

            // Speech bubble when near lemonade stand
            const standElem = sceneryElements.find(e => e.type === 'lemonadeStand');
            if (standElem) {
                const standScreenX = standElem.x - camera.x;
                if (Math.abs(duckScreenX - standScreenX) < 100 * scale && duck.y > canvas.height * 0.7) {
                    const bubbleX = standScreenX + 60 * scale;
                    const bubbleY = canvas.height * 0.5;
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.ellipse(bubbleX, bubbleY, 70 * scale, 30 * scale, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.moveTo(bubbleX - 20 * scale, bubbleY + 25 * scale);
                    ctx.lineTo(bubbleX - 10 * scale, bubbleY + 40 * scale);
                    ctx.lineTo(bubbleX, bubbleY + 25 * scale);
                    ctx.fill();
                    ctx.stroke();

                    ctx.fillStyle = '#000';
                    ctx.font = `bold ${12 * scale}px Comic Sans MS`;
                    ctx.textAlign = 'center';
                    ctx.fillText("We only sell", bubbleX, bubbleY - 5 * scale);
                    ctx.fillText("LEMONADE!", bubbleX, bubbleY + 10 * scale);
                }
            }

            // Progress indicator (how far through level)
            const progress = Math.min(duck.x / (worldWidth - canvas.width * 0.5), 1);
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(10 * scale, canvas.height - 20 * scaleY, 100 * scale, 8 * scaleY);
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(10 * scale, canvas.height - 20 * scaleY, progress * 100 * scale, 8 * scaleY);

            // Gun indicator (level 5+)
            if (level >= 5 && gameRunning) {
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(canvas.width - 120 * scale, canvas.height - 50 * scaleY, 110 * scale, 40 * scaleY);
                ctx.fillStyle = '#F5DEB3';
                ctx.font = `bold ${12 * scale}px Comic Sans MS`;
                ctx.textAlign = 'left';
                ctx.fillText('SEED GUN', canvas.width - 115 * scale, canvas.height - 32 * scaleY);
                ctx.fillStyle = '#FFF';
                ctx.font = `${10 * scale}px Comic Sans MS`;
                ctx.fillText('Press X/F to shoot', canvas.width - 115 * scale, canvas.height - 18 * scaleY);
            }

            // Helicopter fuel indicator (level 6+)
            if (helicopter.available && helicopter.pickedUp && gameRunning) {
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(canvas.width - 120 * scale, canvas.height - 95 * scaleY, 110 * scale, 40 * scaleY);
                ctx.fillStyle = '#4169E1';
                ctx.font = `bold ${12 * scale}px Comic Sans MS`;
                ctx.textAlign = 'left';
                ctx.fillText('HELICOPTER', canvas.width - 115 * scale, canvas.height - 77 * scaleY);
                // Fuel bar
                ctx.fillStyle = '#333';
                ctx.fillRect(canvas.width - 115 * scale, canvas.height - 68 * scaleY, 100 * scale, 8 * scaleY);
                ctx.fillStyle = helicopter.fuel > 20 ? '#32CD32' : '#FF4500';
                ctx.fillRect(canvas.width - 115 * scale, canvas.height - 68 * scaleY, (helicopter.fuel / helicopter.maxFuel) * 100 * scale, 8 * scaleY);
                ctx.fillStyle = '#FFF';
                ctx.font = `${9 * scale}px Comic Sans MS`;
                ctx.fillText('E: toggle, Space: fly', canvas.width - 115 * scale, canvas.height - 55 * scaleY);
            }

            // End zone indicator (arrow pointing right at edge of screen when near end)
            if (duck.x > worldWidth - canvas.width * 1.5) {
                const arrowX = canvas.width - 30 * scale;
                const arrowY = canvas.height * 0.5;
                const pulse = Math.sin(Date.now() * 0.005) * 5 * scale;

                // Arrow glow
                ctx.fillStyle = grapesCollected === totalGrapes ? 'rgba(50, 205, 50, 0.5)' : 'rgba(255, 215, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(arrowX + pulse, arrowY, 25 * scale, 0, Math.PI * 2);
                ctx.fill();

                // Arrow
                ctx.fillStyle = grapesCollected === totalGrapes ? '#32CD32' : '#FFD700';
                ctx.beginPath();
                ctx.moveTo(arrowX - 15 * scale + pulse, arrowY - 12 * scale);
                ctx.lineTo(arrowX + 15 * scale + pulse, arrowY);
                ctx.lineTo(arrowX - 15 * scale + pulse, arrowY + 12 * scale);
                ctx.closePath();
                ctx.fill();

                // "FINISH" text when all grapes collected
                if (grapesCollected === totalGrapes) {
                    ctx.fillStyle = '#32CD32';
                    ctx.font = `bold ${14 * scale}px Comic Sans MS`;
                    ctx.textAlign = 'center';
                    ctx.fillText('FINISH!', arrowX, arrowY + 35 * scale);
                }
            }

            // Particles (draw after characters but before UI)
            drawParticles();

            // Message
            if (messageTimer > 0) {
                const msgW = 400 * scaleX;
                const msgH = 50 * scaleY;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect((canvas.width - msgW) / 2, 20 * scaleY, msgW, msgH);
                ctx.fillStyle = '#FFD700';
                ctx.font = `bold ${24 * scale}px Comic Sans MS`;
                ctx.textAlign = 'center';
                ctx.fillText(gameMessage, canvas.width / 2, 20 * scaleY + msgH * 0.65);
            }
        }

        // Draw lemonade stand at specific screen X position
        function drawLemonadeStandAt(screenX) {
            const groundY = canvas.height * 0.86;
            const s = scale;
            const x = screenX - 60 * s;
            const y = groundY - 150 * s;

            // Stand base
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(x, y + 70*s, 120*s, 80*s);
            ctx.strokeStyle = '#5D2E0C';
            ctx.lineWidth = 3;
            ctx.strokeRect(x, y + 70*s, 120*s, 80*s);

            // Counter top
            ctx.fillStyle = '#A0522D';
            ctx.fillRect(x - 5*s, y + 65*s, 130*s, 10*s);

            // Sign board
            ctx.fillStyle = '#FFFACD';
            ctx.fillRect(x + 10*s, y - 35*s, 100*s, 45*s);
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 3;
            ctx.strokeRect(x + 10*s, y - 35*s, 100*s, 45*s);

            // Sign text
            ctx.fillStyle = '#228B22';
            ctx.font = `bold ${11*s}px Comic Sans MS`;
            ctx.textAlign = 'center';
            ctx.fillText('FRESH', x + 60*s, y - 18*s);
            ctx.fillStyle = '#FFD700';
            ctx.font = `bold ${14*s}px Comic Sans MS`;
            ctx.fillText('LEMONADE', x + 60*s, y - 2*s);
            ctx.fillStyle = '#228B22';
            ctx.font = `bold ${9*s}px Comic Sans MS`;
            ctx.fillText('25', x + 60*s, y + 8*s);

            // Roof poles
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 5*s;
            ctx.beginPath();
            ctx.moveTo(x + 20*s, y - 35*s);
            ctx.lineTo(x + 20*s, y + 70*s);
            ctx.moveTo(x + 100*s, y - 35*s);
            ctx.lineTo(x + 100*s, y + 70*s);
            ctx.stroke();

            // Pile of lemons on the left side of counter
            function drawLemon(lx, ly, size, rotation) {
                ctx.save();
                ctx.translate(lx, ly);
                ctx.rotate(rotation);
                ctx.fillStyle = '#FFE135';
                ctx.beginPath();
                ctx.ellipse(0, 0, size * 8 * s, size * 5 * s, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#DAA520';
                ctx.lineWidth = 1;
                ctx.stroke();
                // Lemon tip
                ctx.fillStyle = '#CCBF00';
                ctx.beginPath();
                ctx.ellipse(size * 7 * s, 0, size * 2 * s, size * 2 * s, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
            // Bottom layer
            drawLemon(x + 25*s, y + 58*s, 1, 0.2);
            drawLemon(x + 40*s, y + 60*s, 0.9, -0.3);
            drawLemon(x + 18*s, y + 62*s, 0.85, 0.5);
            // Top layer
            drawLemon(x + 30*s, y + 52*s, 0.8, -0.1);
            drawLemon(x + 22*s, y + 54*s, 0.75, 0.4);

            // Glass pitcher with lemonade
            // Pitcher body (glass)
            ctx.fillStyle = 'rgba(255, 255, 200, 0.9)';
            ctx.beginPath();
            ctx.moveTo(x + 70*s, y + 35*s);
            ctx.lineTo(x + 65*s, y + 65*s);
            ctx.lineTo(x + 95*s, y + 65*s);
            ctx.lineTo(x + 90*s, y + 35*s);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#87CEEB';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Lemonade liquid inside
            ctx.fillStyle = '#FFEB3B';
            ctx.beginPath();
            ctx.moveTo(x + 67*s, y + 42*s);
            ctx.lineTo(x + 65*s, y + 65*s);
            ctx.lineTo(x + 95*s, y + 65*s);
            ctx.lineTo(x + 92*s, y + 42*s);
            ctx.closePath();
            ctx.fill();

            // Lemon slices floating in pitcher
            ctx.fillStyle = '#FFE135';
            ctx.beginPath();
            ctx.arc(x + 75*s, y + 50*s, 4*s, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#DAA520';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(x + 85*s, y + 55*s, 3*s, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Ice cubes
            ctx.fillStyle = 'rgba(200, 230, 255, 0.7)';
            ctx.fillRect(x + 70*s, y + 45*s, 5*s, 5*s);
            ctx.fillRect(x + 82*s, y + 48*s, 4*s, 4*s);
            ctx.fillRect(x + 76*s, y + 56*s, 5*s, 5*s);

            // Pitcher handle
            ctx.strokeStyle = '#87CEEB';
            ctx.lineWidth = 3*s;
            ctx.beginPath();
            ctx.arc(x + 98*s, y + 50*s, 8*s, -Math.PI/2, Math.PI/2);
            ctx.stroke();

            // Pitcher spout
            ctx.fillStyle = 'rgba(255, 255, 200, 0.9)';
            ctx.beginPath();
            ctx.moveTo(x + 70*s, y + 35*s);
            ctx.lineTo(x + 62*s, y + 30*s);
            ctx.lineTo(x + 68*s, y + 35*s);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Lemonade man (behind counter)
            ctx.fillStyle = '#FDBF6F';
            ctx.beginPath();
            ctx.arc(x + 60*s, y + 30*s, 15*s, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Hair
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.arc(x + 60*s, y + 22*s, 14*s, Math.PI, 2 * Math.PI);
            ctx.fill();

            // Eyes
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(x + 55*s, y + 28*s, 4*s, 0, Math.PI * 2);
            ctx.arc(x + 65*s, y + 28*s, 4*s, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(x + 55*s, y + 28*s, 2*s, 0, Math.PI * 2);
            ctx.arc(x + 65*s, y + 28*s, 2*s, 0, Math.PI * 2);
            ctx.fill();

            // Frown (annoyed expression)
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x + 60*s, y + 42*s, 5*s, 1.2 * Math.PI, 1.8 * Math.PI);
            ctx.stroke();

            // Apron
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(x + 48*s, y + 45*s, 24*s, 25*s);
            ctx.strokeStyle = '#DDD';
            ctx.lineWidth = 1;
            ctx.strokeRect(x + 48*s, y + 45*s, 24*s, 25*s);
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        function startGame() {
            startScreen.classList.add('hidden');
            winScreen.classList.add('hidden');

            level = 1;
            totalGrapesCollected = 0;
            demoMode = false;
            generateLevel(1);
            gameRunning = true;

            // Request motion permission on game start (works on iOS)
            requestMotionPermission();

            // Auto-play music when game starts
            if (!musicPlaying) {
                bgMusic.play().catch(e => console.log('Audio play failed:', e));
                musicBtn.textContent = 'Music: ON';
                musicPlaying = true;
            }
        }

        // Event listeners
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        // Mobile touch controls - tap to jump, touch sides to move (fallback if no tilt)
        let activeTouchId = null;

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.changedTouches[0];
            const rect = canvas.getBoundingClientRect();
            const x = (touch.clientX - rect.left) / rect.width;

            // Tap to jump
            keys['touchJump'] = true;

            // Fallback touch controls: left 30% = left, right 30% = right, middle = just jump
            if (!tiltEnabled) {
                activeTouchId = touch.identifier;
                if (x < 0.3) {
                    keys['touchLeft'] = true;
                    keys['touchRight'] = false;
                } else if (x > 0.7) {
                    keys['touchRight'] = true;
                    keys['touchLeft'] = false;
                }
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!tiltEnabled && activeTouchId !== null) {
                for (const touch of e.changedTouches) {
                    if (touch.identifier === activeTouchId) {
                        const rect = canvas.getBoundingClientRect();
                        const x = (touch.clientX - rect.left) / rect.width;
                        if (x < 0.3) {
                            keys['touchLeft'] = true;
                            keys['touchRight'] = false;
                        } else if (x > 0.7) {
                            keys['touchRight'] = true;
                            keys['touchLeft'] = false;
                        } else {
                            keys['touchLeft'] = false;
                            keys['touchRight'] = false;
                        }
                    }
                }
            }
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            for (const touch of e.changedTouches) {
                if (touch.identifier === activeTouchId) {
                    activeTouchId = null;
                    keys['touchLeft'] = false;
                    keys['touchRight'] = false;
                }
            }
        });

        // Tilt controls for movement (uses device orientation)
        let tiltEnabled = false;
        let tiltSensitivity = 0.5; // 0.1 to 1.0, controlled by slider
        const tiltDeadzone = 5; // degrees of deadzone before movement starts
        const tiltMaxAngle = 20; // degrees at which full speed is reached

        // Sensitivity slider handler
        const sensitivitySlider = document.getElementById('tiltSensitivity');
        const sensitivityValue = document.getElementById('sensitivityValue');
        sensitivitySlider.addEventListener('input', (e) => {
            tiltSensitivity = e.target.value / 100;
            sensitivityValue.textContent = e.target.value;
        });

        function handleOrientation(e) {
            if (!gameRunning || demoMode) return;

            // gamma is left-right tilt (-90 to 90)
            let tilt = e.gamma || 0;

            // Apply sensitivity - lower sensitivity = need more tilt
            const adjustedDeadzone = tiltDeadzone + (1 - tiltSensitivity) * 10;
            const adjustedMaxAngle = tiltMaxAngle + (1 - tiltSensitivity) * 20;

            // Handle device held in portrait mode
            if (tilt > adjustedDeadzone) {
                // Tilted right
                keys['tiltRight'] = true;
                keys['tiltLeft'] = false;
                duck.tiltAmount = Math.min((tilt - adjustedDeadzone) / (adjustedMaxAngle - adjustedDeadzone), 1);
                duck.tiltAmount = Math.max(duck.tiltAmount, 0.3 + tiltSensitivity * 0.4); // min speed scales with sensitivity
            } else if (tilt < -adjustedDeadzone) {
                // Tilted left
                keys['tiltLeft'] = true;
                keys['tiltRight'] = false;
                duck.tiltAmount = Math.min((-tilt - adjustedDeadzone) / (adjustedMaxAngle - adjustedDeadzone), 1);
                duck.tiltAmount = Math.max(duck.tiltAmount, 0.3 + tiltSensitivity * 0.4); // min speed scales with sensitivity
            } else {
                keys['tiltLeft'] = false;
                keys['tiltRight'] = false;
                duck.tiltAmount = 0;
            }
        }

        // Request permission for device orientation (required on iOS 13+)
        function requestMotionPermission() {
            if (typeof DeviceOrientationEvent !== 'undefined' &&
                typeof DeviceOrientationEvent.requestPermission === 'function') {
                // iOS 13+ requires permission request
                DeviceOrientationEvent.requestPermission()
                    .then(response => {
                        if (response === 'granted') {
                            window.addEventListener('deviceorientation', handleOrientation);
                            tiltEnabled = true;
                        }
                    })
                    .catch(err => console.log('Motion permission error:', err));
            } else if (window.DeviceOrientationEvent) {
                // Non-iOS or older iOS - just add listener
                window.addEventListener('deviceorientation', handleOrientation);
                tiltEnabled = true;
            }
        }

        // Request permission on first user interaction (required for iOS)
        function initMotionOnce() {
            requestMotionPermission();
            document.removeEventListener('touchstart', initMotionOnce);
            document.removeEventListener('click', initMotionOnce);
        }
        document.addEventListener('touchstart', initMotionOnce, { once: true });
        document.addEventListener('click', initMotionOnce, { once: true });

        // Handle window resize
        window.addEventListener('resize', () => {
            resizeCanvas();
            generateLevel(level); // Regenerate level for new dimensions
        });

        // Handle iOS Safari viewport changes (address bar show/hide)
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', () => {
                resizeCanvas();
            });
        }

        // Initialize
        resizeCanvas();
        generateLevel(1);
        gameLoop();
    </script>
</body>
</html>
