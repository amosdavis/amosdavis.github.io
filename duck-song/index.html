<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Duck Song - Got Any Grapes?</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            min-height: 100dvh; /* dynamic viewport height for mobile */
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: 'Comic Sans MS', cursive, sans-serif;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }
        #gameContainer {
            position: relative; /* allow absolute children to center over the canvas */
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            width: 100%;
            height: 100%;
            max-width: 900px;
        }
        /* Make canvas scale down on small screens while keeping the game's logical resolution (800x500) */
        #gameCanvas {
            border: 4px solid #8B4513;
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.3);
            width: min(95vw, 800px);
            height: auto;
            display: block;
            touch-action: none; /* prevent browser gestures interfering with game touches */
        }
        /* Full screen mode for mobile - detect touch devices */
        @media (pointer: coarse), (max-width: 600px) {
            html, body {
                height: 100%;
                height: -webkit-fill-available;
            }
            #gameContainer {
                padding: 0;
                max-width: none;
                height: 100%;
                height: -webkit-fill-available;
            }
            #gameCanvas {
                width: 100%;
                height: 100%;
                border: none;
                border-radius: 0;
            }
            #title, #instructions {
                display: none;
            }
            #ui {
                position: absolute;
                top: env(safe-area-inset-top, 10px);
                left: 50%;
                transform: translateX(-50%);
                z-index: 100;
                margin: 0;
                padding: 8px 16px;
                font-size: 14px;
                background: rgba(0,0,0,0.6);
            }
        }
        #ui {
            display: flex;
            gap: 30px;
            margin-bottom: 10px;
            color: white;
            font-size: 18px;
            background: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border-radius: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        #instructions {
            color: #aaa;
            margin-top: 10px;
            text-align: center;
            font-size: 14px;
        }
        #title {
            color: #FFD700;
            font-size: 28px;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            text-align: center;
        }
        #musicBtn {
            background: #FFD700;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-family: inherit;
            font-size: 14px;
            transition: transform 0.1s;
        }
        #musicBtn:hover {
            transform: scale(1.05);
        }
        #startScreen, #winScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.85);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            width: min(90%, 600px);
            box-shadow: 0 8px 30px rgba(0,0,0,0.5);
        }
        .screen-btn {
            background: #FFD700;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-family: inherit;
            font-size: 20px;
            margin-top: 20px;
            transition: transform 0.1s, background 0.2s;
        }
        .screen-btn:hover {
            transform: scale(1.1);
            background: #FFA500;
        }
        .hidden { display: none !important; }

        /* Responsive tweaks */
        @media (max-width: 600px) {
            #title { font-size: 20px; }
            #ui { font-size: 14px; gap: 10px; padding: 8px 12px; }
            #instructions { font-size: 12px; }
            .screen-btn { font-size: 18px; padding: 12px 22px; }
            #startScreen, #winScreen { padding: 20px; }
            #musicBtn { font-size: 12px; padding: 6px 12px; }
            #startScreen h1, #winScreen h1 { font-size: 28px !important; }
            #startScreen p, #winScreen p { font-size: 14px !important; }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="title">The Duck Song Game - Got Any Grapes?</div>
        <div id="ui">
            <span>Grapes: <span id="grapeCount">0</span></span>
            <span>Level: <span id="levelNum">1</span></span>
            <button id="musicBtn" onclick="toggleMusic()">Music: OFF</button>
        </div>
        <canvas id="gameCanvas" width="800" height="500"></canvas>
        <div id="instructions">
            Arrow Keys / WASD to move | SPACE to jump | Collect grapes & reach the end!
        </div>

        <div id="startScreen">
            <h1 style="color: #FFD700; font-size: 36px;">The Duck Song Game</h1>
            <p style="margin: 20px 0; font-size: 18px;">Help the duck collect grapes!<br>Collect all grapes & reach the end of each level.</p>
            <p style="color: #aaa;">Desktop: Arrow Keys / WASD + Space<br>Mobile: Tilt to move, Tap to jump!<br><span style="font-size: 12px;">(Or tap left/right sides to move)</span></p>
            <div style="margin: 15px 0; width: 100%;">
                <label style="color: #aaa; font-size: 14px;">Tilt Sensitivity: <span id="sensitivityValue">50</span>%</label>
                <input type="range" id="tiltSensitivity" min="10" max="100" value="50"
                    style="width: 80%; margin-top: 8px; cursor: pointer;">
            </div>
            <button class="screen-btn" onclick="startGame()">Start Game!</button>
        </div>

        <div id="winScreen" class="hidden">
            <h1 style="color: #FFD700; font-size: 36px;">You Win!</h1>
            <p style="margin: 20px 0; font-size: 18px;">The duck finally got all the grapes!</p>
            <p style="color: #8B008B;">Total grapes collected: <span id="totalGrapes">0</span></p>
            <button class="screen-btn" onclick="startGame()">Play Again</button>
        </div>
    </div>

    <audio id="bgMusic" loop>
        <source src="duck_song.mp3" type="audio/mpeg">
    </audio>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const grapeCountEl = document.getElementById('grapeCount');
        const levelNumEl = document.getElementById('levelNum');
        const musicBtn = document.getElementById('musicBtn');
        const bgMusic = document.getElementById('bgMusic');
        const startScreen = document.getElementById('startScreen');
        const winScreen = document.getElementById('winScreen');

        // Reference dimensions (original design)
        const REF_WIDTH = 800;
        const REF_HEIGHT = 500;

        // Scale factors - updated on resize
        let scaleX = 1;
        let scaleY = 1;
        let scale = 1; // uniform scale for sprites

        // Resize canvas to fill screen
        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            canvas.width = container.clientWidth || window.innerWidth;
            canvas.height = container.clientHeight || window.innerHeight;

            scaleX = canvas.width / REF_WIDTH;
            scaleY = canvas.height / REF_HEIGHT;
            scale = Math.min(scaleX, scaleY); // uniform scale for sprites

            // Update duck size based on scale
            duck.width = 50 * scale;
            duck.height = 60 * scale;
            duck.speed = 5 * scaleX;
            duck.jumpForce = -14 * scaleY;
        }

        // Helper to convert reference coords to screen coords
        function sx(x) { return x * scaleX; }
        function sy(y) { return y * scaleY; }

        // Game state
        let gameRunning = false;
        let demoMode = true;
        let keys = {};
        let grapes = [];
        let platforms = [];
        let level = 1;
        let grapesCollected = 0;
        let totalGrapesCollected = 0;
        let totalGrapes = 0;
        let gameMessage = '';
        let messageTimer = 0;
        let musicPlaying = false;
        let levelCompleting = false;  // Prevent multiple level completions

        // Demo AI state
        let targetGrape = null;
        let demoJumpCooldown = 0;

        const MAX_LEVEL = 5;

        // ========================================
        // WORLD & CAMERA SYSTEM
        // ========================================
        let worldWidth = 2000;  // World extends beyond viewport
        const camera = { x: 0, y: 0 };
        let sceneryElements = [];  // Background objects

        // SVG Background system - 20 scenes loaded from files
        const backgroundImages = [];
        const TOTAL_BG_SCENES = 20;
        let backgroundsLoaded = false;

        // Load all background SVGs
        function loadBackgrounds() {
            let loaded = 0;
            for (let i = 1; i <= TOTAL_BG_SCENES; i++) {
                const img = new Image();
                const num = i.toString().padStart(2, '0');
                img.src = `backgrounds/scene${num}.svg`;
                img.onload = () => {
                    loaded++;
                    if (loaded === TOTAL_BG_SCENES) {
                        backgroundsLoaded = true;
                    }
                };
                backgroundImages.push(img);
            }
        }

        // Get single background for current level
        function getBackgroundForLevel(levelNum) {
            // Each level uses one background
            const bgIndex = (levelNum - 1) % TOTAL_BG_SCENES;
            return backgroundImages[bgIndex];
        }

        // Convert world coords to screen coords
        function worldToScreen(wx, wy) {
            return { x: wx - camera.x, y: wy };
        }

        // Update camera to follow duck
        function updateCamera() {
            // Keep duck at 30% from left edge
            const targetX = duck.x - canvas.width * 0.3;
            camera.x = Math.max(0, Math.min(targetX, worldWidth - canvas.width));
        }

        // Duck player (positions will be in screen coords)
        const duck = {
            x: 100,
            y: 300,
            width: 50,
            height: 60,
            vx: 0,
            vy: 0,
            speed: 5,
            jumpForce: -14,
            onGround: false,
            facing: 1,
            walkFrame: 0,
            walkTimer: 0,
            tiltAmount: 0
        };

        // Physics (scaled on resize)
        let gravity = 0.6;
        const friction = 0.85;

        // Remove unused lemonadeStand object - position is now calculated dynamically

        function toggleMusic() {
            if (musicPlaying) {
                bgMusic.pause();
                musicBtn.textContent = 'Music: OFF';
                musicPlaying = false;
            } else {
                bgMusic.play().catch(e => console.log('Audio play failed:', e));
                musicBtn.textContent = 'Music: ON';
                musicPlaying = true;
            }
        }

        // ========================================
        // NEW GRAPHICS FUNCTIONS
        // ========================================

        // Draw a tree (countryside)
        function drawTree(x, y, size) {
            const s = size * scale;
            // Trunk
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(x - 7 * s, y, 14 * s, 50 * s);
            // Foliage
            ctx.fillStyle = '#228B22';
            ctx.beginPath();
            ctx.arc(x, y - 10 * s, 35 * s, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x - 20 * s, y + 5 * s, 25 * s, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 20 * s, y + 5 * s, 25 * s, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw a shrub (small bush)
        function drawShrub(x, y, size) {
            const s = (size || 1) * scale;
            ctx.fillStyle = '#2E8B57';
            ctx.beginPath();
            ctx.arc(x, y - 8 * s, 15 * s, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x - 10 * s, y - 3 * s, 10 * s, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 10 * s, y - 3 * s, 10 * s, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw a flower
        function drawFlower(x, y, color) {
            const s = scale;
            // Stem
            ctx.strokeStyle = '#228B22';
            ctx.lineWidth = 2 * s;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x, y - 15 * s);
            ctx.stroke();
            // Petals
            ctx.fillStyle = color || '#FF69B4';
            for (let i = 0; i < 5; i++) {
                const angle = (i / 5) * Math.PI * 2;
                ctx.beginPath();
                ctx.arc(x + Math.cos(angle) * 5 * s, y - 15 * s + Math.sin(angle) * 5 * s, 4 * s, 0, Math.PI * 2);
                ctx.fill();
            }
            // Center
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(x, y - 15 * s, 3 * s, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw a picket fence section
        function drawFence(x, y, width) {
            const s = scale;
            const postSpacing = 20 * s;
            ctx.fillStyle = '#F5F5DC';
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 1;
            // Horizontal rails
            ctx.fillRect(x, y - 25 * s, width, 5 * s);
            ctx.fillRect(x, y - 10 * s, width, 5 * s);
            // Pickets
            for (let px = x; px < x + width; px += postSpacing) {
                ctx.fillStyle = '#F5F5DC';
                ctx.beginPath();
                ctx.moveTo(px, y);
                ctx.lineTo(px, y - 35 * s);
                ctx.lineTo(px + 5 * s, y - 40 * s);
                ctx.lineTo(px + 10 * s, y - 35 * s);
                ctx.lineTo(px + 10 * s, y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
        }

        // Draw a suburban house
        function drawHouse(x, y, style) {
            const s = scale;
            const width = (80 + style * 20) * s;
            const height = (60 + style * 10) * s;
            const colors = ['#D2691E', '#8B0000', '#4169E1', '#2F4F4F'];
            const roofColors = ['#8B4513', '#A52A2A', '#696969', '#2F2F2F'];

            // House body
            ctx.fillStyle = colors[style % colors.length];
            ctx.fillRect(x - width/2, y - height, width, height);
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.strokeRect(x - width/2, y - height, width, height);

            // Roof
            ctx.fillStyle = roofColors[style % roofColors.length];
            ctx.beginPath();
            ctx.moveTo(x - width/2 - 10 * s, y - height);
            ctx.lineTo(x, y - height - 40 * s);
            ctx.lineTo(x + width/2 + 10 * s, y - height);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Door
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(x - 10 * s, y - 40 * s, 20 * s, 40 * s);
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(x + 5 * s, y - 20 * s, 2 * s, 0, Math.PI * 2);
            ctx.fill();

            // Windows
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(x - width/2 + 10 * s, y - height + 15 * s, 15 * s, 15 * s);
            ctx.fillRect(x + width/2 - 25 * s, y - height + 15 * s, 15 * s, 15 * s);
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 1;
            ctx.strokeRect(x - width/2 + 10 * s, y - height + 15 * s, 15 * s, 15 * s);
            ctx.strokeRect(x + width/2 - 25 * s, y - height + 15 * s, 15 * s, 15 * s);
        }

        // Draw a mailbox
        function drawMailbox(x, y) {
            const s = scale;
            // Post
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(x - 3 * s, y - 35 * s, 6 * s, 35 * s);
            // Box
            ctx.fillStyle = '#4169E1';
            ctx.fillRect(x - 12 * s, y - 50 * s, 24 * s, 18 * s);
            // Flag
            ctx.fillStyle = '#FF0000';
            ctx.fillRect(x + 12 * s, y - 50 * s, 3 * s, 12 * s);
        }

        // Draw a city building
        function drawBuilding(x, y, width, height, style) {
            const s = scale;
            const w = width * s;
            const h = height * s;
            const colors = ['#708090', '#5F5F5F', '#4A4A4A', '#363636', '#2F4F4F'];

            // Building body
            ctx.fillStyle = colors[style % colors.length];
            ctx.fillRect(x - w/2, y - h, w, h);
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.strokeRect(x - w/2, y - h, w, h);

            // Windows grid
            const windowSize = 12 * s;
            const windowSpacing = 20 * s;
            const margin = 15 * s;

            for (let wy = y - h + margin; wy < y - margin; wy += windowSpacing) {
                for (let wx = x - w/2 + margin; wx < x + w/2 - margin; wx += windowSpacing) {
                    // Randomly lit windows
                    const lit = Math.sin(wx * 0.1 + wy * 0.1 + style) > 0;
                    ctx.fillStyle = lit ? '#FFFF99' : '#333';
                    ctx.fillRect(wx, wy, windowSize, windowSize);
                }
            }

            // Rooftop details
            if (style % 2 === 0) {
                // Water tower
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(x - 8 * s, y - h - 20 * s, 16 * s, 20 * s);
            } else {
                // Antenna
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x, y - h);
                ctx.lineTo(x, y - h - 30 * s);
                ctx.stroke();
            }
        }

        // Draw a lamp post
        function drawLampPost(x, y) {
            const s = scale;
            // Pole
            ctx.fillStyle = '#2F2F2F';
            ctx.fillRect(x - 3 * s, y - 80 * s, 6 * s, 80 * s);
            // Lamp head
            ctx.fillStyle = '#333';
            ctx.fillRect(x - 12 * s, y - 85 * s, 24 * s, 8 * s);
            // Light glow
            const gradient = ctx.createRadialGradient(x, y - 80 * s, 0, x, y - 80 * s, 40 * s);
            gradient.addColorStop(0, 'rgba(255, 255, 200, 0.3)');
            gradient.addColorStop(1, 'rgba(255, 255, 200, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y - 70 * s, 40 * s, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw a fire hydrant
        function drawFireHydrant(x, y) {
            const s = scale;
            ctx.fillStyle = '#FF0000';
            // Body
            ctx.fillRect(x - 6 * s, y - 25 * s, 12 * s, 25 * s);
            // Top
            ctx.beginPath();
            ctx.arc(x, y - 25 * s, 8 * s, Math.PI, 0);
            ctx.fill();
            // Side nozzles
            ctx.fillRect(x - 12 * s, y - 18 * s, 6 * s, 6 * s);
            ctx.fillRect(x + 6 * s, y - 18 * s, 6 * s, 6 * s);
        }

        // Draw a bench
        function drawBench(x, y) {
            const s = scale;
            ctx.fillStyle = '#8B4513';
            // Seat
            ctx.fillRect(x - 25 * s, y - 18 * s, 50 * s, 6 * s);
            // Back
            ctx.fillRect(x - 25 * s, y - 35 * s, 50 * s, 5 * s);
            // Legs
            ctx.fillRect(x - 22 * s, y - 18 * s, 4 * s, 18 * s);
            ctx.fillRect(x + 18 * s, y - 18 * s, 4 * s, 18 * s);
            // Back supports
            ctx.fillRect(x - 22 * s, y - 35 * s, 4 * s, 17 * s);
            ctx.fillRect(x + 18 * s, y - 35 * s, 4 * s, 17 * s);
        }

        // Draw a street sign
        function drawStreetSign(x, y, text) {
            const s = scale;
            // Pole
            ctx.fillStyle = '#4A4A4A';
            ctx.fillRect(x - 2 * s, y - 60 * s, 4 * s, 60 * s);
            // Sign
            ctx.fillStyle = '#228B22';
            ctx.fillRect(x - 30 * s, y - 70 * s, 60 * s, 15 * s);
            ctx.fillStyle = '#FFF';
            ctx.font = `bold ${8 * s}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText(text || 'MAIN ST', x, y - 60 * s);
        }

        // Draw finish banner/flag at end of level
        function drawFinishBanner(x, y) {
            const s = scale;
            // Pole
            ctx.fillStyle = '#4A4A4A';
            ctx.fillRect(x - 3 * s, y - 120 * s, 6 * s, 120 * s);
            // Banner
            ctx.fillStyle = '#FF0000';
            ctx.beginPath();
            ctx.moveTo(x + 3 * s, y - 120 * s);
            ctx.lineTo(x + 60 * s, y - 100 * s);
            ctx.lineTo(x + 3 * s, y - 80 * s);
            ctx.closePath();
            ctx.fill();
            // Checkered pattern
            ctx.fillStyle = '#FFF';
            ctx.fillRect(x + 10 * s, y - 115 * s, 15 * s, 10 * s);
            ctx.fillRect(x + 25 * s, y - 105 * s, 15 * s, 10 * s);
            ctx.fillRect(x + 10 * s, y - 95 * s, 15 * s, 10 * s);
            // Text
            ctx.fillStyle = '#FFD700';
            ctx.font = `bold ${10 * s}px Comic Sans MS`;
            ctx.textAlign = 'center';
            ctx.fillText('FINISH', x + 25 * s, y - 70 * s);
        }

        // Draw scenery element based on type
        function drawSceneryElement(elem, screenX) {
            const groundY = canvas.height * 0.86;
            switch (elem.type) {
                case 'tree':
                    drawTree(screenX, groundY, elem.size || 1);
                    break;
                case 'shrub':
                    drawShrub(screenX, groundY, elem.size || 1);
                    break;
                case 'flower':
                    drawFlower(screenX, groundY, elem.color);
                    break;
                case 'fence':
                    drawFence(screenX, groundY, elem.width * scale);
                    break;
                case 'house':
                    drawHouse(screenX, groundY, elem.style);
                    break;
                case 'mailbox':
                    drawMailbox(screenX, groundY);
                    break;
                case 'building':
                    drawBuilding(screenX, groundY, elem.width, elem.height, elem.style);
                    break;
                case 'lamppost':
                    drawLampPost(screenX, groundY);
                    break;
                case 'hydrant':
                    drawFireHydrant(screenX, groundY);
                    break;
                case 'bench':
                    drawBench(screenX, groundY);
                    break;
                case 'sign':
                    drawStreetSign(screenX, groundY, elem.text);
                    break;
                case 'finishBanner':
                    drawFinishBanner(screenX, groundY);
                    break;
            }
        }

        // ========================================
        // SVG BACKGROUND DRAWING
        // ========================================

        // Draw SVG backgrounds with parallax scrolling
        function drawSVGBackgrounds() {
            const groundY = canvas.height * 0.86;  // Match game's ground level

            if (!backgroundsLoaded || backgroundImages.length === 0) {
                // Fallback: simple gradient while loading
                const gradient = ctx.createLinearGradient(0, 0, 0, groundY);
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(0.7, '#B0E0E6');
                gradient.addColorStop(1, '#90EE90');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, groundY);

                // Ground
                ctx.fillStyle = '#32CD32';
                ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);
                return;
            }

            // Get single background for current level
            const levelBg = getBackgroundForLevel(level);
            if (!levelBg) return;

            // Draw background filling the screen (static, no movement)
            ctx.drawImage(levelBg, 0, 0, canvas.width, groundY);

            // Draw ground below the SVG backgrounds (the playable ground area)
            ctx.fillStyle = '#32CD32';  // Bright green grass
            ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);

            // Ground texture - grass blades
            ctx.strokeStyle = '#228B22';
            ctx.lineWidth = 1;
            for (let i = 0; i < canvas.width; i += 15 * scale) {
                ctx.beginPath();
                ctx.moveTo(i, groundY);
                ctx.lineTo(i + 3 * scale, groundY - 5 * scaleY);
                ctx.moveTo(i + 7 * scale, groundY);
                ctx.lineTo(i + 10 * scale, groundY - 7 * scaleY);
                ctx.stroke();
            }
        }

        // Draw the duck (cartoon style) - scaled version
        function drawDuck(x, y, facing, walkFrame) {
            ctx.save();
            ctx.translate(x + duck.width/2, y + duck.height/2);
            ctx.scale(facing * scale, scale);
            ctx.translate(-25, -30); // center on reference duck size

            // Body (yellow oval)
            ctx.fillStyle = '#FFB830';
            ctx.beginPath();
            ctx.ellipse(25, 35, 22, 28, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Head
            ctx.fillStyle = '#FFB830';
            ctx.beginPath();
            ctx.arc(30, 12, 16, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Beak (orange)
            ctx.fillStyle = '#FF6B35';
            ctx.beginPath();
            ctx.moveTo(44, 10);
            ctx.lineTo(60, 14);
            ctx.lineTo(44, 18);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Eye (white with black pupil)
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.ellipse(36, 8, 6, 7, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Pupil
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(38, 8, 3, 0, Math.PI * 2);
            ctx.fill();

            // Legs
            ctx.strokeStyle = '#FF6B35';
            ctx.lineWidth = 3;
            const legOffset = Math.sin(walkFrame * 0.3) * 5;

            ctx.beginPath();
            ctx.moveTo(18, 58);
            ctx.lineTo(15 - legOffset, 70);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(32, 58);
            ctx.lineTo(35 + legOffset, 70);
            ctx.stroke();

            // Feet
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(10 - legOffset, 70);
            ctx.lineTo(20 - legOffset, 70);
            ctx.moveTo(30 + legOffset, 70);
            ctx.lineTo(40 + legOffset, 70);
            ctx.stroke();

            ctx.restore();
        }

        // Draw a grape bunch (scaled)
        function drawGrape(x, y, size) {
            const s = size * scale;
            const grapeColor = '#8B008B';
            const highlight = '#9932CC';

            ctx.strokeStyle = '#228B22';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x, y - s);
            ctx.lineTo(x, y - s - 10 * scale);
            ctx.stroke();

            ctx.fillStyle = '#228B22';
            ctx.beginPath();
            ctx.ellipse(x + 5 * scale, y - s - 8 * scale, 8 * scale, 4 * scale, 0.3, 0, Math.PI * 2);
            ctx.fill();

            const positions = [
                {dx: 0, dy: 0},
                {dx: -s*0.7, dy: -s*0.4},
                {dx: s*0.7, dy: -s*0.4},
                {dx: -s*0.35, dy: s*0.5},
                {dx: s*0.35, dy: s*0.5},
                {dx: 0, dy: s*0.9}
            ];

            positions.forEach(pos => {
                ctx.fillStyle = grapeColor;
                ctx.beginPath();
                ctx.arc(x + pos.dx, y + pos.dy, s * 0.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#4B0082';
                ctx.lineWidth = 1;
                ctx.stroke();

                ctx.fillStyle = highlight;
                ctx.beginPath();
                ctx.arc(x + pos.dx - 2 * scale, y + pos.dy - 2 * scale, s * 0.15, 0, Math.PI * 2);
                ctx.fill();
            });
        }


        // Draw platforms (already in screen coords)
        function drawPlatform(p) {
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(p.x, p.y + 10 * scaleY, p.width, p.height - 10 * scaleY);

            ctx.fillStyle = '#32CD32';
            ctx.fillRect(p.x, p.y, p.width, 15 * scaleY);

            ctx.strokeStyle = '#228B22';
            ctx.lineWidth = 1;
            for (let i = p.x; i < p.x + p.width; i += 10 * scale) {
                ctx.beginPath();
                ctx.moveTo(i + 2 * scale, p.y);
                ctx.lineTo(i + 4 * scale, p.y - 5 * scaleY);
                ctx.stroke();
            }

            ctx.strokeStyle = '#5D2E0C';
            ctx.lineWidth = 2;
            ctx.strokeRect(p.x, p.y, p.width, p.height);
        }

        // Generate scrolling level with scenery
        function generateLevel(levelNum) {
            platforms = [];
            grapes = [];
            sceneryElements = [];
            grapesCollected = 0;

            // World gets longer each level
            worldWidth = (1500 + levelNum * 500) * scaleX;

            const groundY = canvas.height * 0.86;
            const platHeight = 20 * scaleY;

            // Ground platform spans entire world
            platforms.push({x: 0, y: groundY, width: worldWidth, height: canvas.height - groundY, isGround: true});

            // Level-specific scene themes
            const levelThemes = {
                1: 'countryside',  // Lemonade stand, trees, hills
                2: 'suburbs',      // Houses, mailboxes, small trees
                3: 'mixed',        // Transition - some houses, some buildings
                4: 'downtown',     // Buildings, lamp posts
                5: 'mainstreet'    // Full city with everything
            };

            const theme = levelThemes[levelNum] || 'mainstreet';

            // Generate scenery based on theme
            generateScenery(theme, levelNum);

            // Generate platforms distributed across the world
            const platformCount = 3 + levelNum * 2;
            const spacing = worldWidth / (platformCount + 1);

            for (let i = 0; i < platformCount; i++) {
                const px = spacing * (i + 0.5 + Math.random() * 0.5);
                const py = 0.45 + Math.random() * 0.25;  // Between 45% and 70% height
                const pw = 0.08 + Math.random() * 0.05;  // Platform width

                platforms.push({
                    x: px,
                    y: py * canvas.height,
                    width: pw * canvas.width,
                    height: platHeight
                });
            }

            // Generate grapes distributed across the world
            const grapeCount = 4 + levelNum * 2;
            const grapeSpacing = worldWidth / (grapeCount + 1);

            for (let i = 0; i < grapeCount; i++) {
                const gx = grapeSpacing * (i + 0.3 + Math.random() * 0.4);

                // Some grapes on ground, some elevated (near platforms)
                let gy;
                if (Math.random() > 0.4) {
                    // Find a nearby platform
                    const nearPlatform = platforms.find(p => !p.isGround &&
                        Math.abs(p.x + p.width/2 - gx) < 150 * scaleX);
                    if (nearPlatform) {
                        gy = nearPlatform.y - 30 * scaleY;
                    } else {
                        gy = groundY - 40 * scaleY;
                    }
                } else {
                    gy = groundY - 40 * scaleY;
                }

                grapes.push({
                    x: gx,
                    y: gy,
                    size: 12,
                    collected: false
                });
            }

            totalGrapes = grapes.length;

            // Reset duck and camera
            duck.x = 50 * scaleX;
            duck.y = groundY - duck.height - 10;
            duck.vx = 0;
            duck.vy = 0;
            camera.x = 0;

            // Update gravity based on screen height
            gravity = 0.6 * scaleY;
        }

        // Generate scenery elements based on theme
        function generateScenery(theme, levelNum) {
            sceneryElements = [];
            const colors = ['#FF69B4', '#FF6347', '#FFD700', '#9370DB', '#00CED1'];
            const streetNames = ['MAIN ST', 'OAK AVE', 'PARK RD', 'ELM ST', 'GRAPE LN'];

            for (let x = 100; x < worldWidth; x += 80 + Math.random() * 120) {
                const worldPos = x / worldWidth;  // 0-1 position in world
                const rand = Math.random();

                // Theme-based scenery generation
                if (theme === 'countryside' || (theme === 'mixed' && worldPos < 0.4)) {
                    // Countryside elements
                    if (rand < 0.25) {
                        sceneryElements.push({type: 'tree', x: x, size: 0.8 + Math.random() * 0.4});
                    } else if (rand < 0.4) {
                        sceneryElements.push({type: 'shrub', x: x, size: 0.7 + Math.random() * 0.5});
                    } else if (rand < 0.5) {
                        sceneryElements.push({type: 'flower', x: x, color: colors[Math.floor(Math.random() * colors.length)]});
                    } else if (rand < 0.55) {
                        sceneryElements.push({type: 'fence', x: x, width: 80 + Math.random() * 40});
                        x += 60;  // Skip ahead after fence
                    }
                } else if (theme === 'suburbs' || (theme === 'mixed' && worldPos < 0.7)) {
                    // Suburban elements
                    if (rand < 0.2) {
                        sceneryElements.push({type: 'house', x: x, style: Math.floor(Math.random() * 4)});
                        x += 100;  // Skip ahead after house
                    } else if (rand < 0.35) {
                        sceneryElements.push({type: 'tree', x: x, size: 0.6 + Math.random() * 0.3});
                    } else if (rand < 0.45) {
                        sceneryElements.push({type: 'mailbox', x: x});
                    } else if (rand < 0.55) {
                        sceneryElements.push({type: 'shrub', x: x, size: 0.5 + Math.random() * 0.3});
                    } else if (rand < 0.6) {
                        sceneryElements.push({type: 'lamppost', x: x});
                    }
                } else {
                    // Downtown/city elements
                    if (rand < 0.3) {
                        sceneryElements.push({
                            type: 'building',
                            x: x,
                            width: 80 + Math.random() * 60,
                            height: 150 + Math.random() * 150,
                            style: Math.floor(Math.random() * 5)
                        });
                        x += 120;  // Skip ahead after building
                    } else if (rand < 0.45) {
                        sceneryElements.push({type: 'lamppost', x: x});
                    } else if (rand < 0.55) {
                        sceneryElements.push({type: 'hydrant', x: x});
                    } else if (rand < 0.65) {
                        sceneryElements.push({type: 'bench', x: x});
                    } else if (rand < 0.7) {
                        sceneryElements.push({type: 'sign', x: x, text: streetNames[Math.floor(Math.random() * streetNames.length)]});
                    }
                }
            }

            // Always add lemonade stand near the start for level 1
            if (levelNum === 1) {
                // Mark position for lemonade stand
                sceneryElements.push({type: 'lemonadeStand', x: 400 * scaleX});
            }

            // Add finish banner at the end of every level
            sceneryElements.push({type: 'finishBanner', x: worldWidth - 80 * scaleX});

            // Sort by x position for proper rendering order
            sceneryElements.sort((a, b) => a.x - b.x);
        }

        function checkPlatformCollision() {
            duck.onGround = false;

            for (const p of platforms) {
                if (duck.x + duck.width > p.x &&
                    duck.x < p.x + p.width &&
                    duck.y + duck.height > p.y &&
                    duck.y + duck.height < p.y + p.height + duck.vy + 5 &&
                    duck.vy >= 0) {

                    duck.y = p.y - duck.height;
                    duck.vy = 0;
                    duck.onGround = true;
                }
            }
        }

        function checkGrapeCollection() {
            for (const grape of grapes) {
                if (!grape.collected) {
                    const dx = (duck.x + duck.width/2) - grape.x;
                    const dy = (duck.y + duck.height/2) - grape.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);

                    if (dist < 40 * scale) {
                        grape.collected = true;
                        grapesCollected++;
                        totalGrapesCollected++;
                        showMessage("Got a grape!");

                        // Check if all grapes collected - prompt to reach end
                        if (grapesCollected === totalGrapes) {
                            showMessage("All grapes! Reach the end!");
                        }
                    }
                }
            }
        }

        function showMessage(msg) {
            gameMessage = msg;
            messageTimer = 90;
        }

        // Demo AI - finds nearest uncollected grape and moves toward it
        function updateDemoAI() {
            if (!demoMode) return;

            // Find nearest uncollected grape (within reasonable range for demo)
            let nearestDist = Infinity;
            targetGrape = null;
            for (const grape of grapes) {
                if (!grape.collected) {
                    const dx = grape.x - (duck.x + duck.width/2);
                    const dy = grape.y - (duck.y + duck.height/2);
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    // Prefer grapes ahead and not too far
                    if (dist < nearestDist && dx > -200 * scaleX) {
                        nearestDist = dist;
                        targetGrape = grape;
                    }
                }
            }

            if (!targetGrape) {
                // All grapes collected or none ahead, reset level for demo
                generateLevel(level);
                camera.x = 0;
                return;
            }

            // Move toward target grape
            const dx = targetGrape.x - (duck.x + duck.width/2);
            const threshold = 20 * scaleX;

            if (dx > threshold) {
                duck.vx = duck.speed * 0.8;
                duck.facing = 1;
            } else if (dx < -threshold) {
                duck.vx = -duck.speed * 0.8;
                duck.facing = -1;
            } else {
                duck.vx *= friction;
            }

            // Jump logic
            demoJumpCooldown--;
            const needsToJumpUp = targetGrape.y < duck.y - 30 * scaleY;

            // Check if there's a platform above we need to reach
            let platformAbove = false;
            for (const p of platforms) {
                if (!p.isGround && p.y < duck.y && p.y > duck.y - 150 * scaleY &&
                    duck.x + duck.width > p.x - 50 * scaleX && duck.x < p.x + p.width + 50 * scaleX) {
                    platformAbove = true;
                    break;
                }
            }

            if (duck.onGround && demoJumpCooldown <= 0 && (needsToJumpUp || platformAbove)) {
                duck.vy = duck.jumpForce;
                duck.onGround = false;
                demoJumpCooldown = 30;
            }
        }

        function update() {
            // Run demo mode even when game not started
            if (demoMode && !gameRunning) {
                updateDemoAI();
            }

            // Player input only when game is running (not demo)
            if (gameRunning && !demoMode) {
                if (keys['ArrowLeft'] || keys['KeyA'] || keys['tiltLeft'] || keys['touchLeft']) {
                    duck.vx = -duck.speed * (keys['tiltLeft'] ? duck.tiltAmount : 1);
                    duck.facing = -1;
                } else if (keys['ArrowRight'] || keys['KeyD'] || keys['tiltRight'] || keys['touchRight']) {
                    duck.vx = duck.speed * (keys['tiltRight'] ? duck.tiltAmount : 1);
                    duck.facing = 1;
                } else {
                    duck.vx *= friction;
                }

                if ((keys['Space'] || keys['ArrowUp'] || keys['KeyW'] || keys['touchJump']) && duck.onGround) {
                    duck.vy = duck.jumpForce;
                    duck.onGround = false;
                    keys['touchJump'] = false; // Reset tap jump
                }
            }

            duck.vy += gravity;
            duck.x += duck.vx;
            duck.y += duck.vy;

            // Boundaries - world coordinates
            if (duck.x < 0) duck.x = 0;
            if (duck.x + duck.width > worldWidth) duck.x = worldWidth - duck.width;

            // Fall off screen
            if (duck.y > canvas.height + 50) {
                const groundY = canvas.height * 0.86;
                duck.x = 50 * scaleX;
                duck.y = groundY - duck.height - 10;
                duck.vy = 0;
                camera.x = 0;
                if (gameRunning) showMessage("Whoops! Try again!");
            }

            // Check if reached end of level
            if (gameRunning && !levelCompleting && duck.x > worldWidth - 100 * scaleX && grapesCollected === totalGrapes) {
                levelCompleting = true;
                if (level >= MAX_LEVEL) {
                    showMessage("You Win! Reached the city!");
                    setTimeout(() => {
                        gameRunning = false;
                        levelCompleting = false;
                        document.getElementById('totalGrapes').textContent = totalGrapesCollected;
                        winScreen.classList.remove('hidden');
                    }, 1500);
                } else {
                    showMessage("Level Complete! Onward!");
                    setTimeout(() => {
                        level++;
                        levelCompleting = false;
                        generateLevel(level);
                    }, 1500);
                }
            }

            // Walk animation
            if (Math.abs(duck.vx) > 0.5) {
                duck.walkTimer++;
                if (duck.walkTimer > 5) {
                    duck.walkFrame++;
                    duck.walkTimer = 0;
                }
            } else {
                duck.walkFrame = 0;
            }

            checkPlatformCollision();

            // Only collect grapes and update UI when game is running
            if (gameRunning) {
                checkGrapeCollection();
                grapeCountEl.textContent = grapesCollected + '/' + totalGrapes;
                levelNumEl.textContent = level;
            } else if (demoMode) {
                // Demo mode grape collection (just for show, resets)
                for (const grape of grapes) {
                    if (!grape.collected) {
                        const dx = (duck.x + duck.width/2) - grape.x;
                        const dy = (duck.y + duck.height/2) - grape.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < 40 * scale) {
                            grape.collected = true;
                        }
                    }
                }
            }

            if (messageTimer > 0) messageTimer--;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Update camera to follow duck
            updateCamera();

            const groundY = canvas.height * 0.86;

            // Draw SVG backgrounds
            drawSVGBackgrounds();

            // Level indicator (fixed on screen)
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.font = `bold ${50 * scale}px Comic Sans MS`;
            ctx.textAlign = 'center';
            ctx.fillText('LEVEL ' + level, canvas.width/2, canvas.height * 0.55);

            // Draw scenery elements (with camera offset, culled for performance)
            for (const elem of sceneryElements) {
                const screenX = elem.x - camera.x;
                // Only draw if on screen (with margin for large elements)
                if (screenX > -200 * scale && screenX < canvas.width + 200 * scale) {
                    if (elem.type === 'lemonadeStand') {
                        drawLemonadeStandAt(screenX);
                    } else {
                        drawSceneryElement(elem, screenX);
                    }
                }
            }

            // Platforms (skip ground, apply camera offset)
            for (const p of platforms) {
                if (!p.isGround) {
                    const screenX = p.x - camera.x;
                    // Only draw if on screen
                    if (screenX + p.width > 0 && screenX < canvas.width) {
                        drawPlatform({...p, x: screenX});
                    }
                }
            }

            // Grapes (with camera offset)
            for (const grape of grapes) {
                if (!grape.collected) {
                    const screenX = grape.x - camera.x;
                    if (screenX > -30 && screenX < canvas.width + 30) {
                        drawGrape(screenX, grape.y, grape.size);
                    }
                }
            }

            // Duck (with camera offset)
            const duckScreenX = duck.x - camera.x;
            drawDuck(duckScreenX, duck.y, duck.facing, duck.walkFrame);

            // Speech bubble when near lemonade stand
            const standElem = sceneryElements.find(e => e.type === 'lemonadeStand');
            if (standElem) {
                const standScreenX = standElem.x - camera.x;
                if (Math.abs(duckScreenX - standScreenX) < 100 * scale && duck.y > canvas.height * 0.7) {
                    const bubbleX = standScreenX + 60 * scale;
                    const bubbleY = canvas.height * 0.5;
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.ellipse(bubbleX, bubbleY, 70 * scale, 30 * scale, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.moveTo(bubbleX - 20 * scale, bubbleY + 25 * scale);
                    ctx.lineTo(bubbleX - 10 * scale, bubbleY + 40 * scale);
                    ctx.lineTo(bubbleX, bubbleY + 25 * scale);
                    ctx.fill();
                    ctx.stroke();

                    ctx.fillStyle = '#000';
                    ctx.font = `bold ${12 * scale}px Comic Sans MS`;
                    ctx.textAlign = 'center';
                    ctx.fillText("We only sell", bubbleX, bubbleY - 5 * scale);
                    ctx.fillText("LEMONADE!", bubbleX, bubbleY + 10 * scale);
                }
            }

            // Progress indicator (how far through level)
            const progress = Math.min(duck.x / (worldWidth - canvas.width * 0.5), 1);
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(10 * scale, canvas.height - 20 * scaleY, 100 * scale, 8 * scaleY);
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(10 * scale, canvas.height - 20 * scaleY, progress * 100 * scale, 8 * scaleY);

            // End zone indicator (arrow pointing right at edge of screen when near end)
            if (duck.x > worldWidth - canvas.width * 1.5) {
                const arrowX = canvas.width - 30 * scale;
                const arrowY = canvas.height * 0.5;
                const pulse = Math.sin(Date.now() * 0.005) * 5 * scale;

                // Arrow glow
                ctx.fillStyle = grapesCollected === totalGrapes ? 'rgba(50, 205, 50, 0.5)' : 'rgba(255, 215, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(arrowX + pulse, arrowY, 25 * scale, 0, Math.PI * 2);
                ctx.fill();

                // Arrow
                ctx.fillStyle = grapesCollected === totalGrapes ? '#32CD32' : '#FFD700';
                ctx.beginPath();
                ctx.moveTo(arrowX - 15 * scale + pulse, arrowY - 12 * scale);
                ctx.lineTo(arrowX + 15 * scale + pulse, arrowY);
                ctx.lineTo(arrowX - 15 * scale + pulse, arrowY + 12 * scale);
                ctx.closePath();
                ctx.fill();

                // "FINISH" text when all grapes collected
                if (grapesCollected === totalGrapes) {
                    ctx.fillStyle = '#32CD32';
                    ctx.font = `bold ${14 * scale}px Comic Sans MS`;
                    ctx.textAlign = 'center';
                    ctx.fillText('FINISH!', arrowX, arrowY + 35 * scale);
                }
            }

            // Message
            if (messageTimer > 0) {
                const msgW = 400 * scaleX;
                const msgH = 50 * scaleY;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect((canvas.width - msgW) / 2, 20 * scaleY, msgW, msgH);
                ctx.fillStyle = '#FFD700';
                ctx.font = `bold ${24 * scale}px Comic Sans MS`;
                ctx.textAlign = 'center';
                ctx.fillText(gameMessage, canvas.width / 2, 20 * scaleY + msgH * 0.65);
            }
        }

        // Draw lemonade stand at specific screen X position
        function drawLemonadeStandAt(screenX) {
            const groundY = canvas.height * 0.86;
            const s = scale;
            const x = screenX - 60 * s;
            const y = groundY - 150 * s;

            // Stand base
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(x, y + 70*s, 120*s, 80*s);
            ctx.strokeStyle = '#5D2E0C';
            ctx.lineWidth = 3;
            ctx.strokeRect(x, y + 70*s, 120*s, 80*s);

            // Counter top
            ctx.fillStyle = '#A0522D';
            ctx.fillRect(x - 5*s, y + 65*s, 130*s, 10*s);

            // Sign board
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(x + 10*s, y - 30*s, 100*s, 40*s);
            ctx.strokeRect(x + 10*s, y - 30*s, 100*s, 40*s);

            // Sign text
            ctx.fillStyle = '#FFD700';
            ctx.font = `bold ${12*s}px Comic Sans MS`;
            ctx.textAlign = 'center';
            ctx.fillText('ICE FRESH', x + 60*s, y - 12*s);

            ctx.fillStyle = '#FFD700';
            ctx.font = `bold ${14*s}px Comic Sans MS`;
            ctx.fillText('Lemonade', x + 60*s, y + 90*s);

            // Roof poles
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 5*s;
            ctx.beginPath();
            ctx.moveTo(x + 20*s, y - 30*s);
            ctx.lineTo(x + 20*s, y + 70*s);
            ctx.moveTo(x + 100*s, y - 30*s);
            ctx.lineTo(x + 100*s, y + 70*s);
            ctx.stroke();

            // Lemonade pitcher
            ctx.fillStyle = '#FFFF99';
            ctx.beginPath();
            ctx.ellipse(x + 45*s, y + 55*s, 12*s, 15*s, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(x + 58*s, y + 55*s, 8*s, -Math.PI/2, Math.PI/2);
            ctx.stroke();

            // Lemonade man
            ctx.fillStyle = '#FDBF6F';
            ctx.beginPath();
            ctx.arc(x + 75*s, y + 30*s, 15*s, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.arc(x + 75*s, y + 22*s, 14*s, Math.PI, 2 * Math.PI);
            ctx.fill();

            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(x + 70*s, y + 28*s, 4*s, 0, Math.PI * 2);
            ctx.arc(x + 80*s, y + 28*s, 4*s, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(x + 70*s, y + 28*s, 2*s, 0, Math.PI * 2);
            ctx.arc(x + 80*s, y + 28*s, 2*s, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x + 75*s, y + 40*s, 5*s, 0.2 * Math.PI, 0.8 * Math.PI);
            ctx.stroke();

            ctx.fillStyle = '#4169E1';
            ctx.fillRect(x + 60*s, y + 45*s, 30*s, 25*s);
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        function startGame() {
            startScreen.classList.add('hidden');
            winScreen.classList.add('hidden');

            level = 1;
            totalGrapesCollected = 0;
            demoMode = false;
            generateLevel(1);
            gameRunning = true;

            // Request motion permission on game start (works on iOS)
            requestMotionPermission();

            // Auto-play music when game starts
            if (!musicPlaying) {
                bgMusic.play().catch(e => console.log('Audio play failed:', e));
                musicBtn.textContent = 'Music: ON';
                musicPlaying = true;
            }
        }

        // Event listeners
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        // Mobile touch controls - tap to jump, touch sides to move (fallback if no tilt)
        let activeTouchId = null;

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.changedTouches[0];
            const rect = canvas.getBoundingClientRect();
            const x = (touch.clientX - rect.left) / rect.width;

            // Tap to jump
            keys['touchJump'] = true;

            // Fallback touch controls: left 30% = left, right 30% = right, middle = just jump
            if (!tiltEnabled) {
                activeTouchId = touch.identifier;
                if (x < 0.3) {
                    keys['touchLeft'] = true;
                    keys['touchRight'] = false;
                } else if (x > 0.7) {
                    keys['touchRight'] = true;
                    keys['touchLeft'] = false;
                }
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!tiltEnabled && activeTouchId !== null) {
                for (const touch of e.changedTouches) {
                    if (touch.identifier === activeTouchId) {
                        const rect = canvas.getBoundingClientRect();
                        const x = (touch.clientX - rect.left) / rect.width;
                        if (x < 0.3) {
                            keys['touchLeft'] = true;
                            keys['touchRight'] = false;
                        } else if (x > 0.7) {
                            keys['touchRight'] = true;
                            keys['touchLeft'] = false;
                        } else {
                            keys['touchLeft'] = false;
                            keys['touchRight'] = false;
                        }
                    }
                }
            }
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            for (const touch of e.changedTouches) {
                if (touch.identifier === activeTouchId) {
                    activeTouchId = null;
                    keys['touchLeft'] = false;
                    keys['touchRight'] = false;
                }
            }
        });

        // Tilt controls for movement (uses device orientation)
        let tiltEnabled = false;
        let tiltSensitivity = 0.5; // 0.1 to 1.0, controlled by slider
        const tiltDeadzone = 5; // degrees of deadzone before movement starts
        const tiltMaxAngle = 20; // degrees at which full speed is reached

        // Sensitivity slider handler
        const sensitivitySlider = document.getElementById('tiltSensitivity');
        const sensitivityValue = document.getElementById('sensitivityValue');
        sensitivitySlider.addEventListener('input', (e) => {
            tiltSensitivity = e.target.value / 100;
            sensitivityValue.textContent = e.target.value;
        });

        function handleOrientation(e) {
            if (!gameRunning || demoMode) return;

            // gamma is left-right tilt (-90 to 90)
            let tilt = e.gamma || 0;

            // Apply sensitivity - lower sensitivity = need more tilt
            const adjustedDeadzone = tiltDeadzone + (1 - tiltSensitivity) * 10;
            const adjustedMaxAngle = tiltMaxAngle + (1 - tiltSensitivity) * 20;

            // Handle device held in portrait mode
            if (tilt > adjustedDeadzone) {
                // Tilted right
                keys['tiltRight'] = true;
                keys['tiltLeft'] = false;
                duck.tiltAmount = Math.min((tilt - adjustedDeadzone) / (adjustedMaxAngle - adjustedDeadzone), 1);
                duck.tiltAmount = Math.max(duck.tiltAmount, 0.3 + tiltSensitivity * 0.4); // min speed scales with sensitivity
            } else if (tilt < -adjustedDeadzone) {
                // Tilted left
                keys['tiltLeft'] = true;
                keys['tiltRight'] = false;
                duck.tiltAmount = Math.min((-tilt - adjustedDeadzone) / (adjustedMaxAngle - adjustedDeadzone), 1);
                duck.tiltAmount = Math.max(duck.tiltAmount, 0.3 + tiltSensitivity * 0.4); // min speed scales with sensitivity
            } else {
                keys['tiltLeft'] = false;
                keys['tiltRight'] = false;
                duck.tiltAmount = 0;
            }
        }

        // Request permission for device orientation (required on iOS 13+)
        function requestMotionPermission() {
            if (typeof DeviceOrientationEvent !== 'undefined' &&
                typeof DeviceOrientationEvent.requestPermission === 'function') {
                // iOS 13+ requires permission request
                DeviceOrientationEvent.requestPermission()
                    .then(response => {
                        if (response === 'granted') {
                            window.addEventListener('deviceorientation', handleOrientation);
                            tiltEnabled = true;
                        }
                    })
                    .catch(err => console.log('Motion permission error:', err));
            } else if (window.DeviceOrientationEvent) {
                // Non-iOS or older iOS - just add listener
                window.addEventListener('deviceorientation', handleOrientation);
                tiltEnabled = true;
            }
        }

        // Request permission on first user interaction (required for iOS)
        function initMotionOnce() {
            requestMotionPermission();
            document.removeEventListener('touchstart', initMotionOnce);
            document.removeEventListener('click', initMotionOnce);
        }
        document.addEventListener('touchstart', initMotionOnce, { once: true });
        document.addEventListener('click', initMotionOnce, { once: true });

        // Handle window resize
        window.addEventListener('resize', () => {
            resizeCanvas();
            generateLevel(level); // Regenerate level for new dimensions
        });

        // Initialize
        loadBackgrounds();
        resizeCanvas();
        generateLevel(1);
        gameLoop();
    </script>
</body>
</html>
