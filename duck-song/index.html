<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Duck Song - Got Any Grapes?</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            min-height: 100dvh; /* dynamic viewport height for mobile */
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: 'Comic Sans MS', cursive, sans-serif;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }
        #gameContainer {
            position: relative; /* allow absolute children to center over the canvas */
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            width: 100%;
            height: 100%;
            max-width: 900px;
        }
        /* Make canvas scale down on small screens while keeping the game's logical resolution (800x500) */
        #gameCanvas {
            border: 4px solid #8B4513;
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.3);
            width: min(95vw, 800px);
            height: auto;
            display: block;
            touch-action: none; /* prevent browser gestures interfering with game touches */
        }
        /* Full screen mode for mobile - detect touch devices */
        @media (pointer: coarse), (max-width: 600px) {
            html, body {
                height: 100%;
                height: -webkit-fill-available;
            }
            #gameContainer {
                padding: 0;
                max-width: none;
                height: 100%;
                height: -webkit-fill-available;
            }
            #gameCanvas {
                width: 100%;
                height: 100%;
                border: none;
                border-radius: 0;
            }
            #title, #instructions {
                display: none;
            }
            #ui {
                position: absolute;
                top: env(safe-area-inset-top, 10px);
                left: 50%;
                transform: translateX(-50%);
                z-index: 100;
                margin: 0;
                padding: 8px 16px;
                font-size: 14px;
                background: rgba(0,0,0,0.6);
            }
        }
        #ui {
            display: flex;
            gap: 30px;
            margin-bottom: 10px;
            color: white;
            font-size: 18px;
            background: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border-radius: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        #instructions {
            color: #aaa;
            margin-top: 10px;
            text-align: center;
            font-size: 14px;
        }
        #title {
            color: #FFD700;
            font-size: 28px;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            text-align: center;
        }
        #musicBtn {
            background: #FFD700;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-family: inherit;
            font-size: 14px;
            transition: transform 0.1s;
        }
        #musicBtn:hover {
            transform: scale(1.05);
        }
        #startScreen, #winScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.85);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            width: min(90%, 600px);
            box-shadow: 0 8px 30px rgba(0,0,0,0.5);
        }
        .screen-btn {
            background: #FFD700;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-family: inherit;
            font-size: 20px;
            margin-top: 20px;
            transition: transform 0.1s, background 0.2s;
        }
        .screen-btn:hover {
            transform: scale(1.1);
            background: #FFA500;
        }
        .hidden { display: none !important; }

        /* Responsive tweaks */
        @media (max-width: 600px) {
            #title { font-size: 20px; }
            #ui { font-size: 14px; gap: 10px; padding: 8px 12px; }
            #instructions { font-size: 12px; }
            .screen-btn { font-size: 18px; padding: 12px 22px; }
            #startScreen, #winScreen { padding: 20px; }
            #musicBtn { font-size: 12px; padding: 6px 12px; }
            #startScreen h1, #winScreen h1 { font-size: 28px !important; }
            #startScreen p, #winScreen p { font-size: 14px !important; }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="title">The Duck Song Game - Got Any Grapes?</div>
        <div id="ui">
            <span>Grapes: <span id="grapeCount">0</span></span>
            <span>Level: <span id="levelNum">1</span></span>
            <button id="musicBtn" onclick="toggleMusic()">Music: OFF</button>
        </div>
        <canvas id="gameCanvas" width="800" height="500"></canvas>
        <div id="instructions">
            Arrow Keys / WASD to move | SPACE to jump | Mobile: Tilt to move, Tap to jump!
        </div>

        <div id="startScreen">
            <h1 style="color: #FFD700; font-size: 36px;">The Duck Song Game</h1>
            <p style="margin: 20px 0; font-size: 18px;">Help the duck collect grapes!<br>Visit the lemonade stand along the way.</p>
            <p style="color: #aaa;">Desktop: Arrow Keys / WASD + Space<br>Mobile: Tilt to move, Tap to jump!<br><span style="font-size: 12px;">(Or tap left/right sides to move)</span></p>
            <button class="screen-btn" onclick="startGame()">Start Game!</button>
        </div>

        <div id="winScreen" class="hidden">
            <h1 style="color: #FFD700; font-size: 36px;">You Win!</h1>
            <p style="margin: 20px 0; font-size: 18px;">The duck finally got all the grapes!</p>
            <p style="color: #8B008B;">Total grapes collected: <span id="totalGrapes">0</span></p>
            <button class="screen-btn" onclick="startGame()">Play Again</button>
        </div>
    </div>

    <audio id="bgMusic" loop>
        <source src="duck_song.mp3" type="audio/mpeg">
    </audio>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const grapeCountEl = document.getElementById('grapeCount');
        const levelNumEl = document.getElementById('levelNum');
        const musicBtn = document.getElementById('musicBtn');
        const bgMusic = document.getElementById('bgMusic');
        const startScreen = document.getElementById('startScreen');
        const winScreen = document.getElementById('winScreen');

        // Reference dimensions (original design)
        const REF_WIDTH = 800;
        const REF_HEIGHT = 500;

        // Scale factors - updated on resize
        let scaleX = 1;
        let scaleY = 1;
        let scale = 1; // uniform scale for sprites

        // Resize canvas to fill screen
        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            canvas.width = container.clientWidth || window.innerWidth;
            canvas.height = container.clientHeight || window.innerHeight;

            scaleX = canvas.width / REF_WIDTH;
            scaleY = canvas.height / REF_HEIGHT;
            scale = Math.min(scaleX, scaleY); // uniform scale for sprites

            // Update duck size based on scale
            duck.width = 50 * scale;
            duck.height = 60 * scale;
            duck.speed = 5 * scaleX;
            duck.jumpForce = -14 * scaleY;
        }

        // Helper to convert reference coords to screen coords
        function sx(x) { return x * scaleX; }
        function sy(y) { return y * scaleY; }

        // Game state
        let gameRunning = false;
        let demoMode = true;
        let keys = {};
        let grapes = [];
        let platforms = [];
        let level = 1;
        let grapesCollected = 0;
        let totalGrapesCollected = 0;
        let totalGrapes = 0;
        let gameMessage = '';
        let messageTimer = 0;
        let musicPlaying = false;

        // Demo AI state
        let targetGrape = null;
        let demoJumpCooldown = 0;

        const MAX_LEVEL = 5;

        // Duck player (positions will be in screen coords)
        const duck = {
            x: 100,
            y: 300,
            width: 50,
            height: 60,
            vx: 0,
            vy: 0,
            speed: 5,
            jumpForce: -14,
            onGround: false,
            facing: 1,
            walkFrame: 0,
            walkTimer: 0,
            tiltAmount: 0
        };

        // Physics (scaled on resize)
        let gravity = 0.6;
        const friction = 0.85;

        // Remove unused lemonadeStand object - position is now calculated dynamically

        function toggleMusic() {
            if (musicPlaying) {
                bgMusic.pause();
                musicBtn.textContent = 'Music: OFF';
                musicPlaying = false;
            } else {
                bgMusic.play().catch(e => console.log('Audio play failed:', e));
                musicBtn.textContent = 'Music: ON';
                musicPlaying = true;
            }
        }

        // Draw the duck (cartoon style) - scaled version
        function drawDuck(x, y, facing, walkFrame) {
            ctx.save();
            ctx.translate(x + duck.width/2, y + duck.height/2);
            ctx.scale(facing * scale, scale);
            ctx.translate(-25, -30); // center on reference duck size

            // Body (yellow oval)
            ctx.fillStyle = '#FFB830';
            ctx.beginPath();
            ctx.ellipse(25, 35, 22, 28, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Head
            ctx.fillStyle = '#FFB830';
            ctx.beginPath();
            ctx.arc(30, 12, 16, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Beak (orange)
            ctx.fillStyle = '#FF6B35';
            ctx.beginPath();
            ctx.moveTo(44, 10);
            ctx.lineTo(60, 14);
            ctx.lineTo(44, 18);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Eye (white with black pupil)
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.ellipse(36, 8, 6, 7, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Pupil
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(38, 8, 3, 0, Math.PI * 2);
            ctx.fill();

            // Legs
            ctx.strokeStyle = '#FF6B35';
            ctx.lineWidth = 3;
            const legOffset = Math.sin(walkFrame * 0.3) * 5;

            ctx.beginPath();
            ctx.moveTo(18, 58);
            ctx.lineTo(15 - legOffset, 70);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(32, 58);
            ctx.lineTo(35 + legOffset, 70);
            ctx.stroke();

            // Feet
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(10 - legOffset, 70);
            ctx.lineTo(20 - legOffset, 70);
            ctx.moveTo(30 + legOffset, 70);
            ctx.lineTo(40 + legOffset, 70);
            ctx.stroke();

            ctx.restore();
        }

        // Draw a grape bunch (scaled)
        function drawGrape(x, y, size) {
            const s = size * scale;
            const grapeColor = '#8B008B';
            const highlight = '#9932CC';

            ctx.strokeStyle = '#228B22';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x, y - s);
            ctx.lineTo(x, y - s - 10 * scale);
            ctx.stroke();

            ctx.fillStyle = '#228B22';
            ctx.beginPath();
            ctx.ellipse(x + 5 * scale, y - s - 8 * scale, 8 * scale, 4 * scale, 0.3, 0, Math.PI * 2);
            ctx.fill();

            const positions = [
                {dx: 0, dy: 0},
                {dx: -s*0.7, dy: -s*0.4},
                {dx: s*0.7, dy: -s*0.4},
                {dx: -s*0.35, dy: s*0.5},
                {dx: s*0.35, dy: s*0.5},
                {dx: 0, dy: s*0.9}
            ];

            positions.forEach(pos => {
                ctx.fillStyle = grapeColor;
                ctx.beginPath();
                ctx.arc(x + pos.dx, y + pos.dy, s * 0.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#4B0082';
                ctx.lineWidth = 1;
                ctx.stroke();

                ctx.fillStyle = highlight;
                ctx.beginPath();
                ctx.arc(x + pos.dx - 2 * scale, y + pos.dy - 2 * scale, s * 0.15, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // Draw lemonade stand (scaled) - positioned relative to screen
        function drawLemonadeStand() {
            const x = canvas.width * 0.75 - 60 * scale;
            const y = canvas.height - sy(220);
            const s = scale;

            // Stand base
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(x, y + 70*s, 120*s, 80*s);
            ctx.strokeStyle = '#5D2E0C';
            ctx.lineWidth = 3;
            ctx.strokeRect(x, y + 70*s, 120*s, 80*s);

            // Counter top
            ctx.fillStyle = '#A0522D';
            ctx.fillRect(x - 5*s, y + 65*s, 130*s, 10*s);

            // Sign board
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(x + 10*s, y - 30*s, 100*s, 40*s);
            ctx.strokeRect(x + 10*s, y - 30*s, 100*s, 40*s);

            // Sign text
            ctx.fillStyle = '#FFD700';
            ctx.font = `bold ${12*s}px Comic Sans MS`;
            ctx.textAlign = 'center';
            ctx.fillText('ICE FRESH', x + 60*s, y - 12*s);

            ctx.fillStyle = '#FFD700';
            ctx.font = `bold ${14*s}px Comic Sans MS`;
            ctx.fillText('Lemonade', x + 60*s, y + 90*s);

            // Roof poles
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 5*s;
            ctx.beginPath();
            ctx.moveTo(x + 20*s, y - 30*s);
            ctx.lineTo(x + 20*s, y + 70*s);
            ctx.moveTo(x + 100*s, y - 30*s);
            ctx.lineTo(x + 100*s, y + 70*s);
            ctx.stroke();

            // Lemonade pitcher
            ctx.fillStyle = '#FFFF99';
            ctx.beginPath();
            ctx.ellipse(x + 45*s, y + 55*s, 12*s, 15*s, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(x + 58*s, y + 55*s, 8*s, -Math.PI/2, Math.PI/2);
            ctx.stroke();

            // Lemonade man
            ctx.fillStyle = '#FDBF6F';
            ctx.beginPath();
            ctx.arc(x + 75*s, y + 30*s, 15*s, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.arc(x + 75*s, y + 22*s, 14*s, Math.PI, 2 * Math.PI);
            ctx.fill();

            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(x + 70*s, y + 28*s, 4*s, 0, Math.PI * 2);
            ctx.arc(x + 80*s, y + 28*s, 4*s, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(x + 70*s, y + 28*s, 2*s, 0, Math.PI * 2);
            ctx.arc(x + 80*s, y + 28*s, 2*s, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x + 75*s, y + 40*s, 5*s, 0.2 * Math.PI, 0.8 * Math.PI);
            ctx.stroke();

            ctx.fillStyle = '#4169E1';
            ctx.fillRect(x + 60*s, y + 45*s, 30*s, 25*s);
        }

        // Draw background (fully responsive)
        function drawBackground() {
            const groundY = canvas.height * 0.86; // Ground starts at 86% down
            const horizonY = canvas.height * 0.6;  // Horizon at 60% down

            // Sky gradient - fills to horizon
            const skyGradient = ctx.createLinearGradient(0, 0, 0, horizonY);
            skyGradient.addColorStop(0, '#87CEEB');
            skyGradient.addColorStop(1, '#B0E0E6');
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, horizonY);

            // Sun (top right)
            const sunX = canvas.width * 0.9;
            const sunY = canvas.height * 0.12;
            const sunR = 35 * scale;
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(sunX, sunY, sunR, 0, Math.PI * 2);
            ctx.fill();

            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 3 * scale;
                ctx.beginPath();
                ctx.moveTo(sunX + Math.cos(angle) * sunR * 1.15, sunY + Math.sin(angle) * sunR * 1.15);
                ctx.lineTo(sunX + Math.cos(angle) * sunR * 1.6, sunY + Math.sin(angle) * sunR * 1.6);
                ctx.stroke();
            }

            // Hills
            ctx.fillStyle = '#3CB371';
            ctx.beginPath();
            ctx.moveTo(0, horizonY);
            ctx.quadraticCurveTo(canvas.width * 0.25, horizonY - 70 * scaleY, canvas.width * 0.5, horizonY);
            ctx.quadraticCurveTo(canvas.width * 0.75, horizonY - 70 * scaleY, canvas.width, horizonY);
            ctx.lineTo(canvas.width, groundY);
            ctx.lineTo(0, groundY);
            ctx.closePath();
            ctx.fill();

            // City silhouette (left side)
            ctx.fillStyle = '#696969';
            const cityX = canvas.width * 0.06;
            const cityY = horizonY - 20 * scaleY;
            ctx.fillRect(cityX, cityY, 30 * scale, 70 * scaleY);
            ctx.fillRect(cityX + 35 * scale, cityY + 20 * scaleY, 25 * scale, 50 * scaleY);
            ctx.fillRect(cityX + 65 * scale, cityY - 10 * scaleY, 35 * scale, 80 * scaleY);
            ctx.fillRect(cityX + 105 * scale, cityY + 10 * scaleY, 20 * scale, 60 * scaleY);

            // Tree
            const treeX = canvas.width * 0.23;
            const treeY = horizonY;
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(treeX, treeY, 15 * scale, 100 * scaleY);
            ctx.fillStyle = '#228B22';
            ctx.beginPath();
            ctx.arc(treeX + 7 * scale, treeY - 20 * scaleY, 40 * scale, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(treeX - 10 * scale, treeY, 30 * scale, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(treeX + 25 * scale, treeY - 5 * scaleY, 32 * scale, 0, Math.PI * 2);
            ctx.fill();

            // Ground
            ctx.fillStyle = '#32CD32';
            ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);

            // Grass texture
            ctx.strokeStyle = '#228B22';
            ctx.lineWidth = 1;
            for (let i = 0; i < canvas.width; i += 15 * scale) {
                ctx.beginPath();
                ctx.moveTo(i, groundY);
                ctx.lineTo(i + 3 * scale, groundY - 5 * scaleY);
                ctx.moveTo(i + 7 * scale, groundY);
                ctx.lineTo(i + 10 * scale, groundY - 7 * scaleY);
                ctx.stroke();
            }

            // Level indicator
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.font = `bold ${60 * scale}px Comic Sans MS`;
            ctx.textAlign = 'center';
            ctx.fillText('LEVEL ' + level, canvas.width/2, horizonY - 20 * scaleY);
        }

        // Draw platforms (already in screen coords)
        function drawPlatform(p) {
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(p.x, p.y + 10 * scaleY, p.width, p.height - 10 * scaleY);

            ctx.fillStyle = '#32CD32';
            ctx.fillRect(p.x, p.y, p.width, 15 * scaleY);

            ctx.strokeStyle = '#228B22';
            ctx.lineWidth = 1;
            for (let i = p.x; i < p.x + p.width; i += 10 * scale) {
                ctx.beginPath();
                ctx.moveTo(i + 2 * scale, p.y);
                ctx.lineTo(i + 4 * scale, p.y - 5 * scaleY);
                ctx.stroke();
            }

            ctx.strokeStyle = '#5D2E0C';
            ctx.lineWidth = 2;
            ctx.strokeRect(p.x, p.y, p.width, p.height);
        }

        // Generate level (all positions as fractions 0-1, converted to screen coords)
        function generateLevel(levelNum) {
            platforms = [];
            grapes = [];
            grapesCollected = 0;

            const groundY = canvas.height * 0.86;

            // Ground platform
            platforms.push({x: 0, y: groundY, width: canvas.width, height: canvas.height - groundY});

            // Level configs use fractions (0-1) for positions
            const configs = {
                1: {
                    platforms: [
                        {x: 0.10, y: 0.70, w: 0.125},
                        {x: 0.31, y: 0.56, w: 0.125},
                        {x: 0.52, y: 0.70, w: 0.125}
                    ],
                    grapes: [{x: 0.16, y: 0.64}, {x: 0.37, y: 0.50}, {x: 0.59, y: 0.64}, {x: 0.25, y: 0.80}]
                },
                2: {
                    platforms: [
                        {x: 0.06, y: 0.72, w: 0.125},
                        {x: 0.27, y: 0.58, w: 0.125},
                        {x: 0.49, y: 0.44, w: 0.125}
                    ],
                    grapes: [{x: 0.12, y: 0.66}, {x: 0.34, y: 0.52}, {x: 0.55, y: 0.38}, {x: 0.37, y: 0.80}, {x: 0.62, y: 0.80}]
                },
                3: {
                    platforms: [
                        {x: 0.04, y: 0.74, w: 0.11},
                        {x: 0.22, y: 0.60, w: 0.11},
                        {x: 0.41, y: 0.46, w: 0.11},
                        {x: 0.60, y: 0.60, w: 0.11}
                    ],
                    grapes: [{x: 0.09, y: 0.68}, {x: 0.28, y: 0.54}, {x: 0.47, y: 0.40}, {x: 0.66, y: 0.54}, {x: 0.19, y: 0.80}, {x: 0.50, y: 0.80}]
                },
                4: {
                    platforms: [
                        {x: 0.025, y: 0.74, w: 0.10},
                        {x: 0.19, y: 0.60, w: 0.10},
                        {x: 0.35, y: 0.46, w: 0.10},
                        {x: 0.51, y: 0.32, w: 0.10}
                    ],
                    grapes: [{x: 0.07, y: 0.68}, {x: 0.24, y: 0.54}, {x: 0.40, y: 0.40}, {x: 0.56, y: 0.26}, {x: 0.31, y: 0.80}, {x: 0.62, y: 0.80}]
                },
                5: {
                    platforms: [
                        {x: 0.04, y: 0.76, w: 0.10},
                        {x: 0.20, y: 0.62, w: 0.10},
                        {x: 0.36, y: 0.48, w: 0.10},
                        {x: 0.52, y: 0.34, w: 0.10},
                        {x: 0.36, y: 0.20, w: 0.10}
                    ],
                    grapes: [{x: 0.09, y: 0.70}, {x: 0.25, y: 0.56}, {x: 0.41, y: 0.42}, {x: 0.57, y: 0.28}, {x: 0.41, y: 0.14}, {x: 0.19, y: 0.80}, {x: 0.56, y: 0.80}]
                }
            };

            const config = configs[levelNum] || configs[5];
            const platHeight = 20 * scaleY;

            config.platforms.forEach(p => {
                platforms.push({
                    x: p.x * canvas.width,
                    y: p.y * canvas.height,
                    width: p.w * canvas.width,
                    height: platHeight
                });
            });

            config.grapes.forEach(g => {
                grapes.push({
                    x: g.x * canvas.width,
                    y: g.y * canvas.height,
                    size: 12,
                    collected: false
                });
            });

            totalGrapes = grapes.length;
            duck.x = canvas.width * 0.06;
            duck.y = groundY - duck.height - 10;
            duck.vx = 0;
            duck.vy = 0;

            // Update gravity based on screen height
            gravity = 0.6 * scaleY;
        }

        function checkPlatformCollision() {
            duck.onGround = false;

            for (const p of platforms) {
                if (duck.x + duck.width > p.x &&
                    duck.x < p.x + p.width &&
                    duck.y + duck.height > p.y &&
                    duck.y + duck.height < p.y + p.height + duck.vy + 5 &&
                    duck.vy >= 0) {

                    duck.y = p.y - duck.height;
                    duck.vy = 0;
                    duck.onGround = true;
                }
            }
        }

        function checkGrapeCollection() {
            for (const grape of grapes) {
                if (!grape.collected) {
                    const dx = (duck.x + duck.width/2) - grape.x;
                    const dy = (duck.y + duck.height/2) - grape.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);

                    if (dist < 40 * scale) {
                        grape.collected = true;
                        grapesCollected++;
                        totalGrapesCollected++;
                        showMessage("Got a grape!");

                        if (grapesCollected === totalGrapes) {
                            if (level >= MAX_LEVEL) {
                                showMessage("You Win! Got ALL the grapes!");
                                setTimeout(() => {
                                    gameRunning = false;
                                    document.getElementById('totalGrapes').textContent = totalGrapesCollected;
                                    winScreen.classList.remove('hidden');
                                }, 1500);
                            } else {
                                showMessage("Level Complete!");
                                setTimeout(() => {
                                    level++;
                                    generateLevel(level);
                                }, 1500);
                            }
                        }
                    }
                }
            }
        }

        function showMessage(msg) {
            gameMessage = msg;
            messageTimer = 90;
        }

        // Demo AI - finds nearest uncollected grape and moves toward it
        function updateDemoAI() {
            if (!demoMode) return;

            // Find nearest uncollected grape
            let nearestDist = Infinity;
            targetGrape = null;
            for (const grape of grapes) {
                if (!grape.collected) {
                    const dx = grape.x - (duck.x + duck.width/2);
                    const dy = grape.y - (duck.y + duck.height/2);
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        targetGrape = grape;
                    }
                }
            }

            if (!targetGrape) {
                // All grapes collected, reset level for demo
                generateLevel(level);
                return;
            }

            // Move toward target grape
            const dx = targetGrape.x - (duck.x + duck.width/2);
            const threshold = 20 * scaleX;

            if (dx > threshold) {
                duck.vx = duck.speed * 0.8;
                duck.facing = 1;
            } else if (dx < -threshold) {
                duck.vx = -duck.speed * 0.8;
                duck.facing = -1;
            } else {
                duck.vx *= friction;
            }

            // Jump logic
            demoJumpCooldown--;
            const needsToJumpUp = targetGrape.y < duck.y - 30 * scaleY;

            // Check if there's a platform above we need to reach
            let platformAbove = false;
            for (const p of platforms) {
                if (p.y < duck.y && p.y > duck.y - 150 * scaleY &&
                    duck.x + duck.width > p.x - 50 * scaleX && duck.x < p.x + p.width + 50 * scaleX) {
                    platformAbove = true;
                    break;
                }
            }

            if (duck.onGround && demoJumpCooldown <= 0 && (needsToJumpUp || platformAbove)) {
                duck.vy = duck.jumpForce;
                duck.onGround = false;
                demoJumpCooldown = 30;
            }
        }

        function update() {
            // Run demo mode even when game not started
            if (demoMode && !gameRunning) {
                updateDemoAI();
            }

            // Player input only when game is running (not demo)
            if (gameRunning && !demoMode) {
                if (keys['ArrowLeft'] || keys['KeyA'] || keys['tiltLeft'] || keys['touchLeft']) {
                    duck.vx = -duck.speed * (keys['tiltLeft'] ? duck.tiltAmount : 1);
                    duck.facing = -1;
                } else if (keys['ArrowRight'] || keys['KeyD'] || keys['tiltRight'] || keys['touchRight']) {
                    duck.vx = duck.speed * (keys['tiltRight'] ? duck.tiltAmount : 1);
                    duck.facing = 1;
                } else {
                    duck.vx *= friction;
                }

                if ((keys['Space'] || keys['ArrowUp'] || keys['KeyW'] || keys['touchJump']) && duck.onGround) {
                    duck.vy = duck.jumpForce;
                    duck.onGround = false;
                    keys['touchJump'] = false; // Reset tap jump
                }
            }

            duck.vy += gravity;
            duck.x += duck.vx;
            duck.y += duck.vy;

            // Boundaries
            if (duck.x < 0) duck.x = 0;
            if (duck.x + duck.width > canvas.width) duck.x = canvas.width - duck.width;

            // Fall off screen
            if (duck.y > canvas.height + 50) {
                const groundY = canvas.height * 0.86;
                duck.x = canvas.width * 0.06;
                duck.y = groundY - duck.height - 10;
                duck.vy = 0;
                if (gameRunning) showMessage("Whoops! Try again!");
            }

            // Walk animation
            if (Math.abs(duck.vx) > 0.5) {
                duck.walkTimer++;
                if (duck.walkTimer > 5) {
                    duck.walkFrame++;
                    duck.walkTimer = 0;
                }
            } else {
                duck.walkFrame = 0;
            }

            checkPlatformCollision();

            // Only collect grapes and update UI when game is running
            if (gameRunning) {
                checkGrapeCollection();
                grapeCountEl.textContent = grapesCollected + '/' + totalGrapes;
                levelNumEl.textContent = level;
            } else if (demoMode) {
                // Demo mode grape collection (just for show, resets)
                for (const grape of grapes) {
                    if (!grape.collected) {
                        const dx = (duck.x + duck.width/2) - grape.x;
                        const dy = (duck.y + duck.height/2) - grape.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < 40 * scale) {
                            grape.collected = true;
                        }
                    }
                }
            }

            if (messageTimer > 0) messageTimer--;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawBackground();

            const groundY = canvas.height * 0.86;

            // Platforms (skip ground)
            for (const p of platforms) {
                if (p.y < groundY) drawPlatform(p);
            }

            // Lemonade stand
            drawLemonadeStand();

            // Grapes
            for (const grape of grapes) {
                if (!grape.collected) drawGrape(grape.x, grape.y, grape.size);
            }

            // Duck
            drawDuck(duck.x, duck.y, duck.facing, duck.walkFrame);

            // Speech bubble when near stand (right side of screen, lower area)
            const standX = canvas.width * 0.75;
            if (duck.x > standX - 100 * scale && duck.x < standX + 100 * scale && duck.y > canvas.height * 0.7) {
                const bubbleX = standX + 40 * scale;
                const bubbleY = canvas.height * 0.5;
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.ellipse(bubbleX, bubbleY, 70 * scale, 30 * scale, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.moveTo(bubbleX - 20 * scale, bubbleY + 25 * scale);
                ctx.lineTo(bubbleX - 10 * scale, bubbleY + 40 * scale);
                ctx.lineTo(bubbleX, bubbleY + 25 * scale);
                ctx.fill();
                ctx.stroke();

                ctx.fillStyle = '#000';
                ctx.font = `bold ${12 * scale}px Comic Sans MS`;
                ctx.textAlign = 'center';
                ctx.fillText("We only sell", bubbleX, bubbleY - 5 * scale);
                ctx.fillText("LEMONADE!", bubbleX, bubbleY + 10 * scale);
            }

            // Message
            if (messageTimer > 0) {
                const msgW = 400 * scaleX;
                const msgH = 50 * scaleY;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect((canvas.width - msgW) / 2, 20 * scaleY, msgW, msgH);
                ctx.fillStyle = '#FFD700';
                ctx.font = `bold ${24 * scale}px Comic Sans MS`;
                ctx.textAlign = 'center';
                ctx.fillText(gameMessage, canvas.width / 2, 20 * scaleY + msgH * 0.65);
            }
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        function startGame() {
            startScreen.classList.add('hidden');
            winScreen.classList.add('hidden');

            level = 1;
            totalGrapesCollected = 0;
            demoMode = false;
            generateLevel(1);
            gameRunning = true;

            // Request motion permission on game start (works on iOS)
            requestMotionPermission();

            // Auto-play music when game starts
            if (!musicPlaying) {
                bgMusic.play().catch(e => console.log('Audio play failed:', e));
                musicBtn.textContent = 'Music: ON';
                musicPlaying = true;
            }
        }

        // Event listeners
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        // Mobile touch controls - tap to jump, touch sides to move (fallback if no tilt)
        let activeTouchId = null;

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.changedTouches[0];
            const rect = canvas.getBoundingClientRect();
            const x = (touch.clientX - rect.left) / rect.width;

            // Tap to jump
            keys['touchJump'] = true;

            // Fallback touch controls: left 30% = left, right 30% = right, middle = just jump
            if (!tiltEnabled) {
                activeTouchId = touch.identifier;
                if (x < 0.3) {
                    keys['touchLeft'] = true;
                    keys['touchRight'] = false;
                } else if (x > 0.7) {
                    keys['touchRight'] = true;
                    keys['touchLeft'] = false;
                }
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!tiltEnabled && activeTouchId !== null) {
                for (const touch of e.changedTouches) {
                    if (touch.identifier === activeTouchId) {
                        const rect = canvas.getBoundingClientRect();
                        const x = (touch.clientX - rect.left) / rect.width;
                        if (x < 0.3) {
                            keys['touchLeft'] = true;
                            keys['touchRight'] = false;
                        } else if (x > 0.7) {
                            keys['touchRight'] = true;
                            keys['touchLeft'] = false;
                        } else {
                            keys['touchLeft'] = false;
                            keys['touchRight'] = false;
                        }
                    }
                }
            }
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            for (const touch of e.changedTouches) {
                if (touch.identifier === activeTouchId) {
                    activeTouchId = null;
                    keys['touchLeft'] = false;
                    keys['touchRight'] = false;
                }
            }
        });

        // Tilt controls for movement (uses device orientation)
        let tiltEnabled = false;
        const tiltDeadzone = 5; // degrees of deadzone before movement starts
        const tiltMaxAngle = 20; // degrees at which full speed is reached

        function handleOrientation(e) {
            if (!gameRunning || demoMode) return;

            // gamma is left-right tilt (-90 to 90)
            let tilt = e.gamma || 0;

            // Handle device held in portrait mode
            if (tilt > tiltDeadzone) {
                // Tilted right
                keys['tiltRight'] = true;
                keys['tiltLeft'] = false;
                duck.tiltAmount = Math.min((tilt - tiltDeadzone) / (tiltMaxAngle - tiltDeadzone), 1);
                duck.tiltAmount = Math.max(duck.tiltAmount, 0.4); // minimum speed when tilting
            } else if (tilt < -tiltDeadzone) {
                // Tilted left
                keys['tiltLeft'] = true;
                keys['tiltRight'] = false;
                duck.tiltAmount = Math.min((-tilt - tiltDeadzone) / (tiltMaxAngle - tiltDeadzone), 1);
                duck.tiltAmount = Math.max(duck.tiltAmount, 0.4); // minimum speed when tilting
            } else {
                keys['tiltLeft'] = false;
                keys['tiltRight'] = false;
                duck.tiltAmount = 0;
            }
        }

        // Request permission for device orientation (required on iOS 13+)
        function requestMotionPermission() {
            if (typeof DeviceOrientationEvent !== 'undefined' &&
                typeof DeviceOrientationEvent.requestPermission === 'function') {
                // iOS 13+ requires permission request
                DeviceOrientationEvent.requestPermission()
                    .then(response => {
                        if (response === 'granted') {
                            window.addEventListener('deviceorientation', handleOrientation);
                            tiltEnabled = true;
                        }
                    })
                    .catch(err => console.log('Motion permission error:', err));
            } else if (window.DeviceOrientationEvent) {
                // Non-iOS or older iOS - just add listener
                window.addEventListener('deviceorientation', handleOrientation);
                tiltEnabled = true;
            }
        }

        // Request permission on first user interaction (required for iOS)
        function initMotionOnce() {
            requestMotionPermission();
            document.removeEventListener('touchstart', initMotionOnce);
            document.removeEventListener('click', initMotionOnce);
        }
        document.addEventListener('touchstart', initMotionOnce, { once: true });
        document.addEventListener('click', initMotionOnce, { once: true });

        // Handle window resize
        window.addEventListener('resize', () => {
            resizeCanvas();
            generateLevel(level); // Regenerate level for new dimensions
        });

        // Initialize
        resizeCanvas();
        generateLevel(1);
        gameLoop();
    </script>
</body>
</html>
