<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Duck Song - Got Any Grapes?</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            height: 100dvh; /* dynamic viewport height for mobile */
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: 'Comic Sans MS', cursive, sans-serif;
            overflow: hidden;
            width: 100%;
        }
        #gameContainer {
            position: relative; /* allow absolute children to center over the canvas */
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            width: 100%;
            height: 100%;
            max-width: 900px;
            overflow: hidden;
        }
        /* Make canvas fit within viewport */
        #gameCanvas {
            border: 4px solid #8B4513;
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.3);
            display: block;
            touch-action: none; /* prevent browser gestures interfering with game touches */
        }
        /* Full screen mode for mobile - detect touch devices */
        @media (pointer: coarse), (max-width: 600px) {
            html, body {
                height: 100%;
                height: -webkit-fill-available;
            }
            #gameContainer {
                padding: 0;
                max-width: none;
                height: 100%;
                height: -webkit-fill-available;
            }
            #gameCanvas {
                border: none;
                border-radius: 0;
                max-width: none;
                max-height: none;
            }
            #title, #instructions, #fullscreenBtn {
                display: none;
            }
            #ui {
                position: absolute;
                top: env(safe-area-inset-top, 10px);
                left: 50%;
                transform: translateX(-50%);
                z-index: 100;
                margin: 0;
                padding: 8px 16px;
                font-size: 14px;
                background: rgba(0,0,0,0.6);
            }
        }
        #ui {
            display: flex;
            gap: 30px;
            margin-bottom: 10px;
            color: white;
            font-size: 18px;
            background: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border-radius: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        #instructions {
            color: #aaa;
            margin-top: 10px;
            text-align: center;
            font-size: 14px;
        }
        #title {
            color: #FFD700;
            font-size: 28px;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            text-align: center;
        }
        #musicBtn, #fullscreenBtn {
            background: #FFD700;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-family: inherit;
            font-size: 14px;
            transition: transform 0.1s;
        }
        #musicBtn:hover, #fullscreenBtn:hover {
            transform: scale(1.05);
        }
        #fullscreenBtn {
            background: #4CAF50;
            color: white;
        }
        /* Fullscreen styles */
        #gameContainer:fullscreen, #gameContainer:-webkit-full-screen {
            max-width: none;
            padding: 0;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        }
        #gameContainer:fullscreen #gameCanvas, #gameContainer:-webkit-full-screen #gameCanvas {
            max-width: 100vw;
            max-height: calc(100vh - 60px);
            border: none;
            border-radius: 0;
        }
        #gameContainer:fullscreen #title, #gameContainer:-webkit-full-screen #title,
        #gameContainer:fullscreen #instructions, #gameContainer:-webkit-full-screen #instructions {
            display: none;
        }
        #gameContainer:fullscreen #ui, #gameContainer:-webkit-full-screen #ui {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            margin: 0;
        }
        #startScreen, #winScreen, #levelSelector {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.85);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            width: min(90%, 600px);
            box-shadow: 0 8px 30px rgba(0,0,0,0.5);
        }
        .screen-btn {
            background: #FFD700;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-family: inherit;
            font-size: 20px;
            margin-top: 20px;
            transition: transform 0.1s, background 0.2s;
        }
        .screen-btn:hover {
            transform: scale(1.1);
            background: #FFA500;
        }
        .level-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: 2px solid #FFD700;
            padding: 15px;
            border-radius: 10px;
            cursor: pointer;
            font-family: inherit;
            font-size: 20px;
            font-weight: bold;
            color: white;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        .level-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(255, 215, 0, 0.5);
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
        }
        .hidden { display: none !important; }

        /* Mobile action buttons for helicopter and shooting */
        #mobileControls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: none;
            flex-direction: column;
            gap: 10px;
            z-index: 200;
        }
        .mobile-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid rgba(255,255,255,0.8);
            background: rgba(0,0,0,0.6);
            color: white;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            transition: transform 0.1s, background 0.2s;
            font-weight: bold;
            touch-action: manipulation;
        }
        .mobile-btn:active {
            transform: scale(0.9);
            background: rgba(255,215,0,0.8);
        }
        .mobile-btn.disabled {
            opacity: 0.3;
            pointer-events: none;
        }
        @media (pointer: coarse), (max-width: 600px) {
            #mobileControls {
                display: flex;
            }
        }

        /* Responsive tweaks */
        @media (max-width: 600px) {
            #title { font-size: 20px; }
            #ui { font-size: 14px; gap: 10px; padding: 8px 12px; }
            #instructions { font-size: 12px; }
            .screen-btn { font-size: 18px; padding: 12px 22px; }
            #startScreen, #winScreen, #levelSelector { padding: 20px; }
            #musicBtn { font-size: 12px; padding: 6px 12px; }
            #startScreen h1, #winScreen h1 { font-size: 28px !important; }
            #startScreen p, #winScreen p { font-size: 14px !important; }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="title">The Duck Song Game - Got Any Grapes?</div>
        <div id="ui">
            <span>Grapes: <span id="grapeCount">0</span></span>
            <span>Level: <span id="levelNum">1</span></span>
            <button id="musicBtn" onclick="toggleMusic()">Music: OFF</button>
            <button id="fullscreenBtn" onclick="toggleFullscreen()">Fullscreen</button>
        </div>
        <canvas id="gameCanvas" width="800" height="500"></canvas>
        <div id="instructions">
            WASD/Arrows: move | SPACE: jump | X/F: shoot (Lv5+) | E: helicopter (Lv6+) / doom suit (Lv10+)
        </div>

        <!-- Mobile action buttons -->
        <div id="mobileControls">
            <div id="helicopterBtn" class="mobile-btn disabled" title="Helicopter (Level 6+)" aria-label="Helicopter control" role="button">üöÅ</div>
            <div id="shootBtn" class="mobile-btn disabled" title="Shoot (Level 5+)" aria-label="Shoot control" role="button">üí•</div>
        </div>

        <div id="startScreen">
            <h1 style="color: #FFD700; font-size: 36px;">The Duck Song Game</h1>
            <p style="margin: 20px 0; font-size: 18px;">Help the duck collect grapes!<br>Collect all grapes & reach the end of each level.</p>
            <p style="color: #aaa;">Desktop: Arrow Keys / WASD + Space<br>Mobile: Tilt to move, Tap to jump!<br><span style="font-size: 12px;">(Or tap left/right sides to move)</span></p>
            <div style="margin: 15px 0; width: 100%;">
                <label style="color: #aaa; font-size: 14px;">Tilt Sensitivity: <span id="sensitivityValue">50</span>%</label>
                <input type="range" id="tiltSensitivity" min="10" max="100" value="50"
                    style="width: 80%; margin-top: 8px; cursor: pointer;">
            </div>
            <button class="screen-btn" onclick="showLevelSelector()">Start Game!</button>
        </div>

        <div id="levelSelector" class="hidden">
            <h1 style="color: #FFD700; font-size: 36px;">Level Select</h1>
            <p style="margin: 20px 0; font-size: 16px; color: #aaa;">Choose your starting level</p>
            <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; max-width: 600px; margin: 20px auto;">
                <button class="level-btn" onclick="startGameFromLevel(1)">1</button>
                <button class="level-btn" onclick="startGameFromLevel(2)">2</button>
                <button class="level-btn" onclick="startGameFromLevel(3)">3</button>
                <button class="level-btn" onclick="startGameFromLevel(4)">4</button>
                <button class="level-btn" onclick="startGameFromLevel(5)">5</button>
                <button class="level-btn" onclick="startGameFromLevel(6)">6</button>
                <button class="level-btn" onclick="startGameFromLevel(7)">7</button>
                <button class="level-btn" onclick="startGameFromLevel(8)">8</button>
                <button class="level-btn" onclick="startGameFromLevel(9)">9</button>
                <button class="level-btn" onclick="startGameFromLevel(10)">10</button>
                <button class="level-btn" onclick="startGameFromLevel(11)">11</button>
                <button class="level-btn" onclick="startGameFromLevel(12)">12</button>
                <button class="level-btn" onclick="startGameFromLevel(13)">13</button>
                <button class="level-btn" onclick="startGameFromLevel(14)">14</button>
                <button class="level-btn" onclick="startGameFromLevel(15)">15</button>
            </div>
            <button class="screen-btn" onclick="hideLevelSelector()" style="margin-top: 15px;">Back</button>
        </div>

        <div id="winScreen" class="hidden">
            <h1 style="color: #FFD700; font-size: 36px;">You Win!</h1>
            <p style="margin: 20px 0; font-size: 18px;">The duck finally got all the grapes!</p>
            <p style="color: #8B008B;">Total grapes collected: <span id="totalGrapes">0</span></p>
            <button class="screen-btn" onclick="startGame()">Play Again</button>
        </div>
    </div>

    <audio id="bgMusic" loop>
        <source src="duck_song.mp3" type="audio/mpeg">
    </audio>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const grapeCountEl = document.getElementById('grapeCount');
        const levelNumEl = document.getElementById('levelNum');
        const musicBtn = document.getElementById('musicBtn');
        const bgMusic = document.getElementById('bgMusic');
        const startScreen = document.getElementById('startScreen');
        const levelSelector = document.getElementById('levelSelector');
        const winScreen = document.getElementById('winScreen');

        // Reference dimensions (original design)
        const REF_WIDTH = 800;
        const REF_HEIGHT = 500;

        // Scale factors - updated on resize
        let scaleX = 1;
        let scaleY = 1;
        let scale = 1; // uniform scale for sprites

        // Resize canvas to fill screen
        function resizeCanvas() {
            // Use visualViewport for accurate sizing on iOS Safari
            const vv = window.visualViewport;
            const isMobile = window.matchMedia('(pointer: coarse), (max-width: 600px)').matches;
            const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement);

            let width, height;
            if (isMobile || isFullscreen) {
                // On mobile or fullscreen, use full viewport
                width = Math.floor(vv ? vv.width : window.innerWidth);
                height = Math.floor(vv ? vv.height : window.innerHeight);
            } else {
                // On desktop, fit within container with some room for UI
                const container = document.getElementById('gameContainer');
                width = Math.min(container.clientWidth - 20, 880);
                height = Math.floor(window.innerHeight - 150);
            }

            // Set canvas internal resolution
            canvas.width = width;
            canvas.height = height;

            // Set CSS display size to match exactly (prevents distortion)
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';

            scaleX = canvas.width / REF_WIDTH;
            scaleY = canvas.height / REF_HEIGHT;
            
            // Mobile scale adjustment factor to prevent oversized elements on tall screens
            const MOBILE_SCALE_FACTOR = 0.85;
            
            // On mobile, use height-based scaling to ensure elements are large enough
            // On desktop, use minimum of both to maintain aspect ratio
            if (isMobile) {
                // Use max of width scale or adjusted height scale to ensure visibility
                // while preventing elements from becoming too large on very tall screens
                scale = Math.max(scaleX, scaleY * MOBILE_SCALE_FACTOR);
            } else {
                scale = Math.min(scaleX, scaleY); // uniform scale for sprites
            }

            // Update duck size based on scale
            duck.width = 50 * scale;
            duck.height = 60 * scale;
            duck.speed = 5 * scaleX;
            duck.jumpForce = -14 * scaleY;
        }

        // Helper to convert reference coords to screen coords
        function sx(x) { return x * scaleX; }
        function sy(y) { return y * scaleY; }

        // Game state
        let gameRunning = false;
        let demoMode = true;
        let keys = {};
        let grapes = [];
        let platforms = [];
        let level = 1;
        let grapesCollected = 0;
        let totalGrapesCollected = 0;
        let totalGrapes = 0;
        let gameMessage = '';
        let messageTimer = 0;
        let musicPlaying = false;
        let levelCompleting = false;  // Prevent multiple level completions

        // Particle system for visual effects
        let particles = [];

        // Demo AI state
        let targetGrape = null;
        let demoJumpCooldown = 0;

        const MAX_LEVEL = 15;

        // Combat system - lemon seed gun (available from level 5)
        let seeds = [];  // Projectiles
        let enemies = [];  // Enemy objects
        let lastShotTime = 0;
        const SHOT_COOLDOWN = 250;  // ms between shots

        // Helicopter system (available from level 6)
        let helicopter = {
            active: false,
            available: false,
            x: 0,
            y: 0,
            fuel: 100,
            maxFuel: 100
        };

        // Lava lakes (hell levels 10+)
        let lavaLakes = [];

        // Doomslayer suit (replaces helicopter for levels 10+)
        let doomslayerSuit = {
            active: false,
            available: false,
            pickupX: 0,
            pickupY: 0,
            pickedUp: false,
            invincible: false
        };

        // Floating embers for hell theme
        let hellEmbers = [];

        // ========================================
        // WORLD & CAMERA SYSTEM
        // ========================================
        let worldWidth = 2000;  // World extends beyond viewport
        const camera = { x: 0, y: 0 };
        let sceneryElements = [];  // Background objects

        // Scene definitions for each level theme
        const SCENES = {
            countryside: {
                skyColors: ['#87CEEB', '#B0E0E6'],
                hillColor: '#3CB371',
                groundColor: '#32CD32',
                groundAccent: '#228B22'
            },
            suburbs: {
                skyColors: ['#87CEEB', '#A8C8E8'],
                hillColor: '#5D8C5D',
                groundColor: '#7CBA7C',
                groundAccent: '#5A9A5A'
            },
            downtown: {
                skyColors: ['#6B8CAE', '#8899AA'],
                hillColor: '#4A4A4A',
                groundColor: '#606060',
                groundAccent: '#505050'
            },
            hell: {
                skyColors: ['#1A0000', '#4A0000'],
                hillColor: '#2A0A0A',
                groundColor: '#1C1C1C',
                groundAccent: '#3A1A1A'
            }
        };

        // Get scene for current level
        function getSceneForLevel(levelNum) {
            const levelThemes = {
                1: 'countryside',
                2: 'countryside',
                3: 'suburbs',
                4: 'suburbs',
                5: 'downtown',
                6: 'downtown',
                7: 'countryside',
                8: 'suburbs',
                9: 'downtown',
                10: 'hell',
                11: 'hell',
                12: 'hell',
                13: 'hell',
                14: 'hell',
                15: 'hell'
            };
            const theme = levelThemes[levelNum] || 'countryside';
            return { ...SCENES[theme], name: theme };
        }

        // Convert world coords to screen coords
        function worldToScreen(wx, wy) {
            return { x: wx - camera.x, y: wy };
        }

        // Update camera to follow duck
        function updateCamera() {
            // Keep duck at 30% from left edge
            const targetX = duck.x - canvas.width * 0.3;
            camera.x = Math.max(0, Math.min(targetX, worldWidth - canvas.width));
        }

        // Duck player (positions will be in screen coords)
        const duck = {
            x: 100,
            y: 300,
            width: 50,
            height: 60,
            vx: 0,
            vy: 0,
            speed: 5,
            jumpForce: -14,
            onGround: false,
            facing: 1,
            walkFrame: 0,
            walkTimer: 0,
            tiltAmount: 0
        };

        // Physics (scaled on resize)
        let gravity = 0.6;
        const friction = 0.85;

        // Remove unused lemonadeStand object - position is now calculated dynamically

        function toggleMusic() {
            if (musicPlaying) {
                bgMusic.pause();
                musicBtn.textContent = 'Music: OFF';
                musicPlaying = false;
            } else {
                bgMusic.play().catch(e => console.log('Audio play failed:', e));
                musicBtn.textContent = 'Music: ON';
                musicPlaying = true;
            }
        }

        function toggleFullscreen() {
            const container = document.getElementById('gameContainer');
            const btn = document.getElementById('fullscreenBtn');

            if (!document.fullscreenElement && !document.webkitFullscreenElement) {
                // Enter fullscreen
                if (container.requestFullscreen) {
                    container.requestFullscreen();
                } else if (container.webkitRequestFullscreen) {
                    container.webkitRequestFullscreen();
                }
                btn.textContent = 'Exit Fullscreen';
            } else {
                // Exit fullscreen
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                }
                btn.textContent = 'Fullscreen';
            }
        }

        // Update button text and resize canvas when fullscreen changes
        function onFullscreenChange() {
            const btn = document.getElementById('fullscreenBtn');
            if (document.fullscreenElement || document.webkitFullscreenElement) {
                btn.textContent = 'Exit Fullscreen';
            } else {
                btn.textContent = 'Fullscreen';
            }
            // Resize canvas after a short delay to let the browser adjust
            setTimeout(() => {
                resizeCanvas();
                generateLevel(level);
            }, 100);
        }
        document.addEventListener('fullscreenchange', onFullscreenChange);
        document.addEventListener('webkitfullscreenchange', onFullscreenChange);

        // ========================================
        // NEW GRAPHICS FUNCTIONS
        // ========================================

        // Draw a tree (countryside)
        function drawTree(x, y, size) {
            const s = size * scale;
            
            // Trunk shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.fillRect(x - 6 * s, y + 2 * s, 14 * s, 48 * s);
            
            // Trunk with gradient
            const trunkGradient = ctx.createLinearGradient(x - 7 * s, y, x + 7 * s, y);
            trunkGradient.addColorStop(0, '#6F3710');
            trunkGradient.addColorStop(0.5, '#8B4513');
            trunkGradient.addColorStop(1, '#6F3710');
            ctx.fillStyle = trunkGradient;
            ctx.fillRect(x - 7 * s, y, 14 * s, 50 * s);
            
            // Trunk texture
            ctx.strokeStyle = 'rgba(60, 30, 10, 0.3)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.moveTo(x - 5 * s, y + 15 * s + i * 12 * s);
                ctx.lineTo(x + 5 * s, y + 15 * s + i * 12 * s);
                ctx.stroke();
            }
            
            // Foliage with gradient (back layer)
            const foliageGradient1 = ctx.createRadialGradient(x, y - 10 * s, 0, x, y - 10 * s, 35 * s);
            foliageGradient1.addColorStop(0, '#3CB371');
            foliageGradient1.addColorStop(0.7, '#228B22');
            foliageGradient1.addColorStop(1, '#1B5E20');
            ctx.fillStyle = foliageGradient1;
            ctx.beginPath();
            ctx.arc(x, y - 10 * s, 35 * s, 0, Math.PI * 2);
            ctx.fill();
            
            // Side foliage with gradients
            const foliageGradient2 = ctx.createRadialGradient(x - 20 * s, y + 5 * s, 0, x - 20 * s, y + 5 * s, 25 * s);
            foliageGradient2.addColorStop(0, '#3CB371');
            foliageGradient2.addColorStop(0.7, '#228B22');
            foliageGradient2.addColorStop(1, '#1B5E20');
            ctx.fillStyle = foliageGradient2;
            ctx.beginPath();
            ctx.arc(x - 20 * s, y + 5 * s, 25 * s, 0, Math.PI * 2);
            ctx.fill();
            
            const foliageGradient3 = ctx.createRadialGradient(x + 20 * s, y + 5 * s, 0, x + 20 * s, y + 5 * s, 25 * s);
            foliageGradient3.addColorStop(0, '#3CB371');
            foliageGradient3.addColorStop(0.7, '#228B22');
            foliageGradient3.addColorStop(1, '#1B5E20');
            ctx.fillStyle = foliageGradient3;
            ctx.beginPath();
            ctx.arc(x + 20 * s, y + 5 * s, 25 * s, 0, Math.PI * 2);
            ctx.fill();
            
            // Foliage highlights
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.beginPath();
            ctx.arc(x - 8 * s, y - 15 * s, 12 * s, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw a shrub (small bush)
        function drawShrub(x, y, size) {
            const s = (size || 1) * scale;
            
            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.beginPath();
            ctx.arc(x, y, 16 * s, 0, Math.PI * 2);
            ctx.fill();
            
            // Main bush with gradient
            const bushGradient = ctx.createRadialGradient(x - 3 * s, y - 10 * s, 0, x, y - 8 * s, 15 * s);
            bushGradient.addColorStop(0, '#3CB371');
            bushGradient.addColorStop(0.6, '#2E8B57');
            bushGradient.addColorStop(1, '#1B5E20');
            ctx.fillStyle = bushGradient;
            ctx.beginPath();
            ctx.arc(x, y - 8 * s, 15 * s, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(x - 10 * s, y - 3 * s, 10 * s, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(x + 10 * s, y - 3 * s, 10 * s, 0, Math.PI * 2);
            ctx.fill();
            
            // Highlight
            ctx.fillStyle = 'rgba(255, 255, 255, 0.25)';
            ctx.beginPath();
            ctx.arc(x - 3 * s, y - 10 * s, 6 * s, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw a flower
        function drawFlower(x, y, color) {
            const s = scale;
            
            // Stem with gradient
            const stemGradient = ctx.createLinearGradient(x, y, x, y - 15 * s);
            stemGradient.addColorStop(0, '#1B5E20');
            stemGradient.addColorStop(1, '#4CAF50');
            ctx.strokeStyle = stemGradient;
            ctx.lineWidth = 2.5 * s;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x, y - 15 * s);
            ctx.stroke();
            
            // Leaf
            ctx.fillStyle = '#4CAF50';
            ctx.beginPath();
            ctx.ellipse(x - 4 * s, y - 8 * s, 3 * s, 5 * s, -0.5, 0, Math.PI * 2);
            ctx.fill();
            
            // Petals with gradient
            const petalColor = color || '#FF69B4';
            for (let i = 0; i < 5; i++) {
                const angle = (i / 5) * Math.PI * 2;
                const px = x + Math.cos(angle) * 5 * s;
                const py = y - 15 * s + Math.sin(angle) * 5 * s;
                
                // Convert color to rgba for proper gradient (safe for all color formats)
                const petalGradient = ctx.createRadialGradient(px - s, py - s, 0, px, py, 4 * s);
                petalGradient.addColorStop(0, petalColor);
                // Use semi-transparent version for gradient end
                if (petalColor.startsWith('#') && petalColor.length === 7) {
                    petalGradient.addColorStop(1, petalColor + 'CC');
                } else {
                    // Fallback for named colors or other formats
                    petalGradient.addColorStop(1, 'rgba(255, 105, 180, 0.8)');
                }
                ctx.fillStyle = petalGradient;
                ctx.beginPath();
                ctx.arc(px, py, 4 * s, 0, Math.PI * 2);
                ctx.fill();
                
                // Petal highlight
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.beginPath();
                ctx.arc(px - s * 0.8, py - s * 0.8, 1.5 * s, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Center with gradient
            const centerGradient = ctx.createRadialGradient(x - s, y - 15 * s - s, 0, x, y - 15 * s, 3 * s);
            centerGradient.addColorStop(0, '#FFD700');
            centerGradient.addColorStop(1, '#FFA500');
            ctx.fillStyle = centerGradient;
            ctx.beginPath();
            ctx.arc(x, y - 15 * s, 3 * s, 0, Math.PI * 2);
            ctx.fill();
            
            // Center details (stamens)
            ctx.fillStyle = '#FF8C00';
            for (let i = 0; i < 3; i++) {
                const angle = (i / 3) * Math.PI * 2;
                ctx.beginPath();
                ctx.arc(x + Math.cos(angle) * s, y - 15 * s + Math.sin(angle) * s, 0.5 * s, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Draw a picket fence section
        function drawFence(x, y, width) {
            const s = scale;
            const postSpacing = 20 * s;
            ctx.fillStyle = '#F5F5DC';
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 1;
            // Horizontal rails
            ctx.fillRect(x, y - 25 * s, width, 5 * s);
            ctx.fillRect(x, y - 10 * s, width, 5 * s);
            // Pickets
            for (let px = x; px < x + width; px += postSpacing) {
                ctx.fillStyle = '#F5F5DC';
                ctx.beginPath();
                ctx.moveTo(px, y);
                ctx.lineTo(px, y - 35 * s);
                ctx.lineTo(px + 5 * s, y - 40 * s);
                ctx.lineTo(px + 10 * s, y - 35 * s);
                ctx.lineTo(px + 10 * s, y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
        }

        // Draw a suburban house
        function drawHouse(x, y, style) {
            const s = scale;
            const width = (80 + style * 20) * s;
            const height = (60 + style * 10) * s;
            const colors = ['#D2691E', '#8B0000', '#4169E1', '#2F4F4F'];
            const roofColors = ['#8B4513', '#A52A2A', '#696969', '#2F2F2F'];

            // House body
            ctx.fillStyle = colors[style % colors.length];
            ctx.fillRect(x - width/2, y - height, width, height);
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.strokeRect(x - width/2, y - height, width, height);

            // Roof
            ctx.fillStyle = roofColors[style % roofColors.length];
            ctx.beginPath();
            ctx.moveTo(x - width/2 - 10 * s, y - height);
            ctx.lineTo(x, y - height - 40 * s);
            ctx.lineTo(x + width/2 + 10 * s, y - height);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Door
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(x - 10 * s, y - 40 * s, 20 * s, 40 * s);
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(x + 5 * s, y - 20 * s, 2 * s, 0, Math.PI * 2);
            ctx.fill();

            // Windows
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(x - width/2 + 10 * s, y - height + 15 * s, 15 * s, 15 * s);
            ctx.fillRect(x + width/2 - 25 * s, y - height + 15 * s, 15 * s, 15 * s);
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 1;
            ctx.strokeRect(x - width/2 + 10 * s, y - height + 15 * s, 15 * s, 15 * s);
            ctx.strokeRect(x + width/2 - 25 * s, y - height + 15 * s, 15 * s, 15 * s);
        }

        // Draw a mailbox
        function drawMailbox(x, y) {
            const s = scale;
            // Post
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(x - 3 * s, y - 35 * s, 6 * s, 35 * s);
            // Box
            ctx.fillStyle = '#4169E1';
            ctx.fillRect(x - 12 * s, y - 50 * s, 24 * s, 18 * s);
            // Flag
            ctx.fillStyle = '#FF0000';
            ctx.fillRect(x + 12 * s, y - 50 * s, 3 * s, 12 * s);
        }

        // Draw a city building
        function drawBuilding(x, y, width, height, style) {
            const s = scale;
            const w = width * s;
            const h = height * s;
            const colors = ['#708090', '#5F5F5F', '#4A4A4A', '#363636', '#2F4F4F'];

            // Building body
            ctx.fillStyle = colors[style % colors.length];
            ctx.fillRect(x - w/2, y - h, w, h);
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.strokeRect(x - w/2, y - h, w, h);

            // Windows grid
            const windowSize = 12 * s;
            const windowSpacing = 20 * s;
            const margin = 15 * s;

            for (let wy = y - h + margin; wy < y - margin; wy += windowSpacing) {
                for (let wx = x - w/2 + margin; wx < x + w/2 - margin; wx += windowSpacing) {
                    // Randomly lit windows
                    const lit = Math.sin(wx * 0.1 + wy * 0.1 + style) > 0;
                    ctx.fillStyle = lit ? '#FFFF99' : '#333';
                    ctx.fillRect(wx, wy, windowSize, windowSize);
                }
            }

            // Rooftop details
            if (style % 2 === 0) {
                // Water tower
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(x - 8 * s, y - h - 20 * s, 16 * s, 20 * s);
            } else {
                // Antenna
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x, y - h);
                ctx.lineTo(x, y - h - 30 * s);
                ctx.stroke();
            }
        }

        // Draw a lamp post
        function drawLampPost(x, y) {
            const s = scale;
            // Pole
            ctx.fillStyle = '#2F2F2F';
            ctx.fillRect(x - 3 * s, y - 80 * s, 6 * s, 80 * s);
            // Lamp head
            ctx.fillStyle = '#333';
            ctx.fillRect(x - 12 * s, y - 85 * s, 24 * s, 8 * s);
            // Light glow
            const gradient = ctx.createRadialGradient(x, y - 80 * s, 0, x, y - 80 * s, 40 * s);
            gradient.addColorStop(0, 'rgba(255, 255, 200, 0.3)');
            gradient.addColorStop(1, 'rgba(255, 255, 200, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y - 70 * s, 40 * s, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw a fire hydrant
        function drawFireHydrant(x, y) {
            const s = scale;
            ctx.fillStyle = '#FF0000';
            // Body
            ctx.fillRect(x - 6 * s, y - 25 * s, 12 * s, 25 * s);
            // Top
            ctx.beginPath();
            ctx.arc(x, y - 25 * s, 8 * s, Math.PI, 0);
            ctx.fill();
            // Side nozzles
            ctx.fillRect(x - 12 * s, y - 18 * s, 6 * s, 6 * s);
            ctx.fillRect(x + 6 * s, y - 18 * s, 6 * s, 6 * s);
        }

        // Draw a bench
        function drawBench(x, y) {
            const s = scale;
            ctx.fillStyle = '#8B4513';
            // Seat
            ctx.fillRect(x - 25 * s, y - 18 * s, 50 * s, 6 * s);
            // Back
            ctx.fillRect(x - 25 * s, y - 35 * s, 50 * s, 5 * s);
            // Legs
            ctx.fillRect(x - 22 * s, y - 18 * s, 4 * s, 18 * s);
            ctx.fillRect(x + 18 * s, y - 18 * s, 4 * s, 18 * s);
            // Back supports
            ctx.fillRect(x - 22 * s, y - 35 * s, 4 * s, 17 * s);
            ctx.fillRect(x + 18 * s, y - 35 * s, 4 * s, 17 * s);
        }

        // Draw a street sign
        function drawStreetSign(x, y, text) {
            const s = scale;
            // Pole
            ctx.fillStyle = '#4A4A4A';
            ctx.fillRect(x - 2 * s, y - 60 * s, 4 * s, 60 * s);
            // Sign
            ctx.fillStyle = '#228B22';
            ctx.fillRect(x - 30 * s, y - 70 * s, 60 * s, 15 * s);
            ctx.fillStyle = '#FFF';
            ctx.font = `bold ${8 * s}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText(text || 'MAIN ST', x, y - 60 * s);
        }

        // Draw finish banner/flag at end of level
        function drawFinishBanner(x, y) {
            const s = scale;
            // Pole
            ctx.fillStyle = '#4A4A4A';
            ctx.fillRect(x - 3 * s, y - 120 * s, 6 * s, 120 * s);
            // Banner
            ctx.fillStyle = '#FF0000';
            ctx.beginPath();
            ctx.moveTo(x + 3 * s, y - 120 * s);
            ctx.lineTo(x + 60 * s, y - 100 * s);
            ctx.lineTo(x + 3 * s, y - 80 * s);
            ctx.closePath();
            ctx.fill();
            // Checkered pattern
            ctx.fillStyle = '#FFF';
            ctx.fillRect(x + 10 * s, y - 115 * s, 15 * s, 10 * s);
            ctx.fillRect(x + 25 * s, y - 105 * s, 15 * s, 10 * s);
            ctx.fillRect(x + 10 * s, y - 95 * s, 15 * s, 10 * s);
            // Text
            ctx.fillStyle = '#FFD700';
            ctx.font = `bold ${10 * s}px Comic Sans MS`;
            ctx.textAlign = 'center';
            ctx.fillText('FINISH', x + 25 * s, y - 70 * s);
        }

        // ========================================
        // HELL SCENERY DRAWING FUNCTIONS
        // ========================================

        // "Welcome to Hell" sign
        function drawHellWelcomeSign(x, y) {
            const s = scale;
            // Two charred posts
            ctx.fillStyle = '#2A1A0A';
            ctx.fillRect(x - 50 * s, y - 100 * s, 8 * s, 100 * s);
            ctx.fillRect(x + 42 * s, y - 100 * s, 8 * s, 100 * s);
            // Sign board - dark wood with red border
            ctx.fillStyle = '#1A0A0A';
            ctx.fillRect(x - 55 * s, y - 110 * s, 110 * s, 40 * s);
            ctx.strokeStyle = '#8B0000';
            ctx.lineWidth = 3 * s;
            ctx.strokeRect(x - 55 * s, y - 110 * s, 110 * s, 40 * s);
            // Glowing text
            ctx.shadowColor = '#FF4400';
            ctx.shadowBlur = 15 * s;
            ctx.fillStyle = '#FF2200';
            ctx.font = `bold ${14 * s}px Comic Sans MS`;
            ctx.textAlign = 'center';
            ctx.fillText('WELCOME TO', x, y - 95 * s);
            ctx.fillStyle = '#FF0000';
            ctx.font = `bold ${18 * s}px Comic Sans MS`;
            ctx.fillText('HELL', x, y - 78 * s);
            ctx.shadowBlur = 0;
            // Flames on top of posts
            for (let post of [-46, 46]) {
                const px = x + post * s;
                const flicker = Math.sin(Date.now() * 0.01 + post) * 3 * s;
                ctx.fillStyle = '#FF6600';
                ctx.beginPath();
                ctx.moveTo(px - 6 * s, y - 100 * s);
                ctx.quadraticCurveTo(px + flicker, y - 120 * s - flicker, px + 6 * s, y - 100 * s);
                ctx.fill();
                ctx.fillStyle = '#FFAA00';
                ctx.beginPath();
                ctx.moveTo(px - 3 * s, y - 100 * s);
                ctx.quadraticCurveTo(px - flicker * 0.5, y - 112 * s, px + 3 * s, y - 100 * s);
                ctx.fill();
            }
        }

        // Stalagmite
        function drawStalagmite(x, y, size) {
            const s = (size || 1) * scale;
            const h = 40 + size * 20;
            ctx.fillStyle = '#3A2A2A';
            ctx.beginPath();
            ctx.moveTo(x - 12 * s, y);
            ctx.lineTo(x - 2 * s, y - h * s);
            ctx.lineTo(x + 3 * s, y - h * s * 0.95);
            ctx.lineTo(x + 12 * s, y);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#4A3A3A';
            ctx.lineWidth = 1;
            ctx.stroke();
            // Highlight edge
            ctx.strokeStyle = 'rgba(255, 100, 50, 0.2)';
            ctx.beginPath();
            ctx.moveTo(x - 2 * s, y - h * s);
            ctx.lineTo(x + 12 * s, y);
            ctx.stroke();
        }

        // Dead tree (charred, no leaves)
        function drawDeadTree(x, y, size) {
            const s = (size || 1) * scale;
            // Trunk
            ctx.fillStyle = '#1A1A1A';
            ctx.fillRect(x - 5 * s, y - 50 * s, 10 * s, 50 * s);
            // Branches (bare, twisted)
            ctx.strokeStyle = '#2A1A1A';
            ctx.lineWidth = 3 * s;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(x, y - 40 * s);
            ctx.lineTo(x - 25 * s, y - 65 * s);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x, y - 35 * s);
            ctx.lineTo(x + 20 * s, y - 60 * s);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x - 25 * s, y - 65 * s);
            ctx.lineTo(x - 35 * s, y - 75 * s);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x + 20 * s, y - 60 * s);
            ctx.lineTo(x + 30 * s, y - 70 * s);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x, y - 50 * s);
            ctx.lineTo(x + 5 * s, y - 75 * s);
            ctx.stroke();
            // Subtle ember glow at base
            const baseGlow = ctx.createRadialGradient(x, y, 0, x, y, 15 * s);
            baseGlow.addColorStop(0, 'rgba(255, 80, 0, 0.15)');
            baseGlow.addColorStop(1, 'rgba(255, 80, 0, 0)');
            ctx.fillStyle = baseGlow;
            ctx.beginPath();
            ctx.arc(x, y, 15 * s, 0, Math.PI * 2);
            ctx.fill();
        }

        // Skull pile
        function drawSkullPile(x, y) {
            const s = scale;
            function drawSkull(sx, sy, sz) {
                // Cranium
                ctx.fillStyle = '#D4C8A0';
                ctx.beginPath();
                ctx.arc(sx, sy - 5 * sz * s, 8 * sz * s, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#8B7D5E';
                ctx.lineWidth = 1;
                ctx.stroke();
                // Eye sockets
                ctx.fillStyle = '#1A1A1A';
                ctx.beginPath();
                ctx.arc(sx - 3 * sz * s, sy - 6 * sz * s, 2 * sz * s, 0, Math.PI * 2);
                ctx.arc(sx + 3 * sz * s, sy - 6 * sz * s, 2 * sz * s, 0, Math.PI * 2);
                ctx.fill();
                // Jaw
                ctx.fillStyle = '#C4B890';
                ctx.beginPath();
                ctx.arc(sx, sy + 2 * sz * s, 5 * sz * s, 0, Math.PI);
                ctx.fill();
                ctx.stroke();
            }
            drawSkull(x - 8 * s, y, 1);
            drawSkull(x + 8 * s, y, 0.9);
            drawSkull(x, y - 8 * s, 0.85);
        }

        // Fire pit
        function drawFirePit(x, y) {
            const s = scale;
            // Pit ring (stones)
            ctx.fillStyle = '#3A3A3A';
            ctx.beginPath();
            ctx.ellipse(x, y - 2 * s, 25 * s, 8 * s, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#2A2A2A';
            ctx.lineWidth = 2;
            ctx.stroke();
            // Fire glow
            const fireGlow = ctx.createRadialGradient(x, y - 15 * s, 0, x, y - 10 * s, 30 * s);
            fireGlow.addColorStop(0, 'rgba(255, 200, 0, 0.4)');
            fireGlow.addColorStop(0.5, 'rgba(255, 100, 0, 0.2)');
            fireGlow.addColorStop(1, 'rgba(255, 50, 0, 0)');
            ctx.fillStyle = fireGlow;
            ctx.beginPath();
            ctx.arc(x, y - 10 * s, 30 * s, 0, Math.PI * 2);
            ctx.fill();
            // Flames
            const t = Date.now() * 0.005;
            for (let i = 0; i < 5; i++) {
                const fx = x + (i - 2) * 6 * s;
                const flicker = Math.sin(t + i * 1.5) * 5 * s;
                const h = (15 + Math.sin(t * 1.3 + i) * 8) * s;
                ctx.fillStyle = i % 2 === 0 ? '#FF6600' : '#FFAA00';
                ctx.beginPath();
                ctx.moveTo(fx - 4 * s, y - 5 * s);
                ctx.quadraticCurveTo(fx + flicker, y - 5 * s - h, fx + 4 * s, y - 5 * s);
                ctx.fill();
            }
            // Inner white-hot flame
            ctx.fillStyle = '#FFE0A0';
            ctx.beginPath();
            ctx.moveTo(x - 3 * s, y - 5 * s);
            ctx.quadraticCurveTo(x + Math.sin(t * 2) * 2 * s, y - 20 * s, x + 3 * s, y - 5 * s);
            ctx.fill();
        }

        // Bone pile
        function drawBonePile(x, y) {
            const s = scale;
            ctx.strokeStyle = '#D4C8A0';
            ctx.lineWidth = 3 * s;
            ctx.lineCap = 'round';
            // Several bones scattered
            for (let i = 0; i < 4; i++) {
                const bx = x + (i - 2) * 8 * s;
                const by = y - i * 3 * s;
                const angle = (i * 0.7) - 0.5;
                ctx.save();
                ctx.translate(bx, by);
                ctx.rotate(angle);
                ctx.beginPath();
                ctx.moveTo(-10 * s, 0);
                ctx.lineTo(10 * s, 0);
                ctx.stroke();
                // Bone knobs
                ctx.fillStyle = '#D4C8A0';
                ctx.beginPath();
                ctx.arc(-10 * s, 0, 3 * s, 0, Math.PI * 2);
                ctx.arc(10 * s, 0, 3 * s, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // Hell sign (warning/demonic messages)
        function drawHellSign(x, y, text) {
            const s = scale;
            // Crooked wooden post
            ctx.fillStyle = '#2A1A0A';
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(0.1);
            ctx.fillRect(-2 * s, -50 * s, 5 * s, 50 * s);
            // Sign plank
            ctx.fillStyle = '#3A2010';
            ctx.fillRect(-25 * s, -55 * s, 50 * s, 18 * s);
            ctx.strokeStyle = '#1A0A00';
            ctx.lineWidth = 1.5;
            ctx.strokeRect(-25 * s, -55 * s, 50 * s, 18 * s);
            // Text
            ctx.fillStyle = '#CC0000';
            ctx.font = `bold ${8 * s}px Comic Sans MS`;
            ctx.textAlign = 'center';
            ctx.fillText(text || 'DANGER', 0, -42 * s);
            ctx.restore();
        }

        // Draw lava lakes
        function drawLavaLakes() {
            const groundY = canvas.height * 0.86;
            for (const lava of lavaLakes) {
                const screenX = lava.x - camera.x;
                const screenEnd = screenX + lava.width;
                if (screenEnd < -10 || screenX > canvas.width + 10) continue;

                const s = scale;
                const lavaDepth = 20 * scaleY;

                // Lava body with gradient
                const lavaGrad = ctx.createLinearGradient(screenX, groundY, screenX, groundY + lavaDepth);
                lavaGrad.addColorStop(0, '#FF4500');
                lavaGrad.addColorStop(0.4, '#FF6600');
                lavaGrad.addColorStop(0.7, '#CC3300');
                lavaGrad.addColorStop(1, '#8B0000');
                ctx.fillStyle = lavaGrad;
                ctx.fillRect(screenX, groundY, lava.width, lavaDepth);

                // Glowing edge
                const edgeGlow = ctx.createLinearGradient(screenX, groundY - 5 * scaleY, screenX, groundY + 5 * scaleY);
                edgeGlow.addColorStop(0, 'rgba(255, 200, 0, 0)');
                edgeGlow.addColorStop(0.5, 'rgba(255, 200, 0, 0.5)');
                edgeGlow.addColorStop(1, 'rgba(255, 100, 0, 0)');
                ctx.fillStyle = edgeGlow;
                ctx.fillRect(screenX, groundY - 5 * scaleY, lava.width, 10 * scaleY);

                // Animated surface waves
                ctx.strokeStyle = 'rgba(255, 200, 50, 0.6)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                const t = Date.now() * 0.003;
                for (let wx = screenX; wx < screenX + lava.width; wx += 5 * s) {
                    const wy = groundY + Math.sin(t + wx * 0.05) * 2 * scaleY;
                    if (wx === screenX) ctx.moveTo(wx, wy);
                    else ctx.lineTo(wx, wy);
                }
                ctx.stroke();

                // Bubbling effect
                for (const bubble of lava.bubbles) {
                    bubble.timer += 0.05;
                    if (bubble.timer > 1) bubble.timer = 0;
                    const bubbleX = screenX + bubble.bx * lava.width;
                    const bubbleY = groundY + 5 * scaleY - bubble.timer * 10 * scaleY;
                    const alpha = bubble.timer < 0.8 ? 0.6 : (1 - bubble.timer) * 3;
                    ctx.fillStyle = `rgba(255, 200, 50, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(bubbleX, bubbleY, bubble.size * s * (1 - bubble.timer * 0.3), 0, Math.PI * 2);
                    ctx.fill();
                }

                // Ambient glow above lava
                const ambientGlow = ctx.createRadialGradient(
                    screenX + lava.width / 2, groundY, lava.width * 0.2,
                    screenX + lava.width / 2, groundY - 20 * scaleY, lava.width * 0.8
                );
                ambientGlow.addColorStop(0, 'rgba(255, 100, 0, 0.15)');
                ambientGlow.addColorStop(1, 'rgba(255, 50, 0, 0)');
                ctx.fillStyle = ambientGlow;
                ctx.beginPath();
                ctx.arc(screenX + lava.width / 2, groundY - 10 * scaleY, lava.width * 0.8, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Check lava collision with duck
        function checkLavaCollision() {
            if (level < 10) return;
            if (doomslayerSuit.active && doomslayerSuit.invincible) return;

            const duckFeetY = duck.y + duck.height;
            const groundY = canvas.height * 0.86;

            for (const lava of lavaLakes) {
                if (duck.x + duck.width > lava.x &&
                    duck.x < lava.x + lava.width &&
                    duckFeetY >= groundY - 5 * scaleY &&
                    duckFeetY <= groundY + 25 * scaleY) {
                    // Duck is in lava! Reset position
                    duck.x = 50 * scaleX;
                    duck.y = groundY - duck.height - 10;
                    duck.vx = 0;
                    duck.vy = 0;
                    camera.x = 0;
                    showMessage("Hot! Hot! Hot!");
                    return;
                }
            }
        }

        // Draw scenery element based on type
        function drawSceneryElement(elem, screenX) {
            const groundY = canvas.height * 0.86;
            switch (elem.type) {
                case 'tree':
                    drawTree(screenX, groundY, elem.size || 1);
                    break;
                case 'shrub':
                    drawShrub(screenX, groundY, elem.size || 1);
                    break;
                case 'flower':
                    drawFlower(screenX, groundY, elem.color);
                    break;
                case 'fence':
                    drawFence(screenX, groundY, elem.width * scale);
                    break;
                case 'house':
                    drawHouse(screenX, groundY, elem.style);
                    break;
                case 'mailbox':
                    drawMailbox(screenX, groundY);
                    break;
                case 'building':
                    drawBuilding(screenX, groundY, elem.width, elem.height, elem.style);
                    break;
                case 'lamppost':
                    drawLampPost(screenX, groundY);
                    break;
                case 'hydrant':
                    drawFireHydrant(screenX, groundY);
                    break;
                case 'bench':
                    drawBench(screenX, groundY);
                    break;
                case 'sign':
                    drawStreetSign(screenX, groundY, elem.text);
                    break;
                case 'finishBanner':
                    drawFinishBanner(screenX, groundY);
                    break;
                case 'hellWelcomeSign':
                    drawHellWelcomeSign(screenX, groundY);
                    break;
                case 'stalagmite':
                    drawStalagmite(screenX, groundY, elem.size || 1);
                    break;
                case 'deadTree':
                    drawDeadTree(screenX, groundY, elem.size || 1);
                    break;
                case 'skullPile':
                    drawSkullPile(screenX, groundY);
                    break;
                case 'firePit':
                    drawFirePit(screenX, groundY);
                    break;
                case 'bonePile':
                    drawBonePile(screenX, groundY);
                    break;
                case 'hellSign':
                    drawHellSign(screenX, groundY, elem.text);
                    break;
            }
        }

        // ========================================
        // PROGRAMMATIC BACKGROUND DRAWING
        // ========================================

        // Draw cloud
        function drawCloud(x, y, size) {
            const s = size * scale;
            
            // Cloud shadow (subtle)
            ctx.fillStyle = 'rgba(200, 200, 220, 0.3)';
            ctx.beginPath();
            ctx.arc(x + 2 * s, y + 2 * s, 20 * s, 0, Math.PI * 2);
            ctx.arc(x + 27 * s, y - 3 * s, 25 * s, 0, Math.PI * 2);
            ctx.arc(x + 52 * s, y + 2 * s, 20 * s, 0, Math.PI * 2);
            ctx.arc(x + 17 * s, y + 12 * s, 15 * s, 0, Math.PI * 2);
            ctx.arc(x + 37 * s, y + 10 * s, 18 * s, 0, Math.PI * 2);
            ctx.fill();
            
            // Main cloud with soft gradient
            const cloudGradient = ctx.createRadialGradient(x + 25 * s, y, 0, x + 25 * s, y, 50 * s);
            cloudGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            cloudGradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.95)');
            cloudGradient.addColorStop(1, 'rgba(240, 240, 250, 0.85)');
            ctx.fillStyle = cloudGradient;
            ctx.beginPath();
            ctx.arc(x, y, 20 * s, 0, Math.PI * 2);
            ctx.arc(x + 25 * s, y - 5 * s, 25 * s, 0, Math.PI * 2);
            ctx.arc(x + 50 * s, y, 20 * s, 0, Math.PI * 2);
            ctx.arc(x + 15 * s, y + 10 * s, 15 * s, 0, Math.PI * 2);
            ctx.arc(x + 35 * s, y + 8 * s, 18 * s, 0, Math.PI * 2);
            ctx.fill();
            
            // Cloud highlights
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.beginPath();
            ctx.arc(x + 20 * s, y - 8 * s, 10 * s, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 45 * s, y - 3 * s, 8 * s, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw backgrounds (consistent per level)
        function drawBackgrounds() {
            const groundY = canvas.height * 0.86;
            const scene = getSceneForLevel(level);
            const horizonY = canvas.height * 0.6;

            // Sky gradient
            const skyGradient = ctx.createLinearGradient(0, 0, 0, horizonY);
            skyGradient.addColorStop(0, scene.skyColors[0]);
            skyGradient.addColorStop(1, scene.skyColors[1]);
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, horizonY);

            const parallaxOffset = camera.x * 0.1;

            if (scene.name === 'hell') {
                // Blood moon
                const moonX = canvas.width * 0.85 - parallaxOffset * 0.3;
                const moonY = canvas.height * 0.12;
                const moonR = 40 * scale;

                // Moon glow (dark red)
                const moonGlow = ctx.createRadialGradient(moonX, moonY, moonR * 0.5, moonX, moonY, moonR * 3);
                moonGlow.addColorStop(0, 'rgba(200, 0, 0, 0.4)');
                moonGlow.addColorStop(0.5, 'rgba(150, 0, 0, 0.15)');
                moonGlow.addColorStop(1, 'rgba(100, 0, 0, 0)');
                ctx.fillStyle = moonGlow;
                ctx.beginPath();
                ctx.arc(moonX, moonY, moonR * 3, 0, Math.PI * 2);
                ctx.fill();

                // Moon body
                const moonGradient = ctx.createRadialGradient(moonX - moonR * 0.2, moonY - moonR * 0.2, 0, moonX, moonY, moonR);
                moonGradient.addColorStop(0, '#CC2222');
                moonGradient.addColorStop(0.6, '#8B0000');
                moonGradient.addColorStop(1, '#550000');
                ctx.fillStyle = moonGradient;
                ctx.beginPath();
                ctx.arc(moonX, moonY, moonR, 0, Math.PI * 2);
                ctx.fill();

                // Moon craters
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.beginPath();
                ctx.arc(moonX - 10 * scale, moonY - 5 * scale, 8 * scale, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(moonX + 12 * scale, moonY + 8 * scale, 6 * scale, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(moonX + 5 * scale, moonY - 12 * scale, 4 * scale, 0, Math.PI * 2);
                ctx.fill();

                // Floating embers instead of clouds
                if (hellEmbers.length < 30) {
                    for (let i = hellEmbers.length; i < 30; i++) {
                        hellEmbers.push({
                            x: Math.random() * canvas.width,
                            y: canvas.height * 0.3 + Math.random() * canvas.height * 0.5,
                            size: 1 + Math.random() * 3,
                            speed: 0.3 + Math.random() * 0.8,
                            drift: Math.random() * 2 - 1,
                            alpha: 0.3 + Math.random() * 0.7
                        });
                    }
                }
                for (const ember of hellEmbers) {
                    ember.y -= ember.speed;
                    ember.x += ember.drift + Math.sin(Date.now() * 0.002 + ember.x) * 0.3;
                    ember.alpha -= 0.003;
                    if (ember.y < 0 || ember.alpha <= 0) {
                        ember.y = canvas.height * 0.7 + Math.random() * canvas.height * 0.3;
                        ember.x = Math.random() * canvas.width;
                        ember.alpha = 0.5 + Math.random() * 0.5;
                    }
                    const emberGlow = ctx.createRadialGradient(ember.x, ember.y, 0, ember.x, ember.y, ember.size * scale * 2);
                    emberGlow.addColorStop(0, `rgba(255, 150, 0, ${ember.alpha})`);
                    emberGlow.addColorStop(0.5, `rgba(255, 80, 0, ${ember.alpha * 0.5})`);
                    emberGlow.addColorStop(1, `rgba(255, 0, 0, 0)`);
                    ctx.fillStyle = emberGlow;
                    ctx.beginPath();
                    ctx.arc(ember.x, ember.y, ember.size * scale * 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = `rgba(255, 200, 50, ${ember.alpha})`;
                    ctx.beginPath();
                    ctx.arc(ember.x, ember.y, ember.size * scale * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else {
                // Normal sun
                const sunX = canvas.width * 0.85 - parallaxOffset * 0.3;
                const sunY = canvas.height * 0.12;
                const sunR = 35 * scale;

                // Sun glow (outer)
                const sunGlowOuter = ctx.createRadialGradient(sunX, sunY, sunR * 0.5, sunX, sunY, sunR * 2.5);
                sunGlowOuter.addColorStop(0, 'rgba(255, 223, 0, 0.3)');
                sunGlowOuter.addColorStop(0.5, 'rgba(255, 215, 0, 0.15)');
                sunGlowOuter.addColorStop(1, 'rgba(255, 215, 0, 0)');
                ctx.fillStyle = sunGlowOuter;
                ctx.beginPath();
                ctx.arc(sunX, sunY, sunR * 2.5, 0, Math.PI * 2);
                ctx.fill();

                // Sun body with gradient
                const sunGradient = ctx.createRadialGradient(sunX - sunR * 0.3, sunY - sunR * 0.3, 0, sunX, sunY, sunR);
                sunGradient.addColorStop(0, '#FFEB3B');
                sunGradient.addColorStop(0.6, '#FFD700');
                sunGradient.addColorStop(1, '#FFA500');
                ctx.fillStyle = sunGradient;
                ctx.beginPath();
                ctx.arc(sunX, sunY, sunR, 0, Math.PI * 2);
                ctx.fill();

                // Sun rays
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const rayGradient = ctx.createLinearGradient(
                        sunX + Math.cos(angle) * sunR * 1.15,
                        sunY + Math.sin(angle) * sunR * 1.15,
                        sunX + Math.cos(angle) * sunR * 1.6,
                        sunY + Math.sin(angle) * sunR * 1.6
                    );
                    rayGradient.addColorStop(0, '#FFD700');
                    rayGradient.addColorStop(1, 'rgba(255, 215, 0, 0.3)');
                    ctx.strokeStyle = rayGradient;
                    ctx.lineWidth = 4 * scale;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(sunX + Math.cos(angle) * sunR * 1.15, sunY + Math.sin(angle) * sunR * 1.15);
                    ctx.lineTo(sunX + Math.cos(angle) * sunR * 1.6, sunY + Math.sin(angle) * sunR * 1.6);
                    ctx.stroke();
                }

                // Clouds (slow parallax)
                const cloudOffset = parallaxOffset * 0.5;
                drawCloud(((100 - cloudOffset) % (canvas.width + 200) + canvas.width + 200) % (canvas.width + 200) - 100, 60 * scaleY, 0.8);
                drawCloud(((400 - cloudOffset) % (canvas.width + 200) + canvas.width + 200) % (canvas.width + 200) - 100, 40 * scaleY, 1);
                drawCloud(((700 - cloudOffset) % (canvas.width + 200) + canvas.width + 200) % (canvas.width + 200) - 100, 70 * scaleY, 0.6);
            }

            // Rolling hills (with parallax)
            ctx.fillStyle = scene.hillColor;
            ctx.beginPath();
            ctx.moveTo(0, horizonY);
            const hillCount = 4;
            for (let i = 0; i <= hillCount; i++) {
                const hx = (i / hillCount) * canvas.width;
                const offset = ((parallaxOffset * 0.3) + i * 200) % 400;
                const hillHeight = 50 + Math.sin(offset * 0.02) * 30;
                ctx.quadraticCurveTo(
                    hx + canvas.width / (hillCount * 2),
                    horizonY - hillHeight * scaleY,
                    hx + canvas.width / hillCount,
                    horizonY
                );
            }
            ctx.lineTo(canvas.width, groundY);
            ctx.lineTo(0, groundY);
            ctx.closePath();
            ctx.fill();

            // Ground
            ctx.fillStyle = scene.groundColor;
            ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);

            // Ground texture
            ctx.strokeStyle = scene.groundAccent;
            ctx.lineWidth = 1;
            if (scene.name === 'hell') {
                // Cracked ground texture
                ctx.strokeStyle = '#5A1A1A';
                ctx.lineWidth = 1.5;
                for (let i = 0; i < canvas.width; i += 40 * scale) {
                    const seed = Math.sin(i * 0.1) * 100;
                    ctx.beginPath();
                    ctx.moveTo(i, groundY + 2 * scaleY);
                    ctx.lineTo(i + 10 * scale + seed % 15, groundY + 10 * scaleY);
                    ctx.lineTo(i + 5 * scale, groundY + 18 * scaleY);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(i + 20 * scale, groundY + 5 * scaleY);
                    ctx.lineTo(i + 25 * scale + seed % 10, groundY + 15 * scaleY);
                    ctx.stroke();
                }
                // Subtle lava glow along ground edge
                const lavaEdgeGlow = ctx.createLinearGradient(0, groundY - 3 * scaleY, 0, groundY + 5 * scaleY);
                lavaEdgeGlow.addColorStop(0, 'rgba(255, 60, 0, 0)');
                lavaEdgeGlow.addColorStop(0.5, 'rgba(255, 60, 0, 0.15)');
                lavaEdgeGlow.addColorStop(1, 'rgba(255, 60, 0, 0)');
                ctx.fillStyle = lavaEdgeGlow;
                ctx.fillRect(0, groundY - 3 * scaleY, canvas.width, 8 * scaleY);
            } else if (scene.name === 'countryside' || scene.name === 'suburbs') {
                // Grass blades
                for (let i = 0; i < canvas.width; i += 15 * scale) {
                    ctx.beginPath();
                    ctx.moveTo(i, groundY);
                    ctx.lineTo(i + 3 * scale, groundY - 5 * scaleY);
                    ctx.moveTo(i + 7 * scale, groundY);
                    ctx.lineTo(i + 10 * scale, groundY - 7 * scaleY);
                    ctx.stroke();
                }
            } else {
                // Street markings for downtown
                ctx.strokeStyle = '#FFFF00';
                ctx.lineWidth = 3 * scale;
                ctx.setLineDash([30 * scale, 20 * scale]);
                ctx.beginPath();
                ctx.moveTo(0, groundY + 30 * scaleY);
                ctx.lineTo(canvas.width, groundY + 30 * scaleY);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }

        // Draw the duck (cartoon style) - scaled version
        function drawDuck(x, y, facing, walkFrame, hasGun) {
            ctx.save();
            ctx.translate(x + duck.width/2, y + duck.height/2);
            ctx.scale(facing * scale, scale);
            ctx.translate(-25, -30); // center on reference duck size

            // Tail feathers with gradient
            const tailGradient = ctx.createRadialGradient(-5, 35, 0, -5, 35, 15);
            tailGradient.addColorStop(0, '#F5C842');
            tailGradient.addColorStop(1, '#D4A820');
            ctx.fillStyle = tailGradient;
            ctx.beginPath();
            ctx.moveTo(-5, 35);
            ctx.quadraticCurveTo(-15, 25, -12, 38);
            ctx.quadraticCurveTo(-18, 30, -14, 42);
            ctx.quadraticCurveTo(-12, 45, -5, 42);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Body (yellow oval) with gradient
            const bodyGradient = ctx.createRadialGradient(20, 30, 0, 25, 38, 30);
            bodyGradient.addColorStop(0, '#FFF176');
            bodyGradient.addColorStop(0.6, '#FFD83D');
            bodyGradient.addColorStop(1, '#F5C842');
            ctx.fillStyle = bodyGradient;
            ctx.beginPath();
            ctx.ellipse(25, 38, 24, 26, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Body highlight
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.ellipse(20, 32, 12, 14, -0.3, 0, Math.PI * 2);
            ctx.fill();

            // Wing with gradient
            const wingGradient = ctx.createRadialGradient(15, 35, 0, 20, 40, 18);
            wingGradient.addColorStop(0, '#F5D86D');
            wingGradient.addColorStop(1, '#D4A820');
            ctx.fillStyle = wingGradient;
            ctx.beginPath();
            ctx.ellipse(20, 40, 14, 18, -0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#B8942E';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Wing feather details
            ctx.strokeStyle = 'rgba(180, 148, 46, 0.4)';
            ctx.lineWidth = 0.5;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.arc(20, 35 + i * 5, 10, 0.3, 1.5);
                ctx.stroke();
            }

            // Neck with shading
            const neckGradient = ctx.createLinearGradient(30, 20, 40, 35);
            neckGradient.addColorStop(0, '#FFF176');
            neckGradient.addColorStop(1, '#FFD83D');
            ctx.fillStyle = neckGradient;
            ctx.beginPath();
            ctx.moveTo(35, 20);
            ctx.quadraticCurveTo(42, 25, 40, 35);
            ctx.quadraticCurveTo(35, 30, 30, 22);
            ctx.closePath();
            ctx.fill();

            // Head with gradient
            const headGradient = ctx.createRadialGradient(28, 6, 0, 32, 10, 14);
            headGradient.addColorStop(0, '#FFF9C4');
            headGradient.addColorStop(0.5, '#FFD83D');
            headGradient.addColorStop(1, '#F5C842');
            ctx.fillStyle = headGradient;
            ctx.beginPath();
            ctx.arc(32, 10, 14, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Beak (flat duck bill) with gradient
            const beakGradient = ctx.createLinearGradient(44, 8, 60, 12);
            beakGradient.addColorStop(0, '#FFA726');
            beakGradient.addColorStop(0.5, '#FF8C00');
            beakGradient.addColorStop(1, '#E67E00');
            ctx.fillStyle = beakGradient;
            ctx.beginPath();
            ctx.moveTo(44, 8);
            ctx.quadraticCurveTo(58, 6, 60, 12);
            ctx.quadraticCurveTo(58, 18, 44, 16);
            ctx.quadraticCurveTo(46, 12, 44, 8);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            
            // Beak highlight
            ctx.fillStyle = 'rgba(255, 200, 100, 0.4)';
            ctx.beginPath();
            ctx.moveTo(46, 9);
            ctx.quadraticCurveTo(52, 8, 54, 10);
            ctx.quadraticCurveTo(52, 11, 46, 11);
            ctx.closePath();
            ctx.fill();
            
            // Nostril
            ctx.fillStyle = '#CC6600';
            ctx.beginPath();
            ctx.ellipse(50, 11, 2, 1.5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Eye white with subtle gradient
            const eyeWhiteGradient = ctx.createRadialGradient(37, 6, 0, 38, 7, 6);
            eyeWhiteGradient.addColorStop(0, '#FFFFFF');
            eyeWhiteGradient.addColorStop(1, '#F0F0F0');
            ctx.fillStyle = eyeWhiteGradient;
            ctx.beginPath();
            ctx.ellipse(38, 7, 5, 6, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Pupil with depth
            const pupilGradient = ctx.createRadialGradient(38.5, 6.5, 0, 39, 7, 2.5);
            pupilGradient.addColorStop(0, '#333');
            pupilGradient.addColorStop(1, '#000');
            ctx.fillStyle = pupilGradient;
            ctx.beginPath();
            ctx.arc(39, 7, 2.5, 0, Math.PI * 2);
            ctx.fill();
            
            // Eye highlights (two for more life)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.beginPath();
            ctx.arc(40, 5.5, 1.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.beginPath();
            ctx.arc(38, 8, 0.6, 0, Math.PI * 2);
            ctx.fill();

            // Legs with gradient - improved waddling animation
            const legGradient = ctx.createLinearGradient(0, 60, 0, 72);
            legGradient.addColorStop(0, '#FFA726');
            legGradient.addColorStop(1, '#FF8C00');
            ctx.strokeStyle = legGradient;
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            
            // More natural waddling motion - legs alternate more dramatically
            // Left leg moves forward when sin is positive, right leg when negative
            const waddle = walkFrame * 0.4; // Increased speed for more energetic motion
            const leftLegOffset = Math.sin(waddle) * 8; // Increased amplitude
            const rightLegOffset = Math.sin(waddle + Math.PI) * 8; // Opposite phase
            const leftLegLift = Math.max(0, -Math.sin(waddle) * 3); // Lift leg when moving forward
            const rightLegLift = Math.max(0, -Math.sin(waddle + Math.PI) * 3);

            // Left leg
            ctx.beginPath();
            ctx.moveTo(18, 60);
            ctx.lineTo(15 + leftLegOffset, 72 - leftLegLift);
            ctx.stroke();

            // Right leg
            ctx.beginPath();
            ctx.moveTo(32, 60);
            ctx.lineTo(35 + rightLegOffset, 72 - rightLegLift);
            ctx.stroke();

            // Webbed feet with gradient - improved animation
            const footGradient = ctx.createLinearGradient(0, 72, 0, 74);
            footGradient.addColorStop(0, '#FF8C00');
            footGradient.addColorStop(1, '#E67E00');
            ctx.fillStyle = footGradient;
            ctx.lineWidth = 1.5;
            
            // Calculate foot angles for more dynamic motion
            const leftFootAngle = Math.sin(waddle) * 0.3; // Tilt foot forward/back
            const rightFootAngle = Math.sin(waddle + Math.PI) * 0.3;
            
            // Left foot - with rotation
            ctx.save();
            ctx.translate(15 + leftLegOffset, 72 - leftLegLift);
            ctx.rotate(leftFootAngle);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-10, 2);
            ctx.lineTo(-5, 0);
            ctx.lineTo(0, 2);
            ctx.lineTo(5, 0);
            ctx.lineTo(10, 2);
            ctx.lineTo(5, 0);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#B8660A';
            ctx.stroke();
            ctx.restore();
            
            // Right foot - with rotation
            ctx.save();
            ctx.translate(35 + rightLegOffset, 72 - rightLegLift);
            ctx.rotate(rightFootAngle);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-10, 2);
            ctx.lineTo(-5, 0);
            ctx.lineTo(0, 2);
            ctx.lineTo(5, 0);
            ctx.lineTo(10, 2);
            ctx.lineTo(5, 0);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#B8660A';
            ctx.stroke();
            ctx.restore();

            // Lemon seed gun (if has gun)
            if (hasGun) {
                // Gun body (held under wing)
                ctx.fillStyle = '#8B4513';
                ctx.beginPath();
                ctx.roundRect(35, 32, 30, 10, 3);
                ctx.fill();
                ctx.strokeStyle = '#5D2E0C';
                ctx.lineWidth = 1.5;
                ctx.stroke();

                // Gun barrel
                ctx.fillStyle = '#666';
                ctx.beginPath();
                ctx.roundRect(60, 34, 18, 6, 2);
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.stroke();

                // Gun handle
                ctx.fillStyle = '#8B4513';
                ctx.beginPath();
                ctx.roundRect(40, 40, 8, 12, 2);
                ctx.fill();
                ctx.strokeStyle = '#5D2E0C';
                ctx.stroke();

                // Lemon decoration on gun
                ctx.fillStyle = '#FFE135';
                ctx.beginPath();
                ctx.ellipse(45, 37, 5, 3, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#DAA520';
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            ctx.restore();
        }

        // Draw a grape bunch (scaled)
        function drawGrape(x, y, size) {
            const s = size * scale;

            // Stem with gradient
            const stemGradient = ctx.createLinearGradient(x, y - s - 10 * scale, x, y - s);
            stemGradient.addColorStop(0, '#2E7D32');
            stemGradient.addColorStop(1, '#228B22');
            ctx.strokeStyle = stemGradient;
            ctx.lineWidth = 2.5 * scale;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(x, y - s);
            ctx.lineTo(x, y - s - 10 * scale);
            ctx.stroke();

            // Leaf with gradient
            const leafGradient = ctx.createRadialGradient(x + 5 * scale, y - s - 8 * scale, 0, x + 5 * scale, y - s - 8 * scale, 8 * scale);
            leafGradient.addColorStop(0, '#4CAF50');
            leafGradient.addColorStop(1, '#2E7D32');
            ctx.fillStyle = leafGradient;
            ctx.beginPath();
            ctx.ellipse(x + 5 * scale, y - s - 8 * scale, 8 * scale, 4 * scale, 0.3, 0, Math.PI * 2);
            ctx.fill();
            // Leaf vein
            ctx.strokeStyle = '#1B5E20';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x + 2 * scale, y - s - 8 * scale);
            ctx.lineTo(x + 8 * scale, y - s - 8 * scale);
            ctx.stroke();

            const positions = [
                {dx: 0, dy: 0},
                {dx: -s*0.7, dy: -s*0.4},
                {dx: s*0.7, dy: -s*0.4},
                {dx: -s*0.35, dy: s*0.5},
                {dx: s*0.35, dy: s*0.5},
                {dx: 0, dy: s*0.9}
            ];

            positions.forEach(pos => {
                const gx = x + pos.dx;
                const gy = y + pos.dy;
                
                // Grape shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
                ctx.beginPath();
                ctx.arc(gx + s * 0.1, gy + s * 0.15, s * 0.48, 0, Math.PI * 2);
                ctx.fill();

                // Grape body with radial gradient
                const grapeGradient = ctx.createRadialGradient(
                    gx - s * 0.15, gy - s * 0.15, 0,
                    gx, gy, s * 0.5
                );
                grapeGradient.addColorStop(0, '#BA68C8');
                grapeGradient.addColorStop(0.5, '#8B008B');
                grapeGradient.addColorStop(1, '#6A0080');
                ctx.fillStyle = grapeGradient;
                ctx.beginPath();
                ctx.arc(gx, gy, s * 0.5, 0, Math.PI * 2);
                ctx.fill();
                
                // Grape outline
                ctx.strokeStyle = '#4B0082';
                ctx.lineWidth = 1.5 * scale;
                ctx.stroke();

                // Main highlight (glossy effect)
                const highlightGradient = ctx.createRadialGradient(
                    gx - s * 0.2, gy - s * 0.2, 0,
                    gx - s * 0.2, gy - s * 0.2, s * 0.25
                );
                highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.7)');
                highlightGradient.addColorStop(0.5, 'rgba(204, 153, 255, 0.4)');
                highlightGradient.addColorStop(1, 'rgba(204, 153, 255, 0)');
                ctx.fillStyle = highlightGradient;
                ctx.beginPath();
                ctx.arc(gx - s * 0.2, gy - s * 0.2, s * 0.25, 0, Math.PI * 2);
                ctx.fill();

                // Secondary highlight
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.beginPath();
                ctx.arc(gx - s * 0.25, gy - s * 0.25, s * 0.12, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // Draw a lemon seed projectile
        function drawSeed(x, y) {
            ctx.fillStyle = '#F5DEB3';
            ctx.beginPath();
            ctx.ellipse(x, y, 6 * scale, 3 * scale, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#D2B48C';
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        // ========================================
        // PARTICLE SYSTEM
        // ========================================
        
        function createParticles(x, y, count, type) {
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 * i) / count + Math.random() * 0.5;
                const speed = 2 + Math.random() * 3;
                
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 1,
                    life: 1.0,
                    decay: 0.02 + Math.random() * 0.01,
                    size: 3 + Math.random() * 3,
                    type: type,
                    color: type === 'grape' ? '#8B008B' : '#FFD700'
                });
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.15; // gravity
                p.life -= p.decay;
                
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        function drawParticles() {
            for (const p of particles) {
                const screenX = p.x - camera.x;
                if (screenX < -20 || screenX > canvas.width + 20) continue;
                
                ctx.save();
                ctx.globalAlpha = p.life;
                
                if (p.type === 'grape') {
                    // Sparkle particles for grapes
                    const gradient = ctx.createRadialGradient(screenX, p.y, 0, screenX, p.y, p.size * scale);
                    gradient.addColorStop(0, '#DA70D6');
                    gradient.addColorStop(0.5, '#8B008B');
                    gradient.addColorStop(1, 'rgba(139, 0, 139, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(screenX, p.y, p.size * scale, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Star shape
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * 2 * Math.PI) / 5 - Math.PI / 2;
                        const x = screenX + Math.cos(angle) * p.size * scale * 0.5;
                        const y = p.y + Math.sin(angle) * p.size * scale * 0.5;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                } else {
                    // Simple colored particles
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(screenX, p.y, p.size * scale, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }

        // ========================================
        // ENEMY DRAWING
        // ========================================
        
        // Draw enemy based on type
        function drawEnemy(enemy, screenX) {
            const x = screenX;
            const y = enemy.y;
            const s = scale;

            if (enemy.type === 'walker') {
                // Angry lemon - walks back and forth
                ctx.fillStyle = '#FFE135';
                ctx.beginPath();
                ctx.ellipse(x, y, 20 * s, 16 * s, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#DAA520';
                ctx.lineWidth = 2;
                ctx.stroke();
                // Angry eyes
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(x - 6 * s, y - 4 * s, 3 * s, 0, Math.PI * 2);
                ctx.arc(x + 6 * s, y - 4 * s, 3 * s, 0, Math.PI * 2);
                ctx.fill();
                // Angry eyebrows
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x - 10 * s, y - 10 * s);
                ctx.lineTo(x - 3 * s, y - 7 * s);
                ctx.moveTo(x + 10 * s, y - 10 * s);
                ctx.lineTo(x + 3 * s, y - 7 * s);
                ctx.stroke();
                // Frown
                ctx.beginPath();
                ctx.arc(x, y + 8 * s, 6 * s, 1.2 * Math.PI, 1.8 * Math.PI);
                ctx.stroke();
                // Legs
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(x - 8 * s, y + 14 * s);
                ctx.lineTo(x - 10 * s, y + 25 * s);
                ctx.moveTo(x + 8 * s, y + 14 * s);
                ctx.lineTo(x + 10 * s, y + 25 * s);
                ctx.stroke();
            } else if (enemy.type === 'flyer') {
                // Flying lime with wings
                ctx.fillStyle = '#32CD32';
                ctx.beginPath();
                ctx.arc(x, y, 15 * s, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#228B22';
                ctx.lineWidth = 2;
                ctx.stroke();
                // Wings
                ctx.fillStyle = 'rgba(200, 200, 255, 0.7)';
                const wingFlap = Math.sin(Date.now() * 0.02) * 5;
                ctx.beginPath();
                ctx.ellipse(x - 20 * s, y - wingFlap * s, 12 * s, 6 * s, -0.3, 0, Math.PI * 2);
                ctx.ellipse(x + 20 * s, y - wingFlap * s, 12 * s, 6 * s, 0.3, 0, Math.PI * 2);
                ctx.fill();
                // Eyes
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(x - 5 * s, y - 3 * s, 2 * s, 0, Math.PI * 2);
                ctx.arc(x + 5 * s, y - 3 * s, 2 * s, 0, Math.PI * 2);
                ctx.fill();
            } else if (enemy.type === 'jumper') {
                // Jumping orange
                ctx.fillStyle = '#FFA500';
                ctx.beginPath();
                ctx.arc(x, y, 18 * s, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#FF8C00';
                ctx.lineWidth = 2;
                ctx.stroke();
                // Leaf on top
                ctx.fillStyle = '#228B22';
                ctx.beginPath();
                ctx.ellipse(x, y - 20 * s, 5 * s, 8 * s, 0, 0, Math.PI * 2);
                ctx.fill();
                // Eyes
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(x - 6 * s, y - 4 * s, 3 * s, 0, Math.PI * 2);
                ctx.arc(x + 6 * s, y - 4 * s, 3 * s, 0, Math.PI * 2);
                ctx.fill();
                // Determined mouth
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x - 6 * s, y + 6 * s);
                ctx.lineTo(x + 6 * s, y + 6 * s);
                ctx.stroke();
            } else if (enemy.type === 'demon') {
                // Demon - large red body, horns, bat wings, menacing
                const s2 = s;
                // Body
                ctx.fillStyle = '#8B0000';
                ctx.beginPath();
                ctx.ellipse(x, y, 28 * s2, 30 * s2, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#550000';
                ctx.lineWidth = 2;
                ctx.stroke();
                // Body highlight
                ctx.fillStyle = 'rgba(255, 50, 50, 0.3)';
                ctx.beginPath();
                ctx.ellipse(x - 8 * s2, y - 10 * s2, 12 * s2, 15 * s2, -0.3, 0, Math.PI * 2);
                ctx.fill();
                // Horns
                ctx.fillStyle = '#2A0A0A';
                ctx.beginPath();
                ctx.moveTo(x - 15 * s2, y - 25 * s2);
                ctx.quadraticCurveTo(x - 25 * s2, y - 50 * s2, x - 20 * s2, y - 45 * s2);
                ctx.quadraticCurveTo(x - 12 * s2, y - 40 * s2, x - 10 * s2, y - 28 * s2);
                ctx.closePath();
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(x + 15 * s2, y - 25 * s2);
                ctx.quadraticCurveTo(x + 25 * s2, y - 50 * s2, x + 20 * s2, y - 45 * s2);
                ctx.quadraticCurveTo(x + 12 * s2, y - 40 * s2, x + 10 * s2, y - 28 * s2);
                ctx.closePath();
                ctx.fill();
                // Bat wings (animated flap)
                const wingFlap2 = Math.sin(Date.now() * 0.01) * 8;
                ctx.fillStyle = 'rgba(100, 0, 0, 0.8)';
                // Left wing
                ctx.beginPath();
                ctx.moveTo(x - 25 * s2, y - 5 * s2);
                ctx.quadraticCurveTo(x - 55 * s2, y - 25 * s2 - wingFlap2 * s2, x - 50 * s2, y + 5 * s2);
                ctx.quadraticCurveTo(x - 40 * s2, y + 10 * s2, x - 25 * s2, y + 5 * s2);
                ctx.closePath();
                ctx.fill();
                // Right wing
                ctx.beginPath();
                ctx.moveTo(x + 25 * s2, y - 5 * s2);
                ctx.quadraticCurveTo(x + 55 * s2, y - 25 * s2 - wingFlap2 * s2, x + 50 * s2, y + 5 * s2);
                ctx.quadraticCurveTo(x + 40 * s2, y + 10 * s2, x + 25 * s2, y + 5 * s2);
                ctx.closePath();
                ctx.fill();
                // Wing membrane lines
                ctx.strokeStyle = '#330000';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x - 25 * s2, y - 5 * s2);
                ctx.lineTo(x - 45 * s2, y - 10 * s2 - wingFlap2 * s2 * 0.5);
                ctx.moveTo(x + 25 * s2, y - 5 * s2);
                ctx.lineTo(x + 45 * s2, y - 10 * s2 - wingFlap2 * s2 * 0.5);
                ctx.stroke();
                // Glowing eyes
                ctx.shadowColor = '#FFFF00';
                ctx.shadowBlur = 8 * s2;
                ctx.fillStyle = '#FFFF00';
                ctx.beginPath();
                ctx.ellipse(x - 8 * s2, y - 10 * s2, 5 * s2, 4 * s2, 0, 0, Math.PI * 2);
                ctx.ellipse(x + 8 * s2, y - 10 * s2, 5 * s2, 4 * s2, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                // Red pupils
                ctx.fillStyle = '#FF0000';
                ctx.beginPath();
                ctx.arc(x - 8 * s2, y - 10 * s2, 2 * s2, 0, Math.PI * 2);
                ctx.arc(x + 8 * s2, y - 10 * s2, 2 * s2, 0, Math.PI * 2);
                ctx.fill();
                // Toothy grin
                ctx.fillStyle = '#1A0000';
                ctx.beginPath();
                ctx.arc(x, y + 5 * s2, 12 * s2, 0, Math.PI);
                ctx.fill();
                ctx.fillStyle = '#FFFFFF';
                for (let t = 0; t < 5; t++) {
                    const tx = x - 8 * s2 + t * 4 * s2;
                    ctx.beginPath();
                    ctx.moveTo(tx, y + 5 * s2);
                    ctx.lineTo(tx + 2 * s2, y + 10 * s2);
                    ctx.lineTo(tx + 4 * s2, y + 5 * s2);
                    ctx.fill();
                }
                // Hooves
                ctx.fillStyle = '#1A0A0A';
                ctx.beginPath();
                ctx.ellipse(x - 10 * s2, y + 30 * s2, 6 * s2, 4 * s2, 0, 0, Math.PI * 2);
                ctx.ellipse(x + 10 * s2, y + 30 * s2, 6 * s2, 4 * s2, 0, 0, Math.PI * 2);
                ctx.fill();
                // Legs
                ctx.strokeStyle = '#6B0000';
                ctx.lineWidth = 4 * s2;
                ctx.beginPath();
                ctx.moveTo(x - 10 * s2, y + 25 * s2);
                ctx.lineTo(x - 10 * s2, y + 30 * s2);
                ctx.moveTo(x + 10 * s2, y + 25 * s2);
                ctx.lineTo(x + 10 * s2, y + 30 * s2);
                ctx.stroke();
            }

            // Health indicator
            if (enemy.health > 1) {
                const maxHP = enemy.type === 'demon' ? 4 : 2;
                const barY = enemy.type === 'demon' ? y - 40 * s : y - 30 * s;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(x - 15 * s, barY, 30 * s, 5 * s);
                ctx.fillStyle = '#FF0000';
                ctx.fillRect(x - 15 * s, barY, (enemy.health / maxHP) * 30 * s, 5 * s);
            }
        }

        // Draw helicopter
        function drawHelicopter(x, y, isPickup, facing) {
            const s = scale;
            const f = facing || 1; // 1 = right, -1 = left

            if (isPickup) {
                // Glowing pickup effect
                ctx.fillStyle = 'rgba(100, 200, 255, 0.3)';
                ctx.beginPath();
                ctx.arc(x, y, 40 * s + Math.sin(Date.now() * 0.005) * 5 * s, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.save();
            ctx.translate(x, y);
            ctx.scale(f, 1);

            // Body
            ctx.fillStyle = '#4169E1';
            ctx.beginPath();
            ctx.ellipse(0, 0, 30 * s, 15 * s, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Cockpit
            ctx.fillStyle = '#87CEEB';
            ctx.beginPath();
            ctx.ellipse(15 * s, 0, 12 * s, 10 * s, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Tail
            ctx.fillStyle = '#4169E1';
            ctx.beginPath();
            ctx.moveTo(-25 * s, -5 * s);
            ctx.lineTo(-50 * s, -8 * s);
            ctx.lineTo(-50 * s, 8 * s);
            ctx.lineTo(-25 * s, 5 * s);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Tail rotor
            ctx.fillStyle = '#333';
            ctx.fillRect(-52 * s, -15 * s, 4 * s, 30 * s);

            // Main rotor
            const rotorAngle = Date.now() * 0.03;
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 3 * s;
            ctx.beginPath();
            ctx.moveTo(Math.cos(rotorAngle) * 40 * s, -18 * s);
            ctx.lineTo(-Math.cos(rotorAngle) * 40 * s, -18 * s);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(Math.sin(rotorAngle) * 40 * s, -18 * s);
            ctx.lineTo(-Math.sin(rotorAngle) * 40 * s, -18 * s);
            ctx.stroke();

            // Rotor hub
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.arc(0, -18 * s, 5 * s, 0, Math.PI * 2);
            ctx.fill();

            // Skids
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 3 * s;
            ctx.beginPath();
            ctx.moveTo(-20 * s, 15 * s);
            ctx.lineTo(-20 * s, 22 * s);
            ctx.lineTo(20 * s, 22 * s);
            ctx.lineTo(20 * s, 15 * s);
            ctx.stroke();

            ctx.restore();
        }

        // Draw Doomslayer suit pickup
        function drawDoomslayerPickup(x, y) {
            const s = scale;
            // Glowing green pickup effect
            const pulse = Math.sin(Date.now() * 0.005) * 5 * s;
            ctx.fillStyle = 'rgba(0, 255, 100, 0.2)';
            ctx.beginPath();
            ctx.arc(x, y, 35 * s + pulse, 0, Math.PI * 2);
            ctx.fill();

            // Armor body (green torso)
            const armorGrad = ctx.createLinearGradient(x - 20 * s, y - 25 * s, x + 20 * s, y + 20 * s);
            armorGrad.addColorStop(0, '#33AA33');
            armorGrad.addColorStop(0.5, '#228822');
            armorGrad.addColorStop(1, '#116611');
            ctx.fillStyle = armorGrad;
            ctx.beginPath();
            ctx.moveTo(x - 18 * s, y - 20 * s);
            ctx.lineTo(x + 18 * s, y - 20 * s);
            ctx.lineTo(x + 22 * s, y + 15 * s);
            ctx.lineTo(x - 22 * s, y + 15 * s);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#0A440A';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Helmet (Doom-style visor)
            ctx.fillStyle = '#226622';
            ctx.beginPath();
            ctx.arc(x, y - 28 * s, 14 * s, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            // Cyan visor
            ctx.fillStyle = '#00FFFF';
            ctx.shadowColor = '#00FFFF';
            ctx.shadowBlur = 8 * s;
            ctx.beginPath();
            ctx.ellipse(x, y - 28 * s, 10 * s, 5 * s, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Shoulder pads
            ctx.fillStyle = '#33AA33';
            ctx.beginPath();
            ctx.ellipse(x - 22 * s, y - 15 * s, 8 * s, 6 * s, 0, 0, Math.PI * 2);
            ctx.ellipse(x + 22 * s, y - 15 * s, 8 * s, 6 * s, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // "E" prompt
            ctx.fillStyle = '#00FF88';
            ctx.font = `bold ${10 * s}px Comic Sans MS`;
            ctx.textAlign = 'center';
            ctx.fillText('Press E', x, y + 30 * s);
        }

        // Draw Doomslayer suit with duck inside (side-profile, running pose)
        function drawDoomslayerSuit(x, y, facing) {
            const s = scale;
            const f = facing || 1; // 1 = right, -1 = left
            const time = Date.now() / 150;
            const isMoving = Math.abs(duck.vx) > 0.5;
            const legSwing = isMoving ? Math.sin(time) * 12 : 0;
            const armSwing = isMoving ? Math.sin(time + Math.PI) * 15 : 0;
            const bodyBob = isMoving ? Math.abs(Math.sin(time)) * 2 * s : 0;

            ctx.save();
            ctx.translate(x, y - bodyBob);
            ctx.scale(f, 1);

            // Back arm (behind body, attached at shoulder)
            ctx.save();
            ctx.translate(-14 * s, -24 * s);
            ctx.rotate((-10 + armSwing * 0.6) * Math.PI / 180);
            ctx.fillStyle = '#228822';
            ctx.fillRect(-3.5 * s, 0, 7 * s, 20 * s);
            ctx.strokeStyle = '#0A440A';
            ctx.lineWidth = 2 * s;
            ctx.strokeRect(-3.5 * s, 0, 7 * s, 20 * s);
            // Fist
            ctx.fillStyle = '#2A8A2A';
            ctx.beginPath();
            ctx.arc(0, 22 * s, 4.5 * s, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            ctx.restore();

            // Back leg
            ctx.save();
            ctx.translate(-6 * s, 25 * s);
            ctx.rotate((legSwing) * Math.PI / 180);
            ctx.fillStyle = '#228822';
            ctx.fillRect(-6 * s, 0, 12 * s, 22 * s);
            ctx.strokeStyle = '#0A440A';
            ctx.lineWidth = 2 * s;
            ctx.strokeRect(-6 * s, 0, 12 * s, 22 * s);
            // Boot
            ctx.fillStyle = '#1A6A1A';
            ctx.fillRect(-6 * s, 18 * s, 16 * s, 8 * s);
            ctx.strokeRect(-6 * s, 18 * s, 16 * s, 8 * s);
            ctx.restore();

            // Armor body (torso, slightly angled for side view)
            const armorGrad = ctx.createLinearGradient(-20 * s, -35 * s, 20 * s, 30 * s);
            armorGrad.addColorStop(0, '#44CC44');
            armorGrad.addColorStop(0.5, '#33AA33');
            armorGrad.addColorStop(1, '#228822');
            ctx.fillStyle = armorGrad;
            ctx.beginPath();
            ctx.moveTo(-18 * s, -30 * s);
            ctx.lineTo(16 * s, -30 * s);
            ctx.lineTo(20 * s, 25 * s);
            ctx.lineTo(-22 * s, 25 * s);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#0A440A';
            ctx.lineWidth = 2.5 * s;
            ctx.stroke();

            // Chest plate detail (angled line for side view)
            ctx.strokeStyle = '#116611';
            ctx.lineWidth = 2 * s;
            ctx.beginPath();
            ctx.moveTo(-10 * s, -18 * s);
            ctx.lineTo(12 * s, -22 * s);
            ctx.moveTo(-14 * s, 0);
            ctx.lineTo(14 * s, -3 * s);
            ctx.stroke();

            // Front leg
            ctx.save();
            ctx.translate(6 * s, 25 * s);
            ctx.rotate((-legSwing) * Math.PI / 180);
            ctx.fillStyle = '#2A8A2A';
            ctx.fillRect(-6 * s, 0, 12 * s, 22 * s);
            ctx.strokeStyle = '#0A440A';
            ctx.lineWidth = 2 * s;
            ctx.strokeRect(-6 * s, 0, 12 * s, 22 * s);
            // Boot
            ctx.fillStyle = '#1A6A1A';
            ctx.fillRect(-6 * s, 18 * s, 16 * s, 8 * s);
            ctx.strokeRect(-6 * s, 18 * s, 16 * s, 8 * s);
            ctx.restore();

            // Front shoulder pad
            ctx.fillStyle = '#44CC44';
            ctx.strokeStyle = '#0A440A';
            ctx.lineWidth = 2 * s;
            ctx.beginPath();
            ctx.ellipse(14 * s, -26 * s, 9 * s, 6 * s, 0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Front arm (attached at shoulder, swinging)
            ctx.save();
            ctx.translate(14 * s, -24 * s);
            ctx.rotate((10 - armSwing * 0.6) * Math.PI / 180);
            ctx.fillStyle = '#33AA33';
            ctx.fillRect(-3.5 * s, 0, 7 * s, 22 * s);
            ctx.strokeStyle = '#0A440A';
            ctx.lineWidth = 2 * s;
            ctx.strokeRect(-3.5 * s, 0, 7 * s, 22 * s);
            // Fist
            ctx.fillStyle = '#33AA33';
            ctx.beginPath();
            ctx.arc(0, 26 * s, 5 * s, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            ctx.restore();

            // Helmet (turned to side - offset forward)
            ctx.fillStyle = '#2A7A2A';
            ctx.beginPath();
            ctx.arc(4 * s, -40 * s, 17 * s, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#0A440A';
            ctx.lineWidth = 2.5 * s;
            ctx.stroke();

            // Visor (facing forward/side - asymmetric, on the facing side)
            ctx.fillStyle = '#00FFFF';
            ctx.shadowColor = '#00FFFF';
            ctx.shadowBlur = 10 * s;
            ctx.beginPath();
            ctx.ellipse(14 * s, -40 * s, 7 * s, 10 * s, 0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Visor highlight
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.ellipse(12 * s, -43 * s, 3 * s, 4 * s, 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Energy glow effect
            ctx.globalAlpha = 0.3;
            ctx.fillStyle = '#00FF88';
            ctx.beginPath();
            ctx.arc(4 * s, -40 * s, 20 * s, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1.0;

            ctx.restore();
        }

        // Draw platforms (already in screen coords)
        function drawPlatform(p) {
            const isHell = level >= 10;

            // Platform shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.fillRect(p.x + 3 * scale, p.y + 3 * scaleY, p.width, p.height);

            if (isHell) {
                // Dark stone body
                const stoneGrad = ctx.createLinearGradient(p.x, p.y + 10 * scaleY, p.x, p.y + p.height);
                stoneGrad.addColorStop(0, '#3A3A3A');
                stoneGrad.addColorStop(0.5, '#2A2A2A');
                stoneGrad.addColorStop(1, '#1A1A1A');
                ctx.fillStyle = stoneGrad;
                ctx.fillRect(p.x, p.y + 10 * scaleY, p.width, p.height - 10 * scaleY);

                // Stone cracks
                ctx.strokeStyle = 'rgba(80, 40, 20, 0.4)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 3; i++) {
                    const yPos = p.y + 15 * scaleY + i * 8 * scaleY;
                    ctx.beginPath();
                    ctx.moveTo(p.x + 5 * scale, yPos);
                    ctx.lineTo(p.x + p.width * 0.4, yPos + 3 * scaleY);
                    ctx.lineTo(p.x + p.width * 0.7, yPos - 2 * scaleY);
                    ctx.stroke();
                }

                // Magma-crack top edge (instead of grass)
                const magmaGrad = ctx.createLinearGradient(p.x, p.y, p.x, p.y + 15 * scaleY);
                magmaGrad.addColorStop(0, '#4A2A2A');
                magmaGrad.addColorStop(0.3, '#3A1A1A');
                magmaGrad.addColorStop(1, '#2A1A1A');
                ctx.fillStyle = magmaGrad;
                ctx.fillRect(p.x, p.y, p.width, 15 * scaleY);

                // Glowing magma cracks on top
                ctx.strokeStyle = '#FF4500';
                ctx.lineWidth = 1.5;
                ctx.shadowColor = '#FF4500';
                ctx.shadowBlur = 4 * scale;
                for (let i = p.x; i < p.x + p.width; i += 25 * scale) {
                    const seed = Math.sin(i * 0.1 + p.y * 0.05);
                    ctx.beginPath();
                    ctx.moveTo(i, p.y + 3 * scaleY);
                    ctx.lineTo(i + 8 * scale, p.y + 7 * scaleY + seed * 3 * scaleY);
                    ctx.lineTo(i + 15 * scale, p.y + 4 * scaleY);
                    ctx.stroke();
                }
                ctx.shadowBlur = 0;

                // Platform outline
                ctx.strokeStyle = '#1A0A0A';
                ctx.lineWidth = 2;
                ctx.strokeRect(p.x, p.y, p.width, p.height);
            } else {
                // Normal wood section with gradient
                const woodGradient = ctx.createLinearGradient(p.x, p.y + 10 * scaleY, p.x, p.y + p.height);
                woodGradient.addColorStop(0, '#A0643C');
                woodGradient.addColorStop(0.5, '#8B4513');
                woodGradient.addColorStop(1, '#6F3710');
                ctx.fillStyle = woodGradient;
                ctx.fillRect(p.x, p.y + 10 * scaleY, p.width, p.height - 10 * scaleY);

                // Wood grain texture
                ctx.strokeStyle = 'rgba(101, 67, 33, 0.3)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 3; i++) {
                    const yPos = p.y + 15 * scaleY + i * 8 * scaleY;
                    ctx.beginPath();
                    ctx.moveTo(p.x, yPos);
                    ctx.lineTo(p.x + p.width, yPos);
                    ctx.stroke();
                }

                // Grass section with gradient
                const grassGradient = ctx.createLinearGradient(p.x, p.y, p.x, p.y + 15 * scaleY);
                grassGradient.addColorStop(0, '#4CAF50');
                grassGradient.addColorStop(0.5, '#32CD32');
                grassGradient.addColorStop(1, '#2E7D32');
                ctx.fillStyle = grassGradient;
                ctx.fillRect(p.x, p.y, p.width, 15 * scaleY);

                // Grass blades with varied colors (deterministic pattern based on position)
                const grassColors = ['#228B22', '#2E7D32', '#1B5E20'];
                const GRASS_COLOR_VARIATION = 0.1;
                const GRASS_HEIGHT_VARIATION = 0.1;
                const GRASS_BEND_VARIATION = 0.15;

                for (let i = p.x; i < p.x + p.width; i += 8 * scale) {
                    const colorIndex = Math.floor((i + p.y) * GRASS_COLOR_VARIATION) % grassColors.length;
                    ctx.strokeStyle = grassColors[colorIndex];
                    ctx.lineWidth = 1.5;
                    const heightSeed = Math.sin(i * GRASS_HEIGHT_VARIATION + p.y * 0.05) * 0.5 + 0.5;
                    const grassHeight = 4 + heightSeed * 3;
                    const bendSeed = Math.cos(i * GRASS_BEND_VARIATION) * 0.5 + 0.5;
                    ctx.beginPath();
                    ctx.moveTo(i + 2 * scale, p.y);
                    ctx.lineTo(i + 3 * scale + bendSeed * 2 * scale, p.y - grassHeight * scaleY);
                    ctx.stroke();
                }

                // Platform edge highlights
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(p.x, p.y + 1 * scaleY);
                ctx.lineTo(p.x + p.width, p.y + 1 * scaleY);
                ctx.stroke();

                // Platform outline
                ctx.strokeStyle = '#5D2E0C';
                ctx.lineWidth = 2;
                ctx.strokeRect(p.x, p.y, p.width, p.height);
            }

            // Darker bottom edge
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(p.x, p.y + p.height);
            ctx.lineTo(p.x + p.width, p.y + p.height);
            ctx.stroke();
        }

        // Generate scrolling level with scenery
        function generateLevel(levelNum) {
            platforms = [];
            grapes = [];
            sceneryElements = [];
            grapesCollected = 0;

            // World gets longer each level - increased base width for better mobile experience
            worldWidth = (2500 + levelNum * 600) * scaleX;

            const groundY = canvas.height * 0.86;
            const platHeight = 35 * scaleY; // Increased from 20 for better visibility

            // Ground platform spans entire world
            platforms.push({x: 0, y: groundY, width: worldWidth, height: canvas.height - groundY, isGround: true});

            // Level-specific scene themes
            const levelThemes = {
                1: 'countryside',  // Trees, shrubs, flowers, fences
                2: 'countryside',  // Same pastoral theme
                3: 'suburbs',      // Houses, mailboxes, small trees
                4: 'suburbs',      // More suburban
                5: 'downtown'      // Buildings, lamp posts, city
            };

            const theme = levelNum >= 10 ? 'hell' : (levelThemes[levelNum] || 'mainstreet');

            // Generate scenery based on theme
            generateScenery(theme, levelNum);

            // Generate platforms distributed across the world
            const platformCount = 3 + levelNum * 2;
            const spacing = worldWidth / (platformCount + 1);

            // Define lemonade stand area for level 1 (to avoid placing platforms over it)
            const lemonadeStandX = 400 * scaleX;
            const lemonadeStandWidth = 120 * scale; // Width of stand (matches drawing code)
            const lemonadeStandLeft = lemonadeStandX - 60 * scale - 20 * scale; // Left edge with buffer
            const lemonadeStandRight = lemonadeStandX + 60 * scale + 20 * scale; // Right edge with buffer

            for (let i = 0; i < platformCount; i++) {
                let px = spacing * (i + 0.5 + Math.random() * 0.5);
                const py = 0.45 + Math.random() * 0.25;  // Between 45% and 70% height
                // Increase minimum and maximum width for better playability on mobile/iOS
                const pw = 0.18 + Math.random() * 0.08;  // Platform width (increased for mobile)

                // For level 1, ensure platforms don't overlap with lemonade stand
                if (levelNum === 1) {
                    const platformWidth = pw * canvas.width;
                    // If platform would overlap with lemonade stand, shift it
                    if (px < lemonadeStandRight && px + platformWidth > lemonadeStandLeft) {
                        // Move platform to after the lemonade stand
                        px = lemonadeStandRight + 50 * scaleX;
                    }
                }

                platforms.push({
                    x: px,
                    y: py * canvas.height,
                    width: pw * canvas.width,
                    height: platHeight
                });
            }

            // Generate grapes distributed across the world
            const grapeCount = 4 + levelNum * 2;
            const grapeSpacing = worldWidth / (grapeCount + 1);

            for (let i = 0; i < grapeCount; i++) {
                const gx = grapeSpacing * (i + 0.3 + Math.random() * 0.4);

                // Some grapes on ground, some elevated (near platforms)
                let gy;
                if (Math.random() > 0.4) {
                    // Find a nearby platform
                    const nearPlatform = platforms.find(p => !p.isGround &&
                        Math.abs(p.x + p.width/2 - gx) < 150 * scaleX);
                    if (nearPlatform) {
                        gy = nearPlatform.y - 30 * scaleY;
                    } else {
                        gy = groundY - 40 * scaleY;
                    }
                } else {
                    gy = groundY - 40 * scaleY;
                }

                grapes.push({
                    x: gx,
                    y: gy,
                    size: 12,
                    collected: false
                });
            }

            totalGrapes = grapes.length;

            // Reset duck and camera
            duck.x = 50 * scaleX;
            duck.y = groundY - duck.height - 10;
            duck.vx = 0;
            duck.vy = 0;
            camera.x = 0;

            // Update gravity based on screen height
            gravity = 0.6 * scaleY;

            // Clear projectiles
            seeds = [];

            // Generate enemies (starting from level 5)
            enemies = [];
            if (levelNum >= 5) {
                const enemyCount = 2 + (levelNum - 5) * 2;  // More enemies at higher levels
                const enemySpacing = worldWidth / (enemyCount + 2);

                for (let i = 0; i < enemyCount; i++) {
                    const ex = enemySpacing * (i + 1.5 + Math.random() * 0.5);
                    let type;
                    if (levelNum >= 10) {
                        // Hell levels: mostly demons, some flyers
                        const demonRand = Math.random();
                        type = demonRand < 0.6 ? 'demon' : demonRand < 0.8 ? 'flyer' : 'walker';
                    } else {
                        const enemyTypes = ['walker', 'flyer', 'jumper'];
                        type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
                    }

                    enemies.push({
                        x: ex,
                        y: type === 'flyer' ? groundY - 150 * scaleY : type === 'demon' ? groundY - 35 * scaleY : groundY - 40 * scaleY,
                        width: type === 'demon' ? 55 * scale : 40 * scale,
                        height: type === 'demon' ? 60 * scale : 40 * scale,
                        vx: (Math.random() > 0.5 ? 1 : -1) * 2 * scaleX,
                        vy: 0,
                        type: type,
                        health: type === 'demon' ? 4 : type === 'flyer' ? 1 : 2,
                        jumpTimer: 0,
                        startX: ex,
                        patrolRange: type === 'demon' ? 300 * scaleX : 200 * scaleX
                    });
                }
            }

            // Generate lava lakes for hell levels (10+)
            lavaLakes = [];
            if (levelNum >= 10) {
                const lavaCount = 2 + (levelNum - 10);
                const lavaSpacing = worldWidth / (lavaCount + 2);
                for (let i = 0; i < lavaCount; i++) {
                    const lx = lavaSpacing * (i + 1.2 + Math.random() * 0.6);
                    const lw = (80 + Math.random() * 120) * scaleX;
                    lavaLakes.push({
                        x: lx,
                        width: lw,
                        bubbles: [] // animated bubble positions
                    });
                    // Pre-generate some bubbles
                    for (let b = 0; b < 5; b++) {
                        lavaLakes[i].bubbles.push({
                            bx: Math.random(),
                            timer: Math.random() * 100,
                            size: 2 + Math.random() * 4
                        });
                    }
                }
            }

            // Set up helicopter (available levels 6-9) or Doomslayer suit (levels 10+)
            if (levelNum >= 10) {
                // Doomslayer suit replaces helicopter for hell levels
                helicopter.available = false;
                helicopter.active = false;
                doomslayerSuit.available = true;
                doomslayerSuit.active = false;
                doomslayerSuit.pickedUp = false;
                doomslayerSuit.invincible = false;
                doomslayerSuit.pickupX = 250 * scaleX;
                doomslayerSuit.pickupY = groundY - 60 * scaleY;
            } else {
                helicopter.available = levelNum >= 6;
                helicopter.active = false;
                helicopter.fuel = helicopter.maxFuel;
                doomslayerSuit.available = false;
                doomslayerSuit.active = false;
                if (helicopter.available) {
                    // Place helicopter pickup near start
                    helicopter.pickupX = 200 * scaleX;
                    helicopter.pickupY = groundY - 80 * scaleY;
                    helicopter.pickedUp = false;
                }
            }

            // Reset hell embers on level change
            hellEmbers = [];
        }

        // Generate scenery elements based on theme (consistent throughout level)
        function generateScenery(theme, levelNum) {
            sceneryElements = [];
            const colors = ['#FF69B4', '#FF6347', '#FFD700', '#9370DB', '#00CED1'];
            const streetNames = ['MAIN ST', 'OAK AVE', 'PARK RD', 'ELM ST', 'GRAPE LN'];

            // Much denser scenery - smaller spacing between elements
            for (let x = 50; x < worldWidth; x += 30 + Math.random() * 50) {
                const rand = Math.random();

                // Use same theme throughout entire level
                if (theme === 'countryside') {
                    // Countryside elements - lots of nature
                    if (rand < 0.3) {
                        sceneryElements.push({type: 'tree', x: x, size: 0.6 + Math.random() * 0.6});
                    } else if (rand < 0.5) {
                        sceneryElements.push({type: 'shrub', x: x, size: 0.5 + Math.random() * 0.6});
                    } else if (rand < 0.7) {
                        sceneryElements.push({type: 'flower', x: x, color: colors[Math.floor(Math.random() * colors.length)]});
                    } else if (rand < 0.8) {
                        sceneryElements.push({type: 'fence', x: x, width: 60 + Math.random() * 60});
                        x += 40;
                    } else {
                        // Add extra flowers in gaps
                        sceneryElements.push({type: 'flower', x: x, color: colors[Math.floor(Math.random() * colors.length)]});
                    }
                } else if (theme === 'suburbs') {
                    // Suburban elements - houses, yards, trees
                    if (rand < 0.15) {
                        sceneryElements.push({type: 'house', x: x, style: Math.floor(Math.random() * 4)});
                        x += 80;
                    } else if (rand < 0.35) {
                        sceneryElements.push({type: 'tree', x: x, size: 0.5 + Math.random() * 0.4});
                    } else if (rand < 0.5) {
                        sceneryElements.push({type: 'shrub', x: x, size: 0.4 + Math.random() * 0.4});
                    } else if (rand < 0.6) {
                        sceneryElements.push({type: 'mailbox', x: x});
                    } else if (rand < 0.75) {
                        sceneryElements.push({type: 'flower', x: x, color: colors[Math.floor(Math.random() * colors.length)]});
                    } else if (rand < 0.85) {
                        sceneryElements.push({type: 'lamppost', x: x});
                    } else {
                        sceneryElements.push({type: 'fence', x: x, width: 40 + Math.random() * 40});
                        x += 30;
                    }
                } else if (theme === 'hell') {
                    // Hell elements - dark and menacing
                    if (rand < 0.2) {
                        sceneryElements.push({type: 'stalagmite', x: x, size: 0.5 + Math.random() * 1.0});
                    } else if (rand < 0.35) {
                        sceneryElements.push({type: 'deadTree', x: x, size: 0.6 + Math.random() * 0.5});
                    } else if (rand < 0.5) {
                        sceneryElements.push({type: 'skullPile', x: x});
                    } else if (rand < 0.6) {
                        sceneryElements.push({type: 'firePit', x: x});
                        x += 30;
                    } else if (rand < 0.75) {
                        sceneryElements.push({type: 'bonePile', x: x});
                    } else if (rand < 0.85) {
                        const hellTexts = ['DANGER', 'NO EXIT', 'ABANDON HOPE', 'TURN BACK', 'DOOMED'];
                        sceneryElements.push({type: 'hellSign', x: x, text: hellTexts[Math.floor(Math.random() * hellTexts.length)]});
                    } else {
                        sceneryElements.push({type: 'stalagmite', x: x, size: 0.3 + Math.random() * 0.5});
                    }
                } else if (theme === 'downtown') {
                    // Downtown elements - dense urban
                    if (rand < 0.25) {
                        sceneryElements.push({
                            type: 'building',
                            x: x,
                            width: 60 + Math.random() * 80,
                            height: 120 + Math.random() * 180,
                            style: Math.floor(Math.random() * 5)
                        });
                        x += 80;
                    } else if (rand < 0.45) {
                        sceneryElements.push({type: 'lamppost', x: x});
                    } else if (rand < 0.55) {
                        sceneryElements.push({type: 'hydrant', x: x});
                    } else if (rand < 0.7) {
                        sceneryElements.push({type: 'bench', x: x});
                    } else if (rand < 0.8) {
                        sceneryElements.push({type: 'sign', x: x, text: streetNames[Math.floor(Math.random() * streetNames.length)]});
                    } else {
                        sceneryElements.push({type: 'tree', x: x, size: 0.4 + Math.random() * 0.3});
                    }
                } else {
                    // Default - mix of everything
                    if (rand < 0.2) {
                        sceneryElements.push({type: 'tree', x: x, size: 0.6 + Math.random() * 0.4});
                    } else if (rand < 0.4) {
                        sceneryElements.push({type: 'shrub', x: x, size: 0.5 + Math.random() * 0.5});
                    } else if (rand < 0.5) {
                        sceneryElements.push({type: 'lamppost', x: x});
                    } else if (rand < 0.6) {
                        sceneryElements.push({type: 'bench', x: x});
                    } else {
                        sceneryElements.push({type: 'flower', x: x, color: colors[Math.floor(Math.random() * colors.length)]});
                    }
                }
            }

            // Always add lemonade stand near the start for level 1
            if (levelNum === 1) {
                // Mark position for lemonade stand
                sceneryElements.push({type: 'lemonadeStand', x: 400 * scaleX});
            }

            // Welcome to Hell sign at start of hell levels
            if (levelNum >= 10) {
                sceneryElements.push({type: 'hellWelcomeSign', x: 150 * scaleX});
            }

            // Add finish banner at the end of every level
            sceneryElements.push({type: 'finishBanner', x: worldWidth - 80 * scaleX});

            // Sort by x position for proper rendering order
            sceneryElements.sort((a, b) => a.x - b.x);
        }

        function checkPlatformCollision() {
            duck.onGround = false;

            for (const p of platforms) {
                if (duck.x + duck.width > p.x &&
                    duck.x < p.x + p.width &&
                    duck.y + duck.height > p.y &&
                    duck.y + duck.height < p.y + p.height + duck.vy + 5 &&
                    duck.vy >= 0) {

                    duck.y = p.y - duck.height;
                    duck.vy = 0;
                    duck.onGround = true;
                }
            }
        }

        function checkGrapeCollection() {
            for (const grape of grapes) {
                if (!grape.collected) {
                    const dx = (duck.x + duck.width/2) - grape.x;
                    const dy = (duck.y + duck.height/2) - grape.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);

                    if (dist < 40 * scale) {
                        grape.collected = true;
                        grapesCollected++;
                        totalGrapesCollected++;
                        showMessage("Got a grape!");
                        
                        // Create particle effect
                        createParticles(grape.x, grape.y, 15, 'grape');

                        // Check if all grapes collected - prompt to reach end
                        if (grapesCollected === totalGrapes) {
                            showMessage("All grapes! Reach the end!");
                        }
                    }
                }
            }
        }

        function showMessage(msg) {
            gameMessage = msg;
            messageTimer = 90;
        }

        // Demo AI - finds nearest uncollected grape and moves toward it
        function updateDemoAI() {
            if (!demoMode) return;

            // Find nearest uncollected grape (within reasonable range for demo)
            let nearestDist = Infinity;
            targetGrape = null;
            for (const grape of grapes) {
                if (!grape.collected) {
                    const dx = grape.x - (duck.x + duck.width/2);
                    const dy = grape.y - (duck.y + duck.height/2);
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    // Prefer grapes ahead and not too far
                    if (dist < nearestDist && dx > -200 * scaleX) {
                        nearestDist = dist;
                        targetGrape = grape;
                    }
                }
            }

            if (!targetGrape) {
                // All grapes collected or none ahead, reset level for demo
                generateLevel(level);
                camera.x = 0;
                return;
            }

            // Move toward target grape
            const dx = targetGrape.x - (duck.x + duck.width/2);
            const threshold = 20 * scaleX;

            if (dx > threshold) {
                duck.vx = duck.speed * 0.8;
                duck.facing = 1;
            } else if (dx < -threshold) {
                duck.vx = -duck.speed * 0.8;
                duck.facing = -1;
            } else {
                duck.vx *= friction;
            }

            // Jump logic
            demoJumpCooldown--;
            const needsToJumpUp = targetGrape.y < duck.y - 30 * scaleY;

            // Check if there's a platform above we need to reach
            let platformAbove = false;
            for (const p of platforms) {
                if (!p.isGround && p.y < duck.y && p.y > duck.y - 150 * scaleY &&
                    duck.x + duck.width > p.x - 50 * scaleX && duck.x < p.x + p.width + 50 * scaleX) {
                    platformAbove = true;
                    break;
                }
            }

            if (duck.onGround && demoJumpCooldown <= 0 && (needsToJumpUp || platformAbove)) {
                duck.vy = duck.jumpForce;
                duck.onGround = false;
                demoJumpCooldown = 30;
            }
        }

        function update() {
            // Run demo mode even when game not started
            if (demoMode && !gameRunning) {
                updateDemoAI();
            }

            // Player input only when game is running (not demo)
            if (gameRunning && !demoMode) {
                if (keys['ArrowLeft'] || keys['KeyA'] || keys['tiltLeft'] || keys['touchLeft']) {
                    duck.vx = -duck.speed * (keys['tiltLeft'] ? duck.tiltAmount : 1);
                    duck.facing = -1;
                } else if (keys['ArrowRight'] || keys['KeyD'] || keys['tiltRight'] || keys['touchRight']) {
                    duck.vx = duck.speed * (keys['tiltRight'] ? duck.tiltAmount : 1);
                    duck.facing = 1;
                } else {
                    duck.vx *= friction;
                }

                if ((keys['Space'] || keys['ArrowUp'] || keys['KeyW'] || keys['touchJump']) && duck.onGround && !helicopter.active) {
                    duck.vy = duck.jumpForce;
                    duck.onGround = false;
                    keys['touchJump'] = false; // Reset tap jump
                }

                // Shooting (X key or F key or touchShoot) - available from level 5
                if ((keys['KeyX'] || keys['KeyF'] || keys['touchShoot']) && level >= 5) {
                    const now = Date.now();
                    if (now - lastShotTime > SHOT_COOLDOWN) {
                        // Spawn seed at gun barrel tip (local coord 78,37 -> offset 53,7 from duck center)
                        seeds.push({
                            x: duck.x + duck.width / 2 + duck.facing * 53 * scale,
                            y: duck.y + duck.height / 2 + 7 * scale,
                            vx: duck.facing * 15 * scaleX,
                            vy: 0  // Straight shot, no arc
                        });
                        lastShotTime = now;
                    }
                    keys['touchShoot'] = false; // Reset touch shoot
                }

                // Helicopter controls (E key or touchHeli to toggle, Space to fly up when active)
                if ((keys['KeyE'] || keys['touchHeli']) && helicopter.available && !keys['helicopterToggled']) {
                    keys['helicopterToggled'] = true;
                    if (!helicopter.pickedUp) {
                        // Check if near helicopter pickup
                        const distToPickup = Math.abs(duck.x - helicopter.pickupX) + Math.abs(duck.y - helicopter.pickupY);
                        if (distToPickup < 100 * scale) {
                            helicopter.pickedUp = true;
                            helicopter.active = true;
                            showMessage("Helicopter activated! Space to fly!");
                        }
                    } else {
                        helicopter.active = !helicopter.active;
                        if (helicopter.active && helicopter.fuel > 0) {
                            showMessage("Helicopter ON");
                        } else {
                            showMessage("Helicopter OFF");
                        }
                    }
                }
                if (!keys['KeyE'] && !keys['touchHeli']) keys['helicopterToggled'] = false;

                // Doomslayer suit controls (levels 10+, replaces helicopter)
                if ((keys['KeyE'] || keys['touchHeli']) && doomslayerSuit.available && !keys['suitToggled']) {
                    keys['suitToggled'] = true;
                    if (!doomslayerSuit.pickedUp) {
                        // Check if near suit pickup
                        const distToPickup = Math.abs(duck.x - doomslayerSuit.pickupX) + Math.abs(duck.y - doomslayerSuit.pickupY);
                        if (distToPickup < 100 * scale) {
                            doomslayerSuit.pickedUp = true;
                            doomslayerSuit.active = true;
                            doomslayerSuit.invincible = true;
                            showMessage("RIP AND TEAR!");
                        }
                    } else {
                        doomslayerSuit.active = !doomslayerSuit.active;
                        doomslayerSuit.invincible = doomslayerSuit.active;
                        if (doomslayerSuit.active) {
                            showMessage("Suit ON - RIP AND TEAR!");
                        } else {
                            showMessage("Suit OFF");
                        }
                    }
                }
                if (!keys['KeyE'] && !keys['touchHeli']) keys['suitToggled'] = false;

                // Doomslayer suit - auto-activate in hell levels
                if (level >= 10 && doomslayerSuit.pickedUp) {
                    doomslayerSuit.active = true;
                    doomslayerSuit.invincible = true;
                } else if (level < 10) {
                    doomslayerSuit.active = false;
                    doomslayerSuit.invincible = false;
                }

                // Helicopter flying
                if (helicopter.active && helicopter.fuel > 0) {
                    if (keys['Space'] || keys['ArrowUp'] || keys['KeyW'] || keys['touchJump']) {
                        duck.vy = -6 * scaleY;  // Fly up
                        helicopter.fuel -= 0.3;
                    } else {
                        duck.vy += gravity * 0.3;  // Slow fall
                    }
                    // Helicopter uses fuel slowly even when not ascending
                    helicopter.fuel -= 0.05;
                    if (helicopter.fuel <= 0) {
                        helicopter.fuel = 0;
                        helicopter.active = false;
                        showMessage("Out of fuel!");
                    }
                }
            }

            // Apply gravity (reduced if helicopter active)
            if (!helicopter.active) {
                duck.vy += gravity;
            }
            duck.x += duck.vx;
            duck.y += duck.vy;

            // Boundaries - world coordinates
            if (duck.x < 0) duck.x = 0;
            if (duck.x + duck.width > worldWidth) duck.x = worldWidth - duck.width;

            // Fall off screen
            if (duck.y > canvas.height + 50) {
                const groundY = canvas.height * 0.86;
                duck.x = 50 * scaleX;
                duck.y = groundY - duck.height - 10;
                duck.vy = 0;
                camera.x = 0;
                if (gameRunning) showMessage("Whoops! Try again!");
            }

            // Check if reached end of level (when duck gets close to the end)
            if (gameRunning && !levelCompleting && duck.x > worldWidth - duck.width - 50 * scaleX && grapesCollected === totalGrapes) {
                levelCompleting = true;
                if (level >= MAX_LEVEL) {
                    showMessage("You Win! All 15 levels complete!");
                    setTimeout(() => {
                        gameRunning = false;
                        levelCompleting = false;
                        document.getElementById('totalGrapes').textContent = totalGrapesCollected;
                        winScreen.classList.remove('hidden');
                    }, 1500);
                } else {
                    showMessage("Level Complete! Onward!");
                    setTimeout(() => {
                        level++;
                        levelCompleting = false;
                        generateLevel(level);
                    }, 1500);
                }
            }

            // Walk animation
            if (Math.abs(duck.vx) > 0.5) {
                duck.walkTimer++;
                if (duck.walkTimer > 5) {
                    duck.walkFrame++;
                    duck.walkTimer = 0;
                }
            } else {
                duck.walkFrame = 0;
            }

            checkPlatformCollision();

            // Check lava collision (hell levels)
            if (gameRunning) checkLavaCollision();

            // Update seeds (projectiles)
            for (let i = seeds.length - 1; i >= 0; i--) {
                const seed = seeds[i];
                seed.x += seed.vx;
                seed.y += seed.vy;

                // Remove if off screen
                if (seed.x < camera.x - 50 || seed.x > camera.x + canvas.width + 50 ||
                    seed.y > canvas.height) {
                    seeds.splice(i, 1);
                    continue;
                }

                // Check collision with enemies
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    const dx = seed.x - enemy.x;
                    const dy = seed.y - enemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 30 * scale) {
                        enemy.health--;
                        seeds.splice(i, 1);
                        if (enemy.health <= 0) {
                            enemies.splice(j, 1);
                            showMessage("Enemy defeated!");
                        }
                        break;
                    }
                }
            }

            // Update enemies
            const groundY = canvas.height * 0.86;
            for (const enemy of enemies) {
                if (enemy.type === 'demon') {
                    // Demon: patrols, but charges toward duck when close
                    const distToDuck = Math.abs(duck.x - enemy.x);
                    if (gameRunning && distToDuck < 300 * scaleX) {
                        // Charge toward duck
                        const dir = duck.x > enemy.x ? 1 : -1;
                        enemy.vx = dir * 3.5 * scaleX;
                    } else {
                        // Normal patrol
                        if (Math.abs(enemy.x - enemy.startX) > enemy.patrolRange) {
                            enemy.vx = -enemy.vx;
                        }
                        // Ensure patrol speed
                        if (Math.abs(enemy.vx) < 1.5 * scaleX) {
                            enemy.vx = (enemy.vx >= 0 ? 1 : -1) * 2 * scaleX;
                        }
                    }
                    enemy.x += enemy.vx;
                    enemy.y = groundY - 35 * scale;
                } else if (enemy.type === 'walker') {
                    // Patrol back and forth
                    enemy.x += enemy.vx;
                    if (Math.abs(enemy.x - enemy.startX) > enemy.patrolRange) {
                        enemy.vx = -enemy.vx;
                    }
                    enemy.y = groundY - 25 * scale;
                } else if (enemy.type === 'flyer') {
                    // Fly in a sine wave pattern
                    enemy.x += enemy.vx;
                    enemy.y = groundY - 150 * scaleY + Math.sin(Date.now() * 0.003 + enemy.startX) * 50 * scaleY;
                    if (Math.abs(enemy.x - enemy.startX) > enemy.patrolRange) {
                        enemy.vx = -enemy.vx;
                    }
                } else if (enemy.type === 'jumper') {
                    // Jump periodically
                    enemy.x += enemy.vx * 0.5;
                    enemy.vy += gravity;
                    enemy.y += enemy.vy;
                    if (enemy.y > groundY - 20 * scale) {
                        enemy.y = groundY - 20 * scale;
                        enemy.vy = 0;
                        enemy.jumpTimer++;
                        if (enemy.jumpTimer > 60) {
                            enemy.vy = -12 * scaleY;
                            enemy.jumpTimer = 0;
                        }
                    }
                    if (Math.abs(enemy.x - enemy.startX) > enemy.patrolRange) {
                        enemy.vx = -enemy.vx;
                    }
                }

                // Check collision with duck
                if (gameRunning) {
                    const dx = (duck.x + duck.width / 2) - enemy.x;
                    const dy = (duck.y + duck.height / 2) - enemy.y;
                    const hitRange = enemy.type === 'demon' ? 50 * scale : 40 * scale;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < hitRange) {
                        if (doomslayerSuit.active && doomslayerSuit.invincible) {
                            // Suit destroys enemies on contact
                            createParticles(enemy.x, enemy.y, 15, 'gold');
                            enemies.splice(enemies.indexOf(enemy), 1);
                            showMessage("RIP AND TEAR!");
                            break; // Enemy removed, exit loop safely
                        } else {
                            // Duck hit by enemy - reset position
                            duck.x = 50 * scaleX;
                            duck.y = groundY - duck.height - 10;
                            duck.vx = 0;
                            duck.vy = 0;
                            camera.x = 0;
                            helicopter.active = false;
                            doomslayerSuit.active = false;
                            doomslayerSuit.invincible = false;
                            showMessage("Ouch! Watch out for enemies!");
                        }
                    }
                }
            }

            // Only collect grapes and update UI when game is running
            if (gameRunning) {
                checkGrapeCollection();
                grapeCountEl.textContent = grapesCollected + '/' + totalGrapes;
                levelNumEl.textContent = level;
            } else if (demoMode) {
                // Demo mode grape collection (just for show, resets)
                for (const grape of grapes) {
                    if (!grape.collected) {
                        const dx = (duck.x + duck.width/2) - grape.x;
                        const dy = (duck.y + duck.height/2) - grape.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < 40 * scale) {
                            grape.collected = true;
                        }
                    }
                }
            }

            if (messageTimer > 0) messageTimer--;
            
            // Update particles
            updateParticles();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Update camera to follow duck
            updateCamera();

            const groundY = canvas.height * 0.86;

            // Draw programmatic backgrounds
            drawBackgrounds();

            // Level indicator (fixed on screen)
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.font = `bold ${50 * scale}px Comic Sans MS`;
            ctx.textAlign = 'center';
            ctx.fillText('LEVEL ' + level, canvas.width/2, canvas.height * 0.55);

            // Draw lava lakes (hell levels, after ground but before scenery)
            if (level >= 10) drawLavaLakes();

            // Draw scenery elements (with camera offset)
            for (const elem of sceneryElements) {
                const screenX = elem.x - camera.x;
                if (screenX > -200 * scale && screenX < canvas.width + 200 * scale) {
                    if (elem.type === 'lemonadeStand') {
                        drawLemonadeStandAt(screenX);
                    } else {
                        drawSceneryElement(elem, screenX);
                    }
                }
            }

            // Platforms (skip ground, apply camera offset)
            for (const p of platforms) {
                if (!p.isGround) {
                    const screenX = p.x - camera.x;
                    // Only draw if on screen
                    if (screenX + p.width > 0 && screenX < canvas.width) {
                        drawPlatform({...p, x: screenX});
                    }
                }
            }

            // Grapes (with camera offset)
            for (const grape of grapes) {
                if (!grape.collected) {
                    const screenX = grape.x - camera.x;
                    if (screenX > -30 && screenX < canvas.width + 30) {
                        drawGrape(screenX, grape.y, grape.size);
                    }
                }
            }

            // Helicopter pickup (if available and not picked up)
            if (helicopter.available && !helicopter.pickedUp) {
                const heliScreenX = helicopter.pickupX - camera.x;
                if (heliScreenX > -100 && heliScreenX < canvas.width + 100) {
                    drawHelicopter(heliScreenX, helicopter.pickupY, true);
                }
            }

            // Doomslayer suit pickup (hell levels, if available and not picked up)
            if (doomslayerSuit.available && !doomslayerSuit.pickedUp) {
                const suitScreenX = doomslayerSuit.pickupX - camera.x;
                if (suitScreenX > -100 && suitScreenX < canvas.width + 100) {
                    drawDoomslayerPickup(suitScreenX, doomslayerSuit.pickupY);
                }
            }

            // Enemies (with camera offset)
            for (const enemy of enemies) {
                const screenX = enemy.x - camera.x;
                if (screenX > -50 && screenX < canvas.width + 50) {
                    drawEnemy(enemy, screenX);
                }
            }

            // Seeds/projectiles (with camera offset)
            for (const seed of seeds) {
                const screenX = seed.x - camera.x;
                if (screenX > -20 && screenX < canvas.width + 20) {
                    drawSeed(screenX, seed.y);
                }
            }

            // Duck (with camera offset) - hide when in helicopter
            const duckScreenX = duck.x - camera.x;
            if (helicopter.active) {
                // Draw helicopter with duck inside (duck hidden), facing duck's direction
                drawHelicopter(duckScreenX + duck.width / 2, duck.y + duck.height / 2, false, duck.facing);
            } else if (doomslayerSuit.active && doomslayerSuit.invincible) {
                // Draw Doomslayer suit with duck inside (duck hidden), facing duck's direction
                drawDoomslayerSuit(duckScreenX + duck.width / 2, duck.y + duck.height / 2, duck.facing);
            } else {
                // Draw duck normally (with gun if level 5+)
                drawDuck(duckScreenX, duck.y, duck.facing, duck.walkFrame, level >= 5);
            }

            // Speech bubble when near lemonade stand
            const standElem = sceneryElements.find(e => e.type === 'lemonadeStand');
            if (standElem) {
                const standScreenX = standElem.x - camera.x;
                if (Math.abs(duckScreenX - standScreenX) < 100 * scale && duck.y > canvas.height * 0.7) {
                    const bubbleX = standScreenX + 60 * scale;
                    const bubbleY = canvas.height * 0.5;
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.ellipse(bubbleX, bubbleY, 70 * scale, 30 * scale, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.moveTo(bubbleX - 20 * scale, bubbleY + 25 * scale);
                    ctx.lineTo(bubbleX - 10 * scale, bubbleY + 40 * scale);
                    ctx.lineTo(bubbleX, bubbleY + 25 * scale);
                    ctx.fill();
                    ctx.stroke();

                    ctx.fillStyle = '#000';
                    ctx.font = `bold ${12 * scale}px Comic Sans MS`;
                    ctx.textAlign = 'center';
                    ctx.fillText("We only sell", bubbleX, bubbleY - 5 * scale);
                    ctx.fillText("LEMONADE!", bubbleX, bubbleY + 10 * scale);
                }
            }

            // Progress indicator (how far through level)
            const progress = Math.min(duck.x / (worldWidth - canvas.width * 0.5), 1);
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(10 * scale, canvas.height - 20 * scaleY, 100 * scale, 8 * scaleY);
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(10 * scale, canvas.height - 20 * scaleY, progress * 100 * scale, 8 * scaleY);

            // Gun indicator (level 5+)
            if (level >= 5 && gameRunning) {
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(canvas.width - 120 * scale, canvas.height - 50 * scaleY, 110 * scale, 40 * scaleY);
                ctx.fillStyle = '#F5DEB3';
                ctx.font = `bold ${12 * scale}px Comic Sans MS`;
                ctx.textAlign = 'left';
                ctx.fillText('SEED GUN', canvas.width - 115 * scale, canvas.height - 32 * scaleY);
                ctx.fillStyle = '#FFF';
                ctx.font = `${10 * scale}px Comic Sans MS`;
                ctx.fillText('X/F or TAP to shoot', canvas.width - 115 * scale, canvas.height - 18 * scaleY);
            }

            // Helicopter fuel indicator (level 6-9)
            if (helicopter.available && helicopter.pickedUp && gameRunning) {
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(canvas.width - 120 * scale, canvas.height - 95 * scaleY, 110 * scale, 40 * scaleY);
                ctx.fillStyle = '#4169E1';
                ctx.font = `bold ${12 * scale}px Comic Sans MS`;
                ctx.textAlign = 'left';
                ctx.fillText('HELICOPTER', canvas.width - 115 * scale, canvas.height - 77 * scaleY);
                // Fuel bar
                ctx.fillStyle = '#333';
                ctx.fillRect(canvas.width - 115 * scale, canvas.height - 68 * scaleY, 100 * scale, 8 * scaleY);
                ctx.fillStyle = helicopter.fuel > 20 ? '#32CD32' : '#FF4500';
                ctx.fillRect(canvas.width - 115 * scale, canvas.height - 68 * scaleY, (helicopter.fuel / helicopter.maxFuel) * 100 * scale, 8 * scaleY);
                ctx.fillStyle = '#FFF';
                ctx.font = `${9 * scale}px Comic Sans MS`;
                ctx.fillText('E or TAP to toggle', canvas.width - 115 * scale, canvas.height - 55 * scaleY);
            }

            // Doomslayer suit duration indicator (level 10+)
            if (doomslayerSuit.available && doomslayerSuit.pickedUp && gameRunning) {
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(canvas.width - 120 * scale, canvas.height - 95 * scaleY, 110 * scale, 40 * scaleY);
                ctx.fillStyle = '#00FF44';
                ctx.font = `bold ${12 * scale}px Comic Sans MS`;
                ctx.textAlign = 'left';
                ctx.fillText('DOOM SUIT', canvas.width - 115 * scale, canvas.height - 77 * scaleY);
                // Duration bar
                ctx.fillStyle = '#333';
                ctx.fillRect(canvas.width - 115 * scale, canvas.height - 68 * scaleY, 100 * scale, 8 * scaleY);
                // Doomslayer suit indicator (always full when active since no fuel)
                ctx.fillStyle = '#999';
                ctx.fillRect(canvas.width - 115 * scale, canvas.height - 68 * scaleY, 100 * scale, 8 * scaleY);
                ctx.fillStyle = doomslayerSuit.active ? '#00FF44' : '#666';
                ctx.fillRect(canvas.width - 115 * scale, canvas.height - 68 * scaleY, 100 * scale, 8 * scaleY);
                ctx.fillStyle = '#FFF';
                ctx.font = `${9 * scale}px Comic Sans MS`;
                ctx.fillText(doomslayerSuit.active ? 'ACTIVE' : 'E or TAP to toggle', canvas.width - 115 * scale, canvas.height - 55 * scaleY);
            }

            // End zone indicator (arrow pointing right at edge of screen when near end)
            if (duck.x > worldWidth - canvas.width * 1.5) {
                const arrowX = canvas.width - 30 * scale;
                const arrowY = canvas.height * 0.5;
                const pulse = Math.sin(Date.now() * 0.005) * 5 * scale;

                // Arrow glow
                ctx.fillStyle = grapesCollected === totalGrapes ? 'rgba(50, 205, 50, 0.5)' : 'rgba(255, 215, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(arrowX + pulse, arrowY, 25 * scale, 0, Math.PI * 2);
                ctx.fill();

                // Arrow
                ctx.fillStyle = grapesCollected === totalGrapes ? '#32CD32' : '#FFD700';
                ctx.beginPath();
                ctx.moveTo(arrowX - 15 * scale + pulse, arrowY - 12 * scale);
                ctx.lineTo(arrowX + 15 * scale + pulse, arrowY);
                ctx.lineTo(arrowX - 15 * scale + pulse, arrowY + 12 * scale);
                ctx.closePath();
                ctx.fill();

                // "FINISH" text when all grapes collected
                if (grapesCollected === totalGrapes) {
                    ctx.fillStyle = '#32CD32';
                    ctx.font = `bold ${14 * scale}px Comic Sans MS`;
                    ctx.textAlign = 'center';
                    ctx.fillText('FINISH!', arrowX, arrowY + 35 * scale);
                }
            }

            // Particles (draw after characters but before UI)
            drawParticles();

            // Message
            if (messageTimer > 0) {
                const msgW = 400 * scaleX;
                const msgH = 50 * scaleY;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect((canvas.width - msgW) / 2, 20 * scaleY, msgW, msgH);
                ctx.fillStyle = '#FFD700';
                ctx.font = `bold ${24 * scale}px Comic Sans MS`;
                ctx.textAlign = 'center';
                ctx.fillText(gameMessage, canvas.width / 2, 20 * scaleY + msgH * 0.65);
            }

        }

        // Draw lemonade stand at specific screen X position
        function drawLemonadeStandAt(screenX) {
            const groundY = canvas.height * 0.86;
            const s = scale;
            const x = screenX - 60 * s;
            const y = groundY - 150 * s;

            // Stand base
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(x, y + 70*s, 120*s, 80*s);
            ctx.strokeStyle = '#5D2E0C';
            ctx.lineWidth = 3;
            ctx.strokeRect(x, y + 70*s, 120*s, 80*s);

            // Counter top
            ctx.fillStyle = '#A0522D';
            ctx.fillRect(x - 5*s, y + 65*s, 130*s, 10*s);

            // Sign board
            ctx.fillStyle = '#FFFACD';
            ctx.fillRect(x + 10*s, y - 35*s, 100*s, 45*s);
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 3;
            ctx.strokeRect(x + 10*s, y - 35*s, 100*s, 45*s);

            // Sign text
            ctx.fillStyle = '#228B22';
            ctx.font = `bold ${11*s}px Comic Sans MS`;
            ctx.textAlign = 'center';
            ctx.fillText('FRESH', x + 60*s, y - 18*s);
            ctx.fillStyle = '#FFD700';
            ctx.font = `bold ${14*s}px Comic Sans MS`;
            ctx.fillText('LEMONADE', x + 60*s, y - 2*s);
            ctx.fillStyle = '#228B22';
            ctx.font = `bold ${9*s}px Comic Sans MS`;
            ctx.fillText('25¬¢', x + 60*s, y + 8*s);

            // Roof poles
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 5*s;
            ctx.beginPath();
            ctx.moveTo(x + 20*s, y - 35*s);
            ctx.lineTo(x + 20*s, y + 70*s);
            ctx.moveTo(x + 100*s, y - 35*s);
            ctx.lineTo(x + 100*s, y + 70*s);
            ctx.stroke();

            // Pile of lemons on the left side of counter
            function drawLemon(lx, ly, size, rotation) {
                ctx.save();
                ctx.translate(lx, ly);
                ctx.rotate(rotation);
                ctx.fillStyle = '#FFE135';
                ctx.beginPath();
                ctx.ellipse(0, 0, size * 8 * s, size * 5 * s, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#DAA520';
                ctx.lineWidth = 1;
                ctx.stroke();
                // Lemon tip
                ctx.fillStyle = '#CCBF00';
                ctx.beginPath();
                ctx.ellipse(size * 7 * s, 0, size * 2 * s, size * 2 * s, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
            // Bottom layer
            drawLemon(x + 25*s, y + 58*s, 1, 0.2);
            drawLemon(x + 40*s, y + 60*s, 0.9, -0.3);
            drawLemon(x + 18*s, y + 62*s, 0.85, 0.5);
            // Top layer
            drawLemon(x + 30*s, y + 52*s, 0.8, -0.1);
            drawLemon(x + 22*s, y + 54*s, 0.75, 0.4);

            // Glass pitcher with lemonade
            // Pitcher body (glass)
            ctx.fillStyle = 'rgba(255, 255, 200, 0.9)';
            ctx.beginPath();
            ctx.moveTo(x + 70*s, y + 35*s);
            ctx.lineTo(x + 65*s, y + 65*s);
            ctx.lineTo(x + 95*s, y + 65*s);
            ctx.lineTo(x + 90*s, y + 35*s);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#87CEEB';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Lemonade liquid inside
            ctx.fillStyle = '#FFEB3B';
            ctx.beginPath();
            ctx.moveTo(x + 67*s, y + 42*s);
            ctx.lineTo(x + 65*s, y + 65*s);
            ctx.lineTo(x + 95*s, y + 65*s);
            ctx.lineTo(x + 92*s, y + 42*s);
            ctx.closePath();
            ctx.fill();

            // Lemon slices floating in pitcher
            ctx.fillStyle = '#FFE135';
            ctx.beginPath();
            ctx.arc(x + 75*s, y + 50*s, 4*s, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#DAA520';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(x + 85*s, y + 55*s, 3*s, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Ice cubes
            ctx.fillStyle = 'rgba(200, 230, 255, 0.7)';
            ctx.fillRect(x + 70*s, y + 45*s, 5*s, 5*s);
            ctx.fillRect(x + 82*s, y + 48*s, 4*s, 4*s);
            ctx.fillRect(x + 76*s, y + 56*s, 5*s, 5*s);

            // Pitcher handle
            ctx.strokeStyle = '#87CEEB';
            ctx.lineWidth = 3*s;
            ctx.beginPath();
            ctx.arc(x + 98*s, y + 50*s, 8*s, -Math.PI/2, Math.PI/2);
            ctx.stroke();

            // Pitcher spout
            ctx.fillStyle = 'rgba(255, 255, 200, 0.9)';
            ctx.beginPath();
            ctx.moveTo(x + 70*s, y + 35*s);
            ctx.lineTo(x + 62*s, y + 30*s);
            ctx.lineTo(x + 68*s, y + 35*s);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Lemonade man (behind counter)
            ctx.fillStyle = '#FDBF6F';
            ctx.beginPath();
            ctx.arc(x + 60*s, y + 30*s, 15*s, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Hair
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.arc(x + 60*s, y + 22*s, 14*s, Math.PI, 2 * Math.PI);
            ctx.fill();

            // Eyes
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(x + 55*s, y + 28*s, 4*s, 0, Math.PI * 2);
            ctx.arc(x + 65*s, y + 28*s, 4*s, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(x + 55*s, y + 28*s, 2*s, 0, Math.PI * 2);
            ctx.arc(x + 65*s, y + 28*s, 2*s, 0, Math.PI * 2);
            ctx.fill();

            // Smile (happy expression)
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x + 60*s, y + 35*s, 5*s, 0.2 * Math.PI, 0.8 * Math.PI);
            ctx.stroke();

            // Apron
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(x + 48*s, y + 45*s, 24*s, 25*s);
            ctx.strokeStyle = '#DDD';
            ctx.lineWidth = 1;
            ctx.strokeRect(x + 48*s, y + 45*s, 24*s, 25*s);
        }

        function gameLoop() {
            update();
            draw();
            updateMobileButtons(); // Update button states each frame
            requestAnimationFrame(gameLoop);
        }

        function showLevelSelector() {
            startScreen.classList.add('hidden');
            levelSelector.classList.remove('hidden');
        }

        function hideLevelSelector() {
            levelSelector.classList.add('hidden');
            startScreen.classList.remove('hidden');
        }

        function startGameFromLevel(startLevel) {
            levelSelector.classList.add('hidden');
            winScreen.classList.add('hidden');

            level = startLevel;
            totalGrapesCollected = 0;
            demoMode = false;
            generateLevel(startLevel);
            gameRunning = true;

            // Request motion permission on game start (works on iOS)
            requestMotionPermission();

            // Auto-play music when game starts
            if (!musicPlaying) {
                bgMusic.play().catch(e => console.log('Audio play failed:', e));
                musicBtn.textContent = 'Music: ON';
                musicPlaying = true;
            }
        }

        function startGame() {
            startGameFromLevel(1);
        }

        // Event listeners
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        // Mobile touch controls - tap to jump, touch sides to move (fallback if no tilt)
        let activeTouchId = null;

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.changedTouches[0];
            const rect = canvas.getBoundingClientRect();
            const x = (touch.clientX - rect.left) / rect.width;
            const y = (touch.clientY - rect.top) / rect.height;

            // Check if tapping on gun button (lower right, above 0.9 height)
            if (level >= 5 && gameRunning && x > 0.85 && y > 0.9 && y < 0.98) {
                keys['touchShoot'] = true;
                return;
            }

            // Check if tapping on helicopter button (lower right, above gun button)
            if (helicopter.available && gameRunning && x > 0.85 && y > 0.81 && y < 0.9) {
                keys['touchHeli'] = true;
                setTimeout(() => keys['touchHeli'] = false, 100);
                return;
            }

            // Touch controls work alongside tilt for better control
            activeTouchId = touch.identifier;
            
            // Bottom 25% of screen: directional controls (left/right/jump)
            if (y > 0.75) {
                if (x < 0.3) {
                    keys['touchLeft'] = true;
                    keys['touchRight'] = false;
                } else if (x > 0.7) {
                    keys['touchRight'] = true;
                    keys['touchLeft'] = false;
                } else {
                    // Middle bottom = jump
                    keys['touchJump'] = true;
                }
            } else {
                // Tap anywhere else to jump
                keys['touchJump'] = true;
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (activeTouchId !== null) {
                for (const touch of e.changedTouches) {
                    if (touch.identifier === activeTouchId) {
                        const rect = canvas.getBoundingClientRect();
                        const x = (touch.clientX - rect.left) / rect.width;
                        const y = (touch.clientY - rect.top) / rect.height;
                        
                        // Only update directional controls in bottom 25%
                        if (y > 0.75) {
                            if (x < 0.3) {
                                keys['touchLeft'] = true;
                                keys['touchRight'] = false;
                            } else if (x > 0.7) {
                                keys['touchRight'] = true;
                                keys['touchLeft'] = false;
                            } else {
                                keys['touchLeft'] = false;
                                keys['touchRight'] = false;
                            }
                        }
                    }
                }
            }
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            for (const touch of e.changedTouches) {
                if (touch.identifier === activeTouchId) {
                    activeTouchId = null;
                    keys['touchLeft'] = false;
                    keys['touchRight'] = false;
                }
            }
        });

        // Tilt controls for movement (uses device orientation)
        let tiltEnabled = false;
        let tiltSensitivity = 0.5; // 0.1 to 1.0, controlled by slider
        const tiltDeadzone = 5; // degrees of deadzone before movement starts
        const tiltMaxAngle = 20; // degrees at which full speed is reached

        // Sensitivity slider handler
        const sensitivitySlider = document.getElementById('tiltSensitivity');
        const sensitivityValue = document.getElementById('sensitivityValue');
        sensitivitySlider.addEventListener('input', (e) => {
            tiltSensitivity = e.target.value / 100;
            sensitivityValue.textContent = e.target.value;
        });

        function handleOrientation(e) {
            if (!gameRunning || demoMode) return;

            // gamma is left-right tilt (-90 to 90)
            let tilt = e.gamma || 0;

            // Apply sensitivity - lower sensitivity = need more tilt
            const adjustedDeadzone = tiltDeadzone + (1 - tiltSensitivity) * 10;
            const adjustedMaxAngle = tiltMaxAngle + (1 - tiltSensitivity) * 20;

            // Handle device held in portrait mode
            if (tilt > adjustedDeadzone) {
                // Tilted right
                keys['tiltRight'] = true;
                keys['tiltLeft'] = false;
                duck.tiltAmount = Math.min((tilt - adjustedDeadzone) / (adjustedMaxAngle - adjustedDeadzone), 1);
                // Allow speed to vary from slow to fast based on tilt angle (removed artificial minimum)
            } else if (tilt < -adjustedDeadzone) {
                // Tilted left
                keys['tiltLeft'] = true;
                keys['tiltRight'] = false;
                duck.tiltAmount = Math.min((-tilt - adjustedDeadzone) / (adjustedMaxAngle - adjustedDeadzone), 1);
                // Allow speed to vary from slow to fast based on tilt angle (removed artificial minimum)
            } else {
                keys['tiltLeft'] = false;
                keys['tiltRight'] = false;
                duck.tiltAmount = 0;
            }
        }

        // Request permission for device orientation (required on iOS 13+)
        function requestMotionPermission() {
            if (typeof DeviceOrientationEvent !== 'undefined' &&
                typeof DeviceOrientationEvent.requestPermission === 'function') {
                // iOS 13+ requires permission request
                DeviceOrientationEvent.requestPermission()
                    .then(response => {
                        if (response === 'granted') {
                            window.addEventListener('deviceorientation', handleOrientation);
                            tiltEnabled = true;
                        }
                    })
                    .catch(err => console.log('Motion permission error:', err));
            } else if (window.DeviceOrientationEvent) {
                // Non-iOS or older iOS - just add listener
                window.addEventListener('deviceorientation', handleOrientation);
                tiltEnabled = true;
            }
        }

        // Request permission on first user interaction (required for iOS)
        function initMotionOnce() {
            requestMotionPermission();
            document.removeEventListener('touchstart', initMotionOnce);
            document.removeEventListener('click', initMotionOnce);
        }
        document.addEventListener('touchstart', initMotionOnce, { once: true });
        document.addEventListener('click', initMotionOnce, { once: true });

        // Mobile action button controls
        const helicopterBtn = document.getElementById('helicopterBtn');
        const shootBtn = document.getElementById('shootBtn');

        // Helicopter / Doomslayer suit button - toggle on/off
        helicopterBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (!helicopterBtn.classList.contains('disabled')) {
                if (doomslayerSuit.available) {
                    // Doomslayer suit logic (levels 10+)
                    if (!keys['suitToggled']) {
                        keys['suitToggled'] = true;
                        if (!doomslayerSuit.pickedUp) {
                            const distToPickup = Math.abs(duck.x - doomslayerSuit.pickupX) + Math.abs(duck.y - doomslayerSuit.pickupY);
                            if (distToPickup < 100 * scale) {
                                doomslayerSuit.pickedUp = true;
                                doomslayerSuit.active = true;
                                doomslayerSuit.invincible = true;
                                showMessage("RIP AND TEAR!");
                            }
                        } else {
                            doomslayerSuit.active = !doomslayerSuit.active;
                            doomslayerSuit.invincible = doomslayerSuit.active;
                            if (doomslayerSuit.active) {
                                showMessage("Suit ON - RIP AND TEAR!");
                            } else {
                                showMessage("Suit OFF");
                            }
                        }
                    }
                } else if (helicopter.available) {
                    // Helicopter logic (levels 6-9)
                    if (!keys['helicopterToggled']) {
                        keys['helicopterToggled'] = true;
                        if (!helicopter.pickedUp) {
                            const distToPickup = Math.abs(duck.x - helicopter.pickupX) + Math.abs(duck.y - helicopter.pickupY);
                            if (distToPickup < 100 * scale) {
                                helicopter.pickedUp = true;
                                helicopter.active = true;
                                showMessage("Helicopter activated! Space to fly!");
                            }
                        } else {
                            helicopter.active = !helicopter.active;
                            if (helicopter.active && helicopter.fuel > 0) {
                                showMessage("Helicopter ON");
                            } else {
                                showMessage("Helicopter OFF");
                            }
                        }
                    }
                }
            }
        });

        helicopterBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            keys['helicopterToggled'] = false;
            keys['suitToggled'] = false;
        });

        // Shoot button - press to shoot
        shootBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (!shootBtn.classList.contains('disabled') && level >= 5) {
                keys['KeyX'] = true;
            }
        });
        
        shootBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            keys['KeyX'] = false;
        });

        // Update mobile button states based on game progress
        function updateMobileButtons() {
            // Shooting available from level 5
            if (level >= 5 && gameRunning) {
                shootBtn.classList.remove('disabled');
            } else {
                shootBtn.classList.add('disabled');
            }

            // Helicopter (levels 6-9) or Doomslayer suit (levels 10+)
            if (level >= 10 && doomslayerSuit.available && gameRunning) {
                helicopterBtn.classList.remove('disabled');
                helicopterBtn.textContent = '\u{1F6E1}'; // shield emoji
                helicopterBtn.title = 'Doomslayer Suit (Level 10+)';
            } else if (level >= 6 && helicopter.available && gameRunning) {
                helicopterBtn.classList.remove('disabled');
                helicopterBtn.textContent = '\u{1F681}'; // helicopter emoji
                helicopterBtn.title = 'Helicopter (Level 6+)';
            } else {
                helicopterBtn.classList.add('disabled');
            }
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            resizeCanvas();
            generateLevel(level); // Regenerate level for new dimensions
        });

        // Handle iOS Safari viewport changes (address bar show/hide)
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', () => {
                resizeCanvas();
            });
        }

        // Initialize
        resizeCanvas();
        generateLevel(1);
        gameLoop();
    </script>
</body>
</html>
